var searchModuleIndex = ["vsl","blas","blas.vlas","blas.vlas.internal.float64","consts","deriv","diff","dist","easings","errno","fit","fun","gm","graph","internal","iter","la","ml","poly","quaternion","roots","stats","util","vmath","vmath.bits","vmath.complex","vmath.fractions",];
var searchIndex = ["ArbitraryFn","DfFn","FdfFn","VectorValuedFn","Function","eval","safe_eval","FunctionFdf","eval_f","eval_df","eval_f_df","FunctionVec","eval","c_trans","c_uplo","l_uplo","job_vlr","slice_to_col_major","col_major_to_slice","print_col_major","print_col_major_v","print_col_major_py","slice_to_col_major_complex","col_major_complex_to_slice","print_col_major_complex","print_col_major_complex_v","print_col_major_omplex_py","get_join_complex","get_split_complex","join_complex","split_complex","extract_row","extract_col","extract_row_complex","extract_col_complex","eigenvecs_build","eigenvecs_build_both","dgesv","dgesvd","dgetrf","dgetri","dpotrf","dgeev","dlange","set_num_threads","ddot","dscal","daxpy","dgemv","dgemm","dger","dnrm2","dsyrk","Transpose","Uplo","Diagonal","dgemm","dgemv","dnrm2","dasum","idamax","dswap","dcopy","daxpy","drotg","drot","dscal","ddot","dger","dgbmv","dtrmv","dtrsv","dsymv","dtbmv","dtpmv","dtbsv","dsbmv","dsyr","dsyr2","dtpsv","dspmv","dspr","dspr2","dsyrk","axpy_unitary","axpy_unitary_to","axpy_inc","axpy_inc_to","dot_unitary","dot_inc","ger","gemv_n","gemv_t","l2_norm_unitary","l2_norm_inc","l2_distance_unitary","scal_unitary","scal_unitary_to","scal_inc","scal_inc_to","central","forward","backward","backward","forward","central","text_hist","build_text_hist","Histogram","find_bin","count","gen_labels","density_area","new_histogram","EasingFn","linear_interpolation","quadratic_ease_in","quadratic_ease_out","quadratic_ease_in_out","cubic_ease_in","cubic_ease_out","cubic_ease_in_out","quartic_ease_in","quartic_ease_out","quartic_ease_in_out","quintic_ease_in","quintic_ease_out","quintic_ease_in_out","sine_ease_in","sine_ease_out","sine_ease_in_out","circular_ease_in","circular_ease_out","circular_ease_in_out","exponential_ease_in","exponential_ease_out","exponential_ease_in_out","elastic_ease_in","elastic_ease_out","elastic_ease_in_out","back_ease_in","back_ease_out","back_ease_in_out","bounce_ease_in","bounce_ease_out","bounce_ease_in_out","animate","Errno","vsl_error","vsl_panic","vsl_error_message","vsl_panic_message","str_error","linear","linear_sigma","bessel_j0","bessel_j1","bessel_jn","bessel_y0","bessel_y1","bessel_yn","pzero","pone","qzero","qone","cgamma","clog_gamma","ChebSeries","eval_e","choose","digamma","psi","erf","erfc","beta","binomial","uint_binomial","rbinomial","n_combos_w_replacement","suqcos","suqsin","atan2p","atan2pdeg","ramp","heav","sign","boxcar","rect","hat","hatd1","sramp","srampd1","srampd2","logistic","logistic_d1","sabs","sabs_d1","sabs_d2","exp_pix","exp_mix","sinc","neg_one_pow_n","imag_pow_n","imag_x_pow_n","powp","pow2","pow3","gamma","log_gamma","log_gamma_sign","hypot","hypot_e","sin_e","cos_e","sin","cos","Point","clone","disp","str","Segment","len","new_scaled","vector","str","new_point","dist_point_point","new_segment","vector_dot","vector_norm","vector_new","vector_add","dist_point_line","points_lims","is_point_in","is_point_in_line","BinEntry","Bin","str","Bins","append","clear","find_bin_by_index","calc_index","find_closest","find_closest_and_append","find_along_segment","get_limits","nactive","nentries","summary","str","new_bins","PointsDiffFn","SorthestPaths","Graph","nverts","get_edge","shortest_paths","path","calc_dist","str_dist_matrix","get_adj","new_graph","combinations","CombinationsIter","next","new_combinations_iter","combinations_with_replacement","CombinationsWithReplacementIter","next","new_combinations_with_replacement_iter","Counter","next","new_count_iter","Cycler","next","new_cycle_iter","Repeater","next","new_repeat_iter","PermutationsIter","next","new_permutations_iter","permutations","ProductIterator","next","new_product_iterator","product","vector_rms_error","vector_dot","vector_add","vector_max_diff","vector_scale_abs","matrix_vector_mul","matrix_tr_vector_mul","vector_vector_tr_mul","matrix_vector_mul_add","matrix_matrix_mul","matrix_tr_matrix_mul","matrix_matrix_tr_mul","matrix_tr_matrix_tr_mul","matrix_matrix_muladd","matrix_tr_matrix_muladd","matrix_matrix_tr_muladd","matrix_tr_matrix_tr_mul_add","matrix_add","den_solve","Matrix","set_from_deep2","set_diag","set","get","get_deep2","clone","transpose","copy_into","add","fill","clear_rc","clear_bry","max_diff","largest","col","get_row","get_col","extract_cols","set_col","norm_frob","norm_inf","apply","det","str","print","print_v","print_py","new_matrix","matrix_deep2","matrix_raw","safe_print","matrix_inv_small","matrix_svd","matrix_inv","matrix_cond_num","SparseConfig","set_mumps_symmetry","set_umfpack_symmetry","set_mumps_ordering","set_mumps_scaling","new_sparse_config","Triplet","init","put","put_matrix_and_matrix_t","put_cc_matrix_and_matrix_t","start","len","max","size","to_dense","CCMatrix","new_triplet","VectorApplyFn","vector_apply","vector_apply_func","vector_unit","vector_accum","vector_norm","vector_rms","vector_norm_diff","vector_largest","Data","set","clone","add_observer","notify_update","new_data","data_from_raw_x","data_from_raw_xy","Kmeans","update","nb_classes","set_centroids","find_closest_centroids","compute_centroids","train","new_kmeans","TrainConfig","LinReg","name","predict","cost","gradients","train","add_observer","notify_update","calce","new_lin_reg","ParamsReg","init","backup","restore","set_params","set_param","get_param","set_thetas","get_thetas","access_thetas","access_bias","set_theta","get_theta","set_bias","get_bias","set_lambda","get_lambda","set_degree","get_degree","add_observer","notify_update","new_params_reg","Stat","name","update","sum_vars","copy_into","stat_from_data","eval","eval_derivs","solve_quadratic","solve_cubic","companion_matrix","balance_companion_matrix","add","substract","multiply","Quaternion","*","+","-","/","abs","add","angle","conjugate","copy","divide","equal","exp","inverse","is_finite","is_greater","is_greaterequal","is_inf","is_less","is_lessequal","is_nan","is_zero","lerp","log","multiply","nlerp","norm","normalized","opposite","parity_antisymmetric_part","parity_conjugate","parity_symmetric_part","pow","rotation_chordal_distance","rotation_intrinsic_distance","rotor_chordal_distance","rotor_intrinsic_distance","scalar_add","scalar_divide","scalar_multiply","scalar_pow","scalar_subtract","slerp","sqrt","squad","str","subtract","x_parity_antisymmetric_part","x_parity_conjugate","x_parity_symmetric_part","y_parity_antisymmetric_part","y_parity_conjugate","y_parity_symmetric_part","z_parity_antisymmetric_part","z_parity_conjugate","z_parity_symmetric_part","quaternion","id","from_axis_anglef3","from_spherical_coords","from_euler_angles","bisection","brent","newton","newton_bisection","freq","mean","geometric_mean","harmonic_mean","median_for_sorted_data","mode","rms","population_variance","population_variance_mean","sample_variance","sample_variance_mean","population_stddev","population_stddev_mean","sample_stddev","sample_stddev_mean","absdev","absdev_mean","tss","tss_mean","min","max","minmax","min_index","max_index","minmax_index","range","covariance","covariance_mean","lag1_autocorrelation","lag1_autocorrelation_mean","kurtosis","kurtosis_mean_stddev","skew","skew_mean_stddev","quantile_for_sorted_data","int_ints_map_append","str_ints_map_append","str_flts_map_append","Observer","Observable","add_observer","notify_update","imax","imin","arange","range","get_many","lin_space","stepped_range","move_ith_to_end","abs","inf","nan","is_nan","is_inf","is_finite","normalize","cbrt","ChebSeries","digits","mod","fmod","gcd","lcm","erf","erfc","exp","exp2","ldexp","frexp","expm1","factorial","log_factorial","floor","ceil","trunc","round","round_to_even","gamma","log_gamma","log_gamma_sign","hypot","acosh","asinh","atanh","atan","atan2","asin","acos","log","log_n","log10","log2","log1p","log_b","ilog_b","degrees","radians","max","min","minmax","modf","nextafter32","nextafter","pow","pow10","copysign","signbit","sin","cos","sincos","sinh","cosh","sqrt","tan","cot","tanh","f32_bits","f32_from_bits","f64_bits","f64_from_bits","leading_zeros_8","leading_zeros_16","leading_zeros_32","leading_zeros_64","trailing_zeros_8","trailing_zeros_16","trailing_zeros_32","trailing_zeros_64","ones_count_8","ones_count_16","ones_count_32","ones_count_64","rotate_left_8","rotate_left_16","rotate_left_32","rotate_left_64","reverse_8","reverse_16","reverse_32","reverse_64","reverse_bytes_16","reverse_bytes_32","reverse_bytes_64","len_8","len_16","len_32","len_64","add_32","add_64","sub_32","sub_64","mul_32","mul_64","div_32","div_64","rem_32","rem_64","Complex","str","abs","mod","angle","+","-","*","/","add","subtract","multiply","divide","conjugate","addinv","mulinv","pow","root","exp","ln","log","arg","cpow","sin","cos","tan","cot","sec","csc","asin","acos","atan","acot","asec","acsc","sinh","cosh","tanh","coth","sech","csch","asinh","acosh","atanh","acoth","acsch","equals","complex","approximate","approximate_with_eps","fraction","Fraction","str","+","-","*","/","add","subtract","multiply","divide","negate","reciprocal","reduce","f64","equals","ge","gt","le","lt",];
var searchModuleData = [["<div align=\"center\">","vsl.html"],["# Basic Linear Algebra System","blas.html"],[" ","blas.vlas.html"],[" ","blas.vlas.internal.float64.html"],["# Constants","consts.html"],["# Numerical Differentiation","deriv.html"],["# Numerical Differentiation","diff.html"],["# Probability Distributions algorithms","dist.html"],["# Easing Functions","easings.html"],[" ","errno.html"],[" ","fit.html"],[" ","fun.html"],["# Geometry algorithms and structures","gm.html"],["# Graph theory structures and algorithms","graph.html"],[" ","internal.html"],["# Iterator Tools","iter.html"],[" ","la.html"],[" ","ml.html"],["# Polynomials","poly.html"],["# Quaternions","quaternion.html"],["# One Dimensional Root-Finding","roots.html"],["# Statistics","stats.html"],[" ","util.html"],[" ","vmath.html"],[" ","vmath.bits.html"],["# Complex Numbers","vmath.complex.html"],[" ","vmath.fractions.html"],];
var searchData = [["vsl","","vsl.html#ArbitraryFn","type "],["vsl","","vsl.html#DfFn","type "],["vsl","","vsl.html#FdfFn","type "],["vsl","","vsl.html#VectorValuedFn","type "],["vsl"," Definition of an arbitrary function with parameters ","vsl.html#Function","struct "],["vsl","","vsl.html#Function.eval","fn (Function)"],["vsl"," Call the pointed-to function with argument x, put its result in y, and  return ","vsl.html#Function.safe_eval","fn (Function)"],["vsl"," Definition of an arbitrary function returning two values, r1, r2 ","vsl.html#FunctionFdf","struct "],["vsl","","vsl.html#FunctionFdf.eval_f","fn (FunctionFdf)"],["vsl","","vsl.html#FunctionFdf.eval_df","fn (FunctionFdf)"],["vsl","","vsl.html#FunctionFdf.eval_f_df","fn (FunctionFdf)"],["vsl"," Definition of an arbitrary vector-valued function with parameters ","vsl.html#FunctionVec","struct "],["vsl","","vsl.html#FunctionVec.eval","fn (FunctionVec)"],["blas","","blas.html#c_trans","fn "],["blas","","blas.html#c_uplo","fn "],["blas","","blas.html#l_uplo","fn "],["blas","","blas.html#job_vlr","fn "],["blas"," slice_to_col_major converts nested slice into an array representing a col-major","blas.html#slice_to_col_major","fn "],["blas"," col_major_to_slice converts col-major matrix to nested slice ","blas.html#col_major_to_slice","fn "],["blas"," print_col_major prints matrix (without commas or brackets) ","blas.html#print_col_major","fn "],["blas"," print_col_major_v prints matrix in v format ","blas.html#print_col_major_v","fn "],["blas"," print_col_major_py prints matrix in Python format ","blas.html#print_col_major_py","fn "],["blas"," slice_to_col_major_complex converts nested slice into an array representing a c","blas.html#slice_to_col_major_complex","fn "],["blas"," col_major_complex_to_slice converts col-major matrix to nested slice ","blas.html#col_major_complex_to_slice","fn "],["blas"," print_col_major_complex prints matrix (without commas or brackets).  _**NOTE**:","blas.html#print_col_major_complex","fn "],["blas"," print_col_major_complex_v prints matrix in v format  _**NOTE**: if non-empty, n","blas.html#print_col_major_complex_v","fn "],["blas"," print_col_major_omplex_py prints matrix in Python format  _**NOTE**: if non-emp","blas.html#print_col_major_omplex_py","fn "],["blas"," get_join_complex joins real and imag parts of array ","blas.html#get_join_complex","fn "],["blas"," get_split_complex splits real and imag parts of array ","blas.html#get_split_complex","fn "],["blas"," join_complex joins real and imag parts of array ","blas.html#join_complex","fn "],["blas"," split_complex splits real and imag parts of array ","blas.html#split_complex","fn "],["blas"," extract_row extracts i row from (m,n) col-major matrix ","blas.html#extract_row","fn "],["blas"," extract_col extracts j column from (m,n) col-major matrix ","blas.html#extract_col","fn "],["blas"," extract_row_complex extracts i row from (m,n) col-major matrix (complex version","blas.html#extract_row_complex","fn "],["blas"," extract_col_complex extracts j column from (m,n) col-major matrix (complex vers","blas.html#extract_col_complex","fn "],["blas"," eigenvecs_build builds complex eigenvectros created by Dgeev function    **inpu","blas.html#eigenvecs_build","fn "],["blas"," eigenvecs_build_both builds complex left and right eigenvectros created by Dgee","blas.html#eigenvecs_build_both","fn "],["blas","","blas.html#dgesv","fn "],["blas"," dgesvd computes the singular value decomposition (SVD) of a real M-by-N matrix ","blas.html#dgesvd","fn "],["blas"," dgetrf computes an LU factorization of a general M-by-N matrix A using partial ","blas.html#dgetrf","fn "],["blas"," dgetri computes the inverse of a matrix using the LU factorization computed by ","blas.html#dgetri","fn "],["blas"," dpotrf computes the Cholesky factorization of a real symmetric positive definit","blas.html#dpotrf","fn "],["blas"," dgeev computes for an N-by-N real nonsymmetric matrix A, the  eigenvalues and, ","blas.html#dgeev","fn "],["blas","","blas.html#dlange","fn "],["blas"," set_num_threads sets the number of threads in VLAS ","blas.html#set_num_threads","fn "],["blas"," ddot forms the dot product of two vectors. Uses unrolled loops for increments e","blas.html#ddot","fn "],["blas"," dscal scales a vector by a constant. Uses unrolled loops for increment equal to","blas.html#dscal","fn "],["blas"," daxpy computes constant times a vector plus a vector.   See: http://www.netlib.","blas.html#daxpy","fn "],["blas"," dgemv performs one of the matrix-vector operations   See: http://www.netlib.org","blas.html#dgemv","fn "],["blas"," dgemm performs one of the matrix-matrix operations   false,false:  C_{m,n} := Î","blas.html#dgemm","fn "],["blas"," dger performs the rank 1 operation   See: http://www.netlib.org/lapack/explore-","blas.html#dger","fn "],["blas","","blas.html#dnrm2","fn "],["blas"," dsyrk performs one of the symmetric rank k operations   See: http://www.netlib.","blas.html#dsyrk","fn "],["blas.vlas","","blas.vlas.html#Transpose","type "],["blas.vlas","","blas.vlas.html#Uplo","type "],["blas.vlas","","blas.vlas.html#Diagonal","type "],["blas.vlas"," dgemm performs one of the matrix-matrix operations   C = alpha * A * B + beta *","blas.vlas.html#dgemm","fn "],["blas.vlas"," dgemv computes   y = alpha * A * x + beta * y   if trans_a = blas_no_trans   y ","blas.vlas.html#dgemv","fn "],["blas.vlas"," dnrm2 computes the Euclidean norm of a vector,   sqrt(\sum_i x[i] * x[i]).  Thi","blas.vlas.html#dnrm2","fn "],["blas.vlas"," dasum computes the sum of the absolute values of the elements of x.   \sum_i |x","blas.vlas.html#dasum","fn "],["blas.vlas"," idamax returns the index of an element of x with the largest absolute value.  I","blas.vlas.html#idamax","fn "],["blas.vlas"," dswap exchanges the elements of two vectors.   x[i], y[i] = y[i], x[i] for all ","blas.vlas.html#dswap","fn "],["blas.vlas"," dcopy copies the elements of x into the elements of y.   y[i] = x[i] for all i ","blas.vlas.html#dcopy","fn "],["blas.vlas"," daxpy adds alpha times x to y   y[i] += alpha * x[i] for all i ","blas.vlas.html#daxpy","fn "],["blas.vlas"," drotg computes the plane rotation    _    _      _ _       _ _   |  c s |    | ","blas.vlas.html#drotg","fn "],["blas.vlas"," drot applies a plane transformation.   x[i] = c * x[i] + s * y[i]   y[i] = c * ","blas.vlas.html#drot","fn "],["blas.vlas"," dscal scales x by alpha.   x[i] *= alpha  dscal has no effect if incx < 0. ","blas.vlas.html#dscal","fn "],["blas.vlas"," ddot computes the dot product of the two vectors   \sum_i x[i]*y[i] ","blas.vlas.html#ddot","fn "],["blas.vlas"," dger performs the rank-one operation   A += alpha * x * yáµ€  where A is an mÃ—","blas.vlas.html#dger","fn "],["blas.vlas"," dgbmv performs one of the matrix-vector operations   y = alpha * A * x + beta *","blas.vlas.html#dgbmv","fn "],["blas.vlas"," dtrmv performs one of the matrix-vector operations   x = A * x   if trans_a == ","blas.vlas.html#dtrmv","fn "],["blas.vlas"," dtrsv solves one of the systems of equations   A * x = b   if trans_a == blas_n","blas.vlas.html#dtrsv","fn "],["blas.vlas"," dsymv performs the matrix-vector operation   y = alpha * A * x + beta * y  wher","blas.vlas.html#dsymv","fn "],["blas.vlas"," dtbmv performs one of the matrix-vector operations   x = A * x   if trans_a == ","blas.vlas.html#dtbmv","fn "],["blas.vlas"," dtpmv performs one of the matrix-vector operations   x = A * x   if trans_a == ","blas.vlas.html#dtpmv","fn "],["blas.vlas"," dtbsv solves one of the systems of equations   A * x = b   if trans_a == blas_n","blas.vlas.html#dtbsv","fn "],["blas.vlas"," dsbmv performs the matrix-vector operation   y = alpha * A * x + beta * y  wher","blas.vlas.html#dsbmv","fn "],["blas.vlas"," dsyr performs the symmetric rank-one update   A += alpha * x * xáµ€  where A is","blas.vlas.html#dsyr","fn "],["blas.vlas"," dsyr2 performs the symmetric rank-two update   A += alpha * x * yáµ€ + alpha * ","blas.vlas.html#dsyr2","fn "],["blas.vlas"," dtpsv solves one of the systems of equations   A * x = b   if trans_a == blas_n","blas.vlas.html#dtpsv","fn "],["blas.vlas"," dspmv performs the matrix-vector operation   y = alpha * A * x + beta * y  wher","blas.vlas.html#dspmv","fn "],["blas.vlas"," dspr performs the symmetric rank-one operation   A += alpha * x * xáµ€  where A","blas.vlas.html#dspr","fn "],["blas.vlas"," dspr2 performs the symmetric rank-2 update   A += alpha * x * yáµ€ + alpha * y ","blas.vlas.html#dspr2","fn "],["blas.vlas"," dsyrk performs one of the symmetric rank-k operations   C = alpha * A * Aáµ€ + ","blas.vlas.html#dsyrk","fn "],["blas.vlas.internal.float64"," axpy_unitary ","blas.vlas.internal.float64.html#axpy_unitary","fn "],["blas.vlas.internal.float64"," axpy_unitary_to ","blas.vlas.internal.float64.html#axpy_unitary_to","fn "],["blas.vlas.internal.float64"," axpy_inc ","blas.vlas.internal.float64.html#axpy_inc","fn "],["blas.vlas.internal.float64"," axpy_inc_to ","blas.vlas.internal.float64.html#axpy_inc_to","fn "],["blas.vlas.internal.float64"," dot_unitary ","blas.vlas.internal.float64.html#dot_unitary","fn "],["blas.vlas.internal.float64"," dot_inc ","blas.vlas.internal.float64.html#dot_inc","fn "],["blas.vlas.internal.float64"," ger performs the rank-one operation   A += alpha * x * yáµ€  where A is an mÃ—n","blas.vlas.internal.float64.html#ger","fn "],["blas.vlas.internal.float64"," gemv_n computes   y = alpha * A * x + beta * y  where A is an mÃ—n dense matrix","blas.vlas.internal.float64.html#gemv_n","fn "],["blas.vlas.internal.float64"," gemv_t computes   y = alpha * Aáµ€ * x + beta * y  where A is an mÃ—n dense mat","blas.vlas.internal.float64.html#gemv_t","fn "],["blas.vlas.internal.float64"," l2_norm_unitary returns the L2-norm of x. ","blas.vlas.internal.float64.html#l2_norm_unitary","fn "],["blas.vlas.internal.float64"," l2_norm_inc returns the L2-norm of x. ","blas.vlas.internal.float64.html#l2_norm_inc","fn "],["blas.vlas.internal.float64"," l2_distance_unitary returns the L2-norm of x-y. ","blas.vlas.internal.float64.html#l2_distance_unitary","fn "],["blas.vlas.internal.float64"," scal_unitary ","blas.vlas.internal.float64.html#scal_unitary","fn "],["blas.vlas.internal.float64"," scal_unitary_to ","blas.vlas.internal.float64.html#scal_unitary_to","fn "],["blas.vlas.internal.float64"," scal_inc ","blas.vlas.internal.float64.html#scal_inc","fn "],["blas.vlas.internal.float64"," scal_inc_to ","blas.vlas.internal.float64.html#scal_inc_to","fn "],["deriv","","deriv.html#central","fn "],["deriv","","deriv.html#forward","fn "],["deriv","","deriv.html#backward","fn "],["diff","","diff.html#backward","fn "],["diff","","diff.html#forward","fn "],["diff","","diff.html#central","fn "],["dist"," text_hist prints a text histogram ","dist.html#text_hist","fn "],["dist"," build_text_hist builds a text histogram ","dist.html#build_text_hist","fn "],["dist"," Histogram holds data for computing/plotting histograms ","dist.html#Histogram","struct "],["dist"," find_bin finds where x falls in  returns -1 if x is outside the range ","dist.html#Histogram.find_bin","fn (Histogram)"],["dist"," count counts how many items fall within each bin ","dist.html#Histogram.count","fn (Histogram)"],["dist"," gen_labels generate nice labels identifying bins ","dist.html#Histogram.gen_labels","fn (Histogram)"],["dist"," density_area computes the area of the density diagram   nsamples -- number of s","dist.html#Histogram.density_area","fn (Histogram)"],["dist"," new_histogram returns an histogram struct from a given list of stations ","dist.html#new_histogram","fn "],["easings","","easings.html#EasingFn","type "],["easings"," linear_interpolation is a method of curve fitting using linear polynomials to c","easings.html#linear_interpolation","fn "],["easings"," quadratic_ease_in eases in with a power of 2 ","easings.html#quadratic_ease_in","fn "],["easings"," quadratic_easing_eases out with a power of 2 ","easings.html#quadratic_ease_out","fn "],["easings"," quadratic_easing_in_out speeds up function's growth in a power of 2, then slows","easings.html#quadratic_ease_in_out","fn "],["easings"," cubic_ease_in eases in with a power of 3 ","easings.html#cubic_ease_in","fn "],["easings"," cubic_ease_out eases out with a power of 3 ","easings.html#cubic_ease_out","fn "],["easings"," cubic_ease_in_out speeds up function's growth in a power of 3, then slows down ","easings.html#cubic_ease_in_out","fn "],["easings"," quartic_ease_in eases in with a power of 4 ","easings.html#quartic_ease_in","fn "],["easings"," quartic_ease_out eases out with a power of 4 ","easings.html#quartic_ease_out","fn "],["easings"," quartic_ease_in_out speeds up function's growth in a power of 4, then slows dow","easings.html#quartic_ease_in_out","fn "],["easings"," quintic_ease_in eases in with a power of 5 ","easings.html#quintic_ease_in","fn "],["easings"," quintic_ease_out eases out with a power of 5 ","easings.html#quintic_ease_out","fn "],["easings"," quintic_ease_in_out speeds up function's growth in a power of 5, then slows dow","easings.html#quintic_ease_in_out","fn "],["easings"," sine_ease_in accelerates using a sine formula ","easings.html#sine_ease_in","fn "],["easings"," sine_ease_out decelerates using a sine formula ","easings.html#sine_ease_out","fn "],["easings"," sine_ease_in_out accelerates and decelerates using a sine formula ","easings.html#sine_ease_in_out","fn "],["easings"," circular_ease_in accelerates using a circular function ","easings.html#circular_ease_in","fn "],["easings"," circular_ease_out decelerates using a circular function ","easings.html#circular_ease_out","fn "],["easings"," circular_ease_in_out accelerates and decelerates using a circular function ","easings.html#circular_ease_in_out","fn "],["easings"," exponential_ease_in accelerates using an exponential formula ","easings.html#exponential_ease_in","fn "],["easings"," exponential_ease_out decelerates using an exponential formula ","easings.html#exponential_ease_out","fn "],["easings"," exponential_ease_in_out accelerates and decelerates using an exponential formul","easings.html#exponential_ease_in_out","fn "],["easings"," elastic_ease_in resembles a spring oscillating back and forth, then accelerates","easings.html#elastic_ease_in","fn "],["easings"," elastic_ease_out resembles a spring oscillating back and forth, then decelerate","easings.html#elastic_ease_out","fn "],["easings"," elastic_ease_in_out resembles a spring oscillating back and forth before it beg","easings.html#elastic_ease_in_out","fn "],["easings"," back_ease_in retracts the motion slightly before it begins to accelerate ","easings.html#back_ease_in","fn "],["easings"," back_ease_out retracts the motion slightly before it begins to decelerate ","easings.html#back_ease_out","fn "],["easings"," back_ease_in_out retracts the motion slightly before it begins to accelerate, t","easings.html#back_ease_in_out","fn "],["easings"," bounce_ease_in creates a bouncing effect, then accelerates ","easings.html#bounce_ease_in","fn "],["easings"," bounce_ease_out creates a bouncing effect, then decelerates ","easings.html#bounce_ease_out","fn "],["easings"," bounce_ease_in_out creates a bouncing effect before it begins to accelerate, th","easings.html#bounce_ease_in_out","fn "],["easings"," animate returns []f64 of length \"frames\" using the easing function provided w","easings.html#animate","fn "],["errno"," success = 0  failure = -1  can_continue = -2 iteration has not converged  edom ","errno.html#Errno","enum "],["errno","","errno.html#vsl_error","fn "],["errno","","errno.html#vsl_panic","fn "],["errno","","errno.html#vsl_error_message","fn "],["errno","","errno.html#vsl_panic_message","fn "],["errno","","errno.html#str_error","fn "],["fit"," linear computes linear fitting parameters. Errors on y-direction only   `y(x) =","fit.html#linear","fn "],["fit"," linear_sigma computes linear fitting parameters and variances (sigma_a, sigma_b","fit.html#linear_sigma","fn "],["fun"," bessel_j0 returns the order-zero Bessel function of the first kind.   special c","fun.html#bessel_j0","fn "],["fun"," bessel_j1 returns the order-one Bessel function of the first kind.   special ca","fun.html#bessel_j1","fn "],["fun"," bessel_jn returns the order-n Bessel function of the first kind.   special case","fun.html#bessel_jn","fn "],["fun"," bessel_y0 returns the order-zero Bessel function of the second kind.   special ","fun.html#bessel_y0","fn "],["fun"," bessel_y1 returns the order-one Bessel function of the second kind.   special c","fun.html#bessel_y1","fn "],["fun"," bessel_yn returns the order-n Bessel function of the second kind.   special cas","fun.html#bessel_yn","fn "],["fun"," The asymptotic expansions of pzero is  1 - 9/128 s**2 + 11025/98304 s**4 - ...,","fun.html#pzero","fn "],["fun"," For x >= 8, the asymptotic expansions of pone is  1 + 15/128 s**2 - 4725/2**15 ","fun.html#pone","fn "],["fun"," For x >= 8, the asymptotic expansions of qzero is  -1/8 s + 75/1024 s**3 - ...,","fun.html#qzero","fn "],["fun"," For x >= 8, the asymptotic expansions of qone is  3/8 s - 105/1024 s**3 - ..., ","fun.html#qone","fn "],["fun"," gamma computes the gamma function value ","fun.html#cgamma","fn "],["fun"," log_gamma computes the log-gamma function value ","fun.html#clog_gamma","fn "],["fun"," data for a Chebyshev series over a given interval ","fun.html#ChebSeries","struct "],["fun","","fun.html#ChebSeries.eval_e","fn (ChebSeries)"],["fun"," Compute the binomial coefficient ","fun.html#choose","fn "],["fun","","fun.html#digamma","fn "],["fun","","fun.html#psi","fn "],["fun"," erf returns the error function of x.   special cases are:  erf(+inf) = 1  erf(-","fun.html#erf","fn "],["fun"," erfc returns the complementary error function of x.   special cases are:  erfc(","fun.html#erfc","fn "],["fun"," beta computes the beta function by calling the log_gamma_sign function ","fun.html#beta","fn "],["fun"," binomial comptues the binomial coefficient (n k)^t ","fun.html#binomial","fn "],["fun"," uint_binomial implements the binomial coefficient using u64. panic happens on o","fun.html#uint_binomial","fn "],["fun"," rbinomial computes the binomial coefficient with real (non-negative) arguments ","fun.html#rbinomial","fn "],["fun"," (n+r-1)! / r! / (n-1)! when n > 0. ","fun.html#n_combos_w_replacement","fn "],["fun"," suqcos implements the superquadric auxiliary function that uses cos(x) ","fun.html#suqcos","fn "],["fun"," suqsin implements the superquadric auxiliary function that uses sin(x) ","fun.html#suqsin","fn "],["fun"," atan2p implements a positive version of atan2, in such a way that: 0 â‰¤ Î± â‰¤","fun.html#atan2p","fn "],["fun"," atan2pdeg implements a positive version of atan2, in such a way that: 0 â‰¤ Î± ","fun.html#atan2pdeg","fn "],["fun"," ramp function => macaulay brackets ","fun.html#ramp","fn "],["fun"," heav computes the heaviside step function (== derivative of ramp(x))           ","fun.html#heav","fn "],["fun"," sign implements the sign function ","fun.html#sign","fn "],["fun"," boxcar implements the boxcar function   `boxcar(x;a,b) = heav(x-a) - heav(x-b)`","fun.html#boxcar","fn "],["fun"," rect implements the rectangular function   `rect(x) = boxcar(x;-0.5,0.5)` ","fun.html#rect","fn "],["fun"," hat implements the hat function ","fun.html#hat","fn "],["fun"," hatd1 returns the first derivative of the hat function  _**NOTE**: the disconti","fun.html#hatd1","fn "],["fun"," sramp implements a smooth ramp function. ramp ","fun.html#sramp","fn "],["fun"," srampd1 returns the first derivative of sramp ","fun.html#srampd1","fn "],["fun"," srampd2 returns the second derivative of sramp ","fun.html#srampd2","fn "],["fun"," logistic implements the sigmoid/logistic function ","fun.html#logistic","fn "],["fun"," logistic_d1 implements the first derivative of the sigmoid/logistic function ","fun.html#logistic_d1","fn "],["fun"," sabs implements a smooth abs function: sabs(x) = x*x / (sign(x)*x + eps) ","fun.html#sabs","fn "],["fun"," sabs_d1 returns the first derivative of sabs ","fun.html#sabs_d1","fn "],["fun"," sabs_d2 returns the first derivative of sabs ","fun.html#sabs_d2","fn "],["fun"," exp_pix uses euler's formula to compute exp(+iâ‹…x) = cos(x) + iâ‹…sin(x) ","fun.html#exp_pix","fn "],["fun"," exp_mix uses euler's formula to compute exp(-iâ‹…x) = cos(x) - iâ‹…sin(x) ","fun.html#exp_mix","fn "],["fun"," sinc computes the sine cardinal (sinc) function     sinc(x) = |     1      if x","fun.html#sinc","fn "],["fun"," neg_one_pow_n computes (-1)â¿ ","fun.html#neg_one_pow_n","fn "],["fun"," imag_pow_n computes iâ¿ = (âˆš-1)â¿ ","fun.html#imag_pow_n","fn "],["fun"," imag_x_pow_n computes (xâ‹…i)â¿ ","fun.html#imag_x_pow_n","fn "],["fun"," powp computes real raised to positive integer xâ¿ ","fun.html#powp","fn "],["fun"," pow2 computes xÂ² ","fun.html#pow2","fn "],["fun"," pow3 computes xÂ³ ","fun.html#pow3","fn "],["fun"," gamma returns the gamma function of x.   special ifs are:  gamma(+inf) = +inf  ","fun.html#gamma","fn "],["fun"," log_gamma returns the natural logarithm and sign (-1 or +1) of Gamma(x).   spec","fun.html#log_gamma","fn "],["fun","","fun.html#log_gamma_sign","fn "],["fun","","fun.html#hypot","fn "],["fun","","fun.html#hypot_e","fn "],["fun","","fun.html#sin_e","fn "],["fun","","fun.html#cos_e","fn "],["fun","","fun.html#sin","fn "],["fun","","fun.html#cos","fn "],["gm"," Point holds the Cartesian coordinates of a point in 3D space ","gm.html#Point","struct "],["gm"," clone creates a new copy of Point ","gm.html#Point.clone","fn (Point)"],["gm"," disp creates a new copy of Point displaced by dx, dy, dz ","gm.html#Point.disp","fn (Point)"],["gm"," str outputs Point ","gm.html#Point.str","fn (Point)"],["gm"," Segment represents a directed segment from a to b ","gm.html#Segment","struct "],["gm"," len computes the length of Segment == Euclidean norm ","gm.html#Segment.len","fn (Segment)"],["gm"," New creates a new Segment scaled by m and starting from A ","gm.html#Segment.new_scaled","fn (Segment)"],["gm"," vector returns the vector representing Segment from A to B (scaled by m) ","gm.html#Segment.vector","fn (Segment)"],["gm"," str outputs Segment ","gm.html#Segment.str","fn (Segment)"],["gm"," new_point creates a new point ","gm.html#new_point","fn "],["gm"," dist_point_point computes the unsigned distance from a to b ","gm.html#dist_point_point","fn "],["gm"," new_segment creates a new segment from a to b ","gm.html#new_segment","fn "],["gm"," vector_dot returns the dot product between two vectors ","gm.html#vector_dot","fn "],["gm"," vector_norm returns the length (Euclidean norm) of a vector ","gm.html#vector_norm","fn "],["gm"," vector_new returns a new vector scaled by m ","gm.html#vector_new","fn "],["gm"," vector_add returns a new vector by adding two other vectors   w := Î±*u + Î²*v ","gm.html#vector_add","fn "],["gm"," dist_point_line computes the distance from p to line passing through a -> b ","gm.html#dist_point_line","fn "],["gm"," points_lims returns the limits of a set of points ","gm.html#points_lims","fn "],["gm"," is_point_in returns whether p is inside box with cmin and cmax ","gm.html#is_point_in","fn "],["gm"," is_point_in_line returns whether p is inside line passing through a and b ","gm.html#is_point_in_line","fn "],["gm"," BinEntry holds data of an entry to bin ","gm.html#BinEntry","struct "],["gm"," Bin defines one bin in Bins (holds entries for search) ","gm.html#Bin","struct "],["gm"," str returns the string representation of one Bin ","gm.html#Bin.str","fn (Bin)"],["gm"," Bins implements a set of bins holding entries and is used to fast search entrie","gm.html#Bins","struct "],["gm"," append adds a new entry {x, id, something} into the bins structure ","gm.html#Bins.append","fn (Bins)"],["gm"," clear clears all biBinsns ","gm.html#Bins.clear","fn (Bins)"],["gm"," find_bin_by_index finds or allocate new bin corresponding to index idx ","gm.html#Bins.find_bin_by_index","fn (Bins)"],["gm"," calc_index calculates the bin index where the point x is  returns -1 if out-of-","gm.html#Bins.calc_index","fn (Bins)"],["gm"," find_closest returns the id of the entry whose coordinates are closest to x    ","gm.html#Bins.find_closest","fn (Bins)"],["gm"," find_closest_and_append finds closest point and, if not found, append to bins w","gm.html#Bins.find_closest_and_append","fn (Bins)"],["gm"," find_along_segment gets the ids of entries that lie close to a segment   Note: ","gm.html#Bins.find_along_segment","fn (Bins)"],["gm"," get_limits returns limigs of a specific bin ","gm.html#Bins.get_limits","fn (Bins)"],["gm"," nactive returns the number of active bins; i.e. non-nil bins ","gm.html#Bins.nactive","fn (Bins)"],["gm"," nentries returns the total number of entries (in active bins) ","gm.html#Bins.nentries","fn (Bins)"],["gm"," summary returns the summary of this Bins' data ","gm.html#Bins.summary","fn (Bins)"],["gm"," str returns the string representation of a set of Bins ","gm.html#Bins.str","fn (Bins)"],["gm"," new_bins initialise bins structure    xmin -- [ndim] min/initial coordinates of","gm.html#new_bins","fn "],["gm","","gm.html#PointsDiffFn","type "],["graph","","graph.html#SorthestPaths","enum "],["graph"," Graph defines a graph structure ","graph.html#Graph","struct "],["graph"," nverts returns the number of vertices ","graph.html#Graph.nverts","fn (Graph)"],["graph"," get_edge performs a lookup on key2edge map and returs id of edge for given node","graph.html#Graph.get_edge","fn (Graph)"],["graph","","graph.html#Graph.shortest_paths","fn (Graph)"],["graph"," path returns the path from source (s) to destination (t)  Note: shortest_paths ","graph.html#Graph.path","fn (Graph)"],["graph"," calc_dist computes distances beetween all vertices and initialises 'next' matri","graph.html#Graph.calc_dist","fn (Graph)"],["graph"," str_dist_matrix returns a string representation of dist matrix ","graph.html#Graph.str_dist_matrix","fn (Graph)"],["graph"," get_adj returns adjacency list as a compressed storage format for METIS ","graph.html#Graph.get_adj","fn (Graph)"],["graph"," new_graph initialises graph  edges    -- [nedges][2] edges (connectivity)  weig","graph.html#new_graph","fn "],["iter"," combinations will return an array of all length `r` combinations of `data`  Whi","iter.html#combinations","fn "],["iter","","iter.html#CombinationsIter","struct "],["iter"," next will return next combination if possible ","iter.html#CombinationsIter.next","fn (CombinationsIter)"],["iter"," new_combinations_iter will return an iterator that allows  lazy computation for","iter.html#new_combinations_iter","fn "],["iter"," combinations_with_replacement will return r length subsequences of elements fro","iter.html#combinations_with_replacement","fn "],["iter","","iter.html#CombinationsWithReplacementIter","struct "],["iter"," next will return next combination if possible ","iter.html#CombinationsWithReplacementIter.next","fn (CombinationsWithReplacementIter)"],["iter"," new_combinations_with_replacement_iter will return an iterator that allows  laz","iter.html#new_combinations_with_replacement_iter","fn "],["iter","","iter.html#Counter","struct "],["iter","","iter.html#Counter.next","fn (Counter)"],["iter","","iter.html#new_count_iter","fn "],["iter","","iter.html#Cycler","struct "],["iter","","iter.html#Cycler.next","fn (Cycler)"],["iter","","iter.html#new_cycle_iter","fn "],["iter","","iter.html#Repeater","struct "],["iter","","iter.html#Repeater.next","fn (Repeater)"],["iter","","iter.html#new_repeat_iter","fn "],["iter","","iter.html#PermutationsIter","struct "],["iter"," next will return next permutation if possible ","iter.html#PermutationsIter.next","fn (PermutationsIter)"],["iter"," new_permutations_iter will return an iterator that allows  lazy computation for","iter.html#new_permutations_iter","fn "],["iter"," permutations returns successive `r` length permutations of elements in `data` ","iter.html#permutations","fn "],["iter","","iter.html#ProductIterator","struct "],["iter","","iter.html#ProductIterator.next","fn (ProductIterator)"],["iter","","iter.html#new_product_iterator","fn "],["iter"," Cartesian product of the arrays in `data` ","iter.html#product","fn "],["la","","la.html#vector_rms_error","fn "],["la"," vector_dot returns the dot product between two vectors:  s := uãƒ»v ","la.html#vector_dot","fn "],["la"," vector_add adds the scaled components of two vectors  res := alphaâ‹…u + betaâ‹","la.html#vector_add","fn "],["la"," vector_max_diff returns the maximum absolute difference between two vectors  ma","la.html#vector_max_diff","fn "],["la"," vector_scale_abs creates a \"scale\" vector using the absolute value of another","la.html#vector_scale_abs","fn "],["la"," matrix_vector_mul returns the matrix-vector multiplication   v = alphaâ‹…aâ‹…u ","la.html#matrix_vector_mul","fn "],["la"," matrix_tr_vector_mul returns the transpose(matrix)-vector multiplication   v = ","la.html#matrix_tr_vector_mul","fn "],["la"," vector_vector_tr_mul returns the matrix = vector-transpose(vector) multiplicati","la.html#vector_vector_tr_mul","fn "],["la"," matrix_vector_mul_add returns the matrix-vector multiplication with addition   ","la.html#matrix_vector_mul_add","fn "],["la"," matrix_matrix_mul returns the matrix multiplication (scaled)    c := alphaâ‹…aâ","la.html#matrix_matrix_mul","fn "],["la"," matrix_tr_matrix_mul returns the matrix multiplication (scaled) with transposed","la.html#matrix_tr_matrix_mul","fn "],["la"," matrix_matrix_tr_mul returns the matrix multiplication (scaled) with transposed","la.html#matrix_matrix_tr_mul","fn "],["la"," matrix_tr_matrix_tr_mul returns the matrix multiplication (scaled) with transpo","la.html#matrix_tr_matrix_tr_mul","fn "],["la"," matrix_matrix_muladd returns the matrix multiplication (scaled)    c += alphaâ‹","la.html#matrix_matrix_muladd","fn "],["la"," matrix_tr_matrix_muladd returns the matrix multiplication (scaled) with transpo","la.html#matrix_tr_matrix_muladd","fn "],["la"," matrix_matrix_tr_muladd returns the matrix multiplication (scaled) with transpo","la.html#matrix_matrix_tr_muladd","fn "],["la"," matrix_tr_matrix_tr_mul_add returns the matrix multiplication (scaled) with tra","la.html#matrix_tr_matrix_tr_mul_add","fn "],["la"," matrix_add adds the scaled components of two matrices    res := alphaâ‹…a + bet","la.html#matrix_add","fn "],["la"," den_solve solves dense linear system using LAPACK (OpenBLaS)     Given:  a â‹… ","la.html#den_solve","fn "],["la","","la.html#Matrix","struct "],["la"," set_from_deep2 sets matrix with data from a nested slice (Deep2) structure ","la.html#Matrix.set_from_deep2","fn (Matrix)"],["la"," set_diag sets diagonal matrix with diagonal components equal to val ","la.html#Matrix.set_diag","fn (Matrix)"],["la"," set sets value ","la.html#Matrix.set","fn (Matrix)"],["la"," get gets value ","la.html#Matrix.get","fn (Matrix)"],["la"," get_deep2 returns nested slice representation ","la.html#Matrix.get_deep2","fn (Matrix)"],["la"," clone returns a copy of this matrix ","la.html#Matrix.clone","fn (Matrix)"],["la"," transpose returns the transpose matrix ","la.html#Matrix.transpose","fn (Matrix)"],["la"," copy_into copies the scaled components of this matrix into another one (result)","la.html#Matrix.copy_into","fn (Matrix)"],["la"," add adds value to (i,j) location ","la.html#Matrix.add","fn (Matrix)"],["la"," fill fills this matrix with a single number val  aij = val ","la.html#Matrix.fill","fn (Matrix)"],["la","","la.html#Matrix.clear_rc","fn (Matrix)"],["la","","la.html#Matrix.clear_bry","fn (Matrix)"],["la"," max_diff returns the maximum difference between the components of this and anot","la.html#Matrix.max_diff","fn (Matrix)"],["la"," largest returns the largest component |a[ij]| of this matrix, normalised by den","la.html#Matrix.largest","fn (Matrix)"],["la"," col access column j of this matrix. No copies are made since the internal data ","la.html#Matrix.col","fn (Matrix)"],["la"," get_row returns row i of this matrix ","la.html#Matrix.get_row","fn (Matrix)"],["la"," get_col returns column j of this matrix ","la.html#Matrix.get_col","fn (Matrix)"],["la"," extract_cols returns columns from j=start to j=endp1-1  start -- first column  ","la.html#Matrix.extract_cols","fn (Matrix)"],["la"," set_col sets the values of a column j with a single value ","la.html#Matrix.set_col","fn (Matrix)"],["la"," norm_frob returns the Frobenius norm of this matrix  nrm := â€–aâ€–_F = sqrt(Î£","la.html#Matrix.norm_frob","fn (Matrix)"],["la"," norm_inf returns the infinite norm of this matrix  nrm := â€–aâ€–_âˆž = max_i (","la.html#Matrix.norm_inf","fn (Matrix)"],["la"," apply sets this matrix with the scaled components of another matrix  this := al","la.html#Matrix.apply","fn (Matrix)"],["la"," det computes the determinant of matrix using the LU factorization  NOTE: this m","la.html#Matrix.det","fn (Matrix)"],["la","","la.html#Matrix.str","fn (Matrix)"],["la"," print prints matrix (without commas or brackets) ","la.html#Matrix.print","fn (Matrix)"],["la"," print_v prints matrix in V format ","la.html#Matrix.print_v","fn (Matrix)"],["la"," print_py prints matrix in Python format ","la.html#Matrix.print_py","fn (Matrix)"],["la"," matrix allocates a new (empty) Matrix with given (m,n) (row/col sizes) ","la.html#new_matrix","fn "],["la"," matrix_deep2 allocates a new Matrix from given (Deep2) nested slice.  NOTE: mak","la.html#matrix_deep2","fn "],["la"," matrix_raw creates a new Matrix using given raw data  Input:  rawdata -- data o","la.html#matrix_raw","fn "],["la","","la.html#safe_print","fn "],["la"," matrix_inv_small computes the inverse of small matrices of size 1x1, 2x2, or 3x","la.html#matrix_inv_small","fn "],["la"," matrix_svd performs the SVD decomposition  Input:  a     -- matrix a  copy_a --","la.html#matrix_svd","fn "],["la"," matrix_inv computes the inverse of a general matrix (square or not). It also co","la.html#matrix_inv","fn "],["la"," matrix_cond_num returns the condition number of a square matrix using the inver","la.html#matrix_cond_num","fn "],["la"," The SparseConfig structure holds configuration arguments for sparse solvers ","la.html#SparseConfig","struct "],["la"," set_mumps_symmetry sets symmetry options for MUMPS solver ","la.html#SparseConfig.set_mumps_symmetry","fn (SparseConfig)"],["la"," set_umfpack_symmetry sets symmetry options for UMFPACK solver ","la.html#SparseConfig.set_umfpack_symmetry","fn (SparseConfig)"],["la"," set_mumps_ordering sets ordering for MUMPS solver  ordering -- \"\" or \"amf\" ","la.html#SparseConfig.set_mumps_ordering","fn (SparseConfig)"],["la"," set_mumps_scaling sets scaling for MUMPS solver  scaling -- \"\" or \"rcit\" [d","la.html#SparseConfig.set_mumps_scaling","fn (SparseConfig)"],["la"," new_sparse_config returns a new SparseConfig  Input:   comm -- may be nil ","la.html#new_sparse_config","fn "],["la"," Triplet is a simple representation of a sparse matrix, where the indices and va","la.html#Triplet","struct "],["la"," init allocates all memory required to hold a sparse matrix in triplet form ","la.html#Triplet.init","fn (Triplet)"],["la"," put inserts an element to a pre-allocated (with init) triplet matrix ","la.html#Triplet.put","fn (Triplet)"],["la","","la.html#Triplet.put_matrix_and_matrix_t","fn (Triplet)"],["la","","la.html#Triplet.put_cc_matrix_and_matrix_t","fn (Triplet)"],["la"," start (re)starts index for inserting items using the put command ","la.html#Triplet.start","fn (Triplet)"],["la"," Len returns the number of items just inserted in the triplet ","la.html#Triplet.len","fn (Triplet)"],["la"," max returns the maximum number of items that can be inserted in the triplet ","la.html#Triplet.max","fn (Triplet)"],["la"," size returns the row/column size of the matrix represented by the Triplet ","la.html#Triplet.size","fn (Triplet)"],["la"," to_dense returns the dense matrix corresponding to this Triplet ","la.html#Triplet.to_dense","fn (Triplet)"],["la"," CCMatrix represents a sparse matrix using the so-called \"column-compressed for","la.html#CCMatrix","struct "],["la"," new_triplet returns a new Triplet. This is a wrapper to new(Triplet) followed b","la.html#new_triplet","fn "],["la","","la.html#VectorApplyFn","type "],["la"," apply sets this []f64 with the scaled components of another []f64  this := a * ","la.html#vector_apply","fn "],["la"," apply_func runs a function over all components of a []f64  vi = f(i,vi) ","la.html#vector_apply_func","fn "],["la"," unit returns the unit []f64 parallel to this []f64  b := a / norm(a) ","la.html#vector_unit","fn "],["la"," accum sum/accumulates all components in a []f64  sum := Î£_i v[i] ","la.html#vector_accum","fn "],["la"," norm returns the Euclidean norm of a []f64:  nrm := â€–vâ€– ","la.html#vector_norm","fn "],["la"," rms returns the root-mean-square of this []f64  ","la.html#vector_rms","fn "],["la"," norm_diff returns the Euclidean norm of the difference:  nrm := ||u - v|| ","la.html#vector_norm_diff","fn "],["la"," largest returns the largest component |u[i]| of this []f64, normalised by den  ","la.html#vector_largest","fn "],["ml","","ml.html#Data","struct "],["ml"," set sets x matrix and y vector [optional] and notify observers  Input:  x -- x ","ml.html#Data.set","fn (Data)"],["ml"," clone returns a deep copy of this object ","ml.html#Data.clone","fn (Data)"],["ml"," add_observer adds an object to the list of interested observers ","ml.html#Data.add_observer","fn (Data)"],["ml"," notify_update notifies observers of updates ","ml.html#Data.notify_update","fn (Data)"],["ml"," data returns a new object to hold ML data  Input:  nb_samples  -- number of dat","ml.html#new_data","fn "],["ml"," data_from_raw_x returns a new object with data set from raw x values  Input:  x","ml.html#data_from_raw_x","fn "],["ml"," data_from_raw_xy returns a new object with data set from raw Xy values  Input: ","ml.html#data_from_raw_xy","fn "],["ml"," Kmeans implements the K-means model (Observer of Data) ","ml.html#Kmeans","struct "],["ml"," update perform updates after data has been changed (as an Observer) ","ml.html#Kmeans.update","fn (Kmeans)"],["ml"," nb_classes returns the number of classes ","ml.html#Kmeans.nb_classes","fn (Kmeans)"],["ml"," set_centroids sets centroids; e.g. trial centroids    xc -- [nb_class][nb_featu","ml.html#Kmeans.set_centroids","fn (Kmeans)"],["ml"," find_closest_centroids finds closest centroids to each sample ","ml.html#Kmeans.find_closest_centroids","fn (Kmeans)"],["ml"," compute_centroids update centroids based on new classes information (from find_","ml.html#Kmeans.compute_centroids","fn (Kmeans)"],["ml"," train trains model ","ml.html#Kmeans.train","fn (Kmeans)"],["ml"," new_kmeans returns a new K-means model ","ml.html#new_kmeans","fn "],["ml","","ml.html#TrainConfig","struct "],["ml"," LinReg implements a linear regression model ","ml.html#LinReg","struct "],["ml"," name returns the name of this LinReg object (thus defining the Observer interfa","ml.html#LinReg.name","fn (LinReg)"],["ml"," predict returns the model evaluation @ {x;theta,b}    Input:      x -- vector o","ml.html#LinReg.predict","fn (LinReg)"],["ml"," cost returns the cost c(x;theta,b)    Input:      data -- x,y data      params ","ml.html#LinReg.cost","fn (LinReg)"],["ml"," gradients returns âˆ‚C/âˆ‚theta and âˆ‚C/âˆ‚b    Output:      dcdtheta -- âˆ‚C/","ml.html#LinReg.gradients","fn (LinReg)"],["ml"," train finds theta and b using closed-form solution    Input:      data -- x,y d","ml.html#LinReg.train","fn (LinReg)"],["ml"," add_observer adds an object to the list of interested observers ","ml.html#LinReg.add_observer","fn (LinReg)"],["ml"," notify_update notifies observers of updates ","ml.html#LinReg.notify_update","fn (LinReg)"],["ml"," calce calculates e vector (save into o.e)   Output: e = bâ‹…o + xâ‹…theta - y ","ml.html#LinReg.calce","fn (LinReg)"],["ml"," new_lin_reg returns a new LinReg object    Input:      data   -- x,y data      ","ml.html#new_lin_reg","fn "],["ml","","ml.html#ParamsReg","struct "],["ml"," init initializes ParamsReg with nb_features (number of features) ","ml.html#ParamsReg.init","fn (ParamsReg)"],["ml"," backup creates an internal copy of parameters ","ml.html#ParamsReg.backup","fn (ParamsReg)"],["ml"," restore restores an internal copy of parameters and notifies observers ","ml.html#ParamsReg.restore","fn (ParamsReg)"],["ml"," set_params sets theta and b and notifies observers ","ml.html#ParamsReg.set_params","fn (ParamsReg)"],["ml"," set_param sets either theta or b (use negative indices for b). Notifies observe","ml.html#ParamsReg.set_param","fn (ParamsReg)"],["ml"," get_param returns either theta or b (use negative indices for b)   i -- index o","ml.html#ParamsReg.get_param","fn (ParamsReg)"],["ml"," set_thetas sets the whole vector theta and notifies observers ","ml.html#ParamsReg.set_thetas","fn (ParamsReg)"],["ml"," get_thetas gets a copy of theta ","ml.html#ParamsReg.get_thetas","fn (ParamsReg)"],["ml"," access_thetas returns access (slice) to theta ","ml.html#ParamsReg.access_thetas","fn (ParamsReg)"],["ml"," access_bias returns access (pointer) to b ","ml.html#ParamsReg.access_bias","fn (ParamsReg)"],["ml"," set_theta sets one component of theta and notifies observers ","ml.html#ParamsReg.set_theta","fn (ParamsReg)"],["ml"," get_theta returns the value of theta[i] ","ml.html#ParamsReg.get_theta","fn (ParamsReg)"],["ml"," set_bias sets b and notifies observers ","ml.html#ParamsReg.set_bias","fn (ParamsReg)"],["ml"," get_bias gets a copy of b ","ml.html#ParamsReg.get_bias","fn (ParamsReg)"],["ml"," set_lambda sets lambda and notifies observers ","ml.html#ParamsReg.set_lambda","fn (ParamsReg)"],["ml"," get_lambda gets a copy of lambda ","ml.html#ParamsReg.get_lambda","fn (ParamsReg)"],["ml"," set_degree sets p and notifies observers ","ml.html#ParamsReg.set_degree","fn (ParamsReg)"],["ml"," get_degree gets a copy of p ","ml.html#ParamsReg.get_degree","fn (ParamsReg)"],["ml"," add_observer adds an object to the list of interested observers ","ml.html#ParamsReg.add_observer","fn (ParamsReg)"],["ml"," notify_update notifies observers of updates ","ml.html#ParamsReg.notify_update","fn (ParamsReg)"],["ml"," new_params_reg returns a new object to hold regression parameters ","ml.html#new_params_reg","fn "],["ml"," Stat holds statistics about data   NOTE: Stat is an Observer of Data; thus, dat","ml.html#Stat","struct "],["ml"," name returns the name of this stat object (thus defining the Observer interface","ml.html#Stat.name","fn (Stat)"],["ml"," update compute statistics for given data (an Observer of Data) ","ml.html#Stat.update","fn (Stat)"],["ml"," sum_vars computes the sums along the columns of X and y  Output:  t -- scalar t","ml.html#Stat.sum_vars","fn (Stat)"],["ml"," copy_into copies stat into p ","ml.html#Stat.copy_into","fn (Stat)"],["ml"," stat returns a new Stat object ","ml.html#stat_from_data","fn "],["poly","","poly.html#eval","fn "],["poly","","poly.html#eval_derivs","fn "],["poly","","poly.html#solve_quadratic","fn "],["poly","","poly.html#solve_cubic","fn "],["poly","","poly.html#companion_matrix","fn "],["poly","","poly.html#balance_companion_matrix","fn "],["poly"," Arithmetic operations on polynomials   In the following descriptions a, b, c ar","poly.html#add","fn "],["poly","","poly.html#substract","fn "],["poly","","poly.html#multiply","fn "],["quaternion","","quaternion.html#Quaternion","struct "],["quaternion","","quaternion.html#Quaternion.*","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.+","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.-","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion./","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.abs","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.add","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.angle","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.conjugate","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.copy","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.divide","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.equal","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.exp","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.inverse","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.is_finite","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.is_greater","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.is_greaterequal","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.is_inf","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.is_less","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.is_lessequal","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.is_nan","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.is_zero","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.lerp","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.log","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.multiply","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.nlerp","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.norm","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.normalized","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.opposite","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.parity_antisymmetric_part","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.parity_conjugate","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.parity_symmetric_part","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.pow","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.rotation_chordal_distance","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.rotation_intrinsic_distance","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.rotor_chordal_distance","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.rotor_intrinsic_distance","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.scalar_add","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.scalar_divide","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.scalar_multiply","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.scalar_pow","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.scalar_subtract","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.slerp","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.sqrt","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.squad","fn (Quaternion)"],["quaternion"," To String method  w + xi + yj + zk ","quaternion.html#Quaternion.str","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.subtract","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.x_parity_antisymmetric_part","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.x_parity_conjugate","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.x_parity_symmetric_part","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.y_parity_antisymmetric_part","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.y_parity_conjugate","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.y_parity_symmetric_part","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.z_parity_antisymmetric_part","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.z_parity_conjugate","fn (Quaternion)"],["quaternion","","quaternion.html#Quaternion.z_parity_symmetric_part","fn (Quaternion)"],["quaternion","","quaternion.html#quaternion","fn "],["quaternion","","quaternion.html#id","fn "],["quaternion","","quaternion.html#from_axis_anglef3","fn "],["quaternion","","quaternion.html#from_spherical_coords","fn "],["quaternion","","quaternion.html#from_euler_angles","fn "],["roots"," Find the root of a function using a bisection method ","roots.html#bisection","fn "],["roots"," Search for the root of func in the interval [x1, x2] with a  given tolerance ","roots.html#brent","fn "],["roots"," Find the root of a function using Newton's algorithm with the Armijo line  sear","roots.html#newton","fn "],["roots"," Find the root of a function by combining Newton's method with the bisection  me","roots.html#newton_bisection","fn "],["stats"," Measure of Occurance  Frequency of a given number  Based on  https://www.mathsi","stats.html#freq","fn "],["stats"," Measure of Central Tendancy  Mean of the given input array  Based on  https://w","stats.html#mean","fn "],["stats"," Measure of Central Tendancy  Geometric Mean of the given input array  Based on ","stats.html#geometric_mean","fn "],["stats"," Measure of Central Tendancy  Harmonic Mean of the given input array  Based on  ","stats.html#harmonic_mean","fn "],["stats"," Measure of Central Tendancy  Median of the given input array ( input array is a","stats.html#median_for_sorted_data","fn "],["stats"," Measure of Central Tendancy  Mode of the given input array  Based on  https://w","stats.html#mode","fn "],["stats"," Root Mean Square of the given input array  Based on  https://en.wikipedia.org/w","stats.html#rms","fn "],["stats"," Measure of Dispersion / Spread  Population Variance of the given input array  B","stats.html#population_variance","fn "],["stats"," Measure of Dispersion / Spread  Population Variance of the given input array  B","stats.html#population_variance_mean","fn "],["stats"," Measure of Dispersion / Spread  Sample Variance of the given input array  Based","stats.html#sample_variance","fn "],["stats"," Measure of Dispersion / Spread  Sample Variance of the given input array  Based","stats.html#sample_variance_mean","fn "],["stats"," Measure of Dispersion / Spread  Population Standard Deviation of the given inpu","stats.html#population_stddev","fn "],["stats"," Measure of Dispersion / Spread  Population Standard Deviation of the given inpu","stats.html#population_stddev_mean","fn "],["stats"," Measure of Dispersion / Spread  Sample Standard Deviation of the given input ar","stats.html#sample_stddev","fn "],["stats"," Measure of Dispersion / Spread  Sample Standard Deviation of the given input ar","stats.html#sample_stddev_mean","fn "],["stats"," Measure of Dispersion / Spread  Mean Absolute Deviation of the given input arra","stats.html#absdev","fn "],["stats"," Measure of Dispersion / Spread  Mean Absolute Deviation of the given input arra","stats.html#absdev_mean","fn "],["stats"," Sum of squares ","stats.html#tss","fn "],["stats"," Sum of squares about the mean ","stats.html#tss_mean","fn "],["stats"," Minimum of the given input array ","stats.html#min","fn "],["stats"," Maximum of the given input array ","stats.html#max","fn "],["stats"," Minimum and maximum of the given input array ","stats.html#minmax","fn "],["stats"," Minimum of the given input array ","stats.html#min_index","fn "],["stats"," Maximum of the given input array ","stats.html#max_index","fn "],["stats"," Minimum and maximum of the given input array ","stats.html#minmax_index","fn "],["stats"," Measure of Dispersion / Spread  Range ( Maximum - Minimum ) of the given input ","stats.html#range","fn "],["stats","","stats.html#covariance","fn "],["stats"," Compute the covariance of a dataset using  the recurrence relation ","stats.html#covariance_mean","fn "],["stats","","stats.html#lag1_autocorrelation","fn "],["stats"," Compute the lag-1 autocorrelation of a dataset using  the recurrence relation ","stats.html#lag1_autocorrelation_mean","fn "],["stats","","stats.html#kurtosis","fn "],["stats"," Takes a dataset and finds the kurtosis  using the fourth moment the deviations,","stats.html#kurtosis_mean_stddev","fn "],["stats","","stats.html#skew","fn "],["stats","","stats.html#skew_mean_stddev","fn "],["stats","","stats.html#quantile_for_sorted_data","fn "],["util"," int_ints_map_append appends a new item to a map of slice.  Note: this function ","util.html#int_ints_map_append","fn "],["util"," str_ints_map_append appends a new item to a map of slice.  Note: this function ","util.html#str_ints_map_append","fn "],["util"," str_flts_map_append appends a new item to a map of slice.  Note: this function ","util.html#str_flts_map_append","fn "],["util"," Observer is an interface to objects that need to observe something  the data ob","util.html#Observer","interface "],["util"," Observable indicates that an object is observable; i.e. it has a list of intere","util.html#Observable","struct "],["util"," add_observer adds an object to the list of interested observers ","util.html#Observable.add_observer","fn (Observable)"],["util"," notify_update notifies observers of updates ","util.html#Observable.notify_update","fn (Observable)"],["util"," imax returns the maximum value of the two provided. ","util.html#imax","fn "],["util"," imin returns the minimum value of the two provided. ","util.html#imin","fn "],["util"," range returns a list with int values in the interval [0, n) ","util.html#arange","fn "],["util"," range returns a list with int values in the interval [start, stop) ","util.html#range","fn "],["util"," get_many returns an array containing the values in the given idxs ","util.html#get_many","fn "],["util"," lin_space returns evenly spaced numbers over a specified closed interval. ","util.html#lin_space","fn "],["util"," Mimics python's range() with a step argument ","util.html#stepped_range","fn "],["util"," move_ith_to_end removes element at i from the array, and puts it at the end  is","util.html#move_ith_to_end","fn "],["vmath"," Returns the absolute value. ","vmath.html#abs","fn "],["vmath"," inf returns positive infinity if sign >= 0, negative infinity if sign < 0. ","vmath.html#inf","fn "],["vmath"," nan returns an IEEE 754 ``not-a-number'' value. ","vmath.html#nan","fn "],["vmath"," is_nan reports whether f is an IEEE 754 ``not-a-number'' value. ","vmath.html#is_nan","fn "],["vmath"," is_inf reports whether f is an infinity, according to sign.  If sign > 0, is_in","vmath.html#is_inf","fn "],["vmath","","vmath.html#is_finite","fn "],["vmath"," normalize returns a normal number y and exponent exp  satisfying x == y Ã— 2**e","vmath.html#normalize","fn "],["vmath"," cbrt returns the cube root of x.   special cases are:  cbrt(Â±0) = Â±0  cbrt(Â±","vmath.html#cbrt","fn "],["vmath"," data for a Chebyshev series over a given interval ","vmath.html#ChebSeries","struct "],["vmath"," digits returns an array of the digits of n in the given base. ","vmath.html#digits","fn "],["vmath"," Floating-point mod function.  mod returns the floating-point remainder of x/y. ","vmath.html#mod","fn "],["vmath","","vmath.html#fmod","fn "],["vmath"," gcd calculates greatest common (positive) divisor (or zero if a and b are both ","vmath.html#gcd","fn "],["vmath"," lcm calculates least common (non-negative) multiple. ","vmath.html#lcm","fn "],["vmath"," erf returns the error function of x.   special cases are:  erf(+inf) = 1  erf(-","vmath.html#erf","fn "],["vmath"," erfc returns the complementary error function of x.   special cases are:  erfc(","vmath.html#erfc","fn "],["vmath"," exp returns e**x, the base-e exponential of x.   special cases are:  exp(+inf) ","vmath.html#exp","fn "],["vmath"," exp2 returns 2**x, the base-2 exponential of x.   special cases are the same as","vmath.html#exp2","fn "],["vmath","","vmath.html#ldexp","fn "],["vmath"," frexp breaks f into a normalized fraction  and an integral power of two.  It re","vmath.html#frexp","fn "],["vmath"," special cases are:  expm1(+inf) = +inf  expm1(-inf) = -1  expm1(nan) = nan ","vmath.html#expm1","fn "],["vmath"," factorial calculates the factorial of the provided value. ","vmath.html#factorial","fn "],["vmath"," log_factorial calculates the log-factorial of the provided value. ","vmath.html#log_factorial","fn "],["vmath"," floor returns the greatest integer value less than or equal to x.   special cas","vmath.html#floor","fn "],["vmath"," ceil returns the least integer value greater than or equal to x.   special case","vmath.html#ceil","fn "],["vmath"," trunc returns the integer value of x.   special cases are:  trunc(Â±0) = Â±0  t","vmath.html#trunc","fn "],["vmath"," round returns the nearest integer, rounding half away from zero.   special case","vmath.html#round","fn "],["vmath"," round_to_even returns the nearest integer, rounding ties to even.   special cas","vmath.html#round_to_even","fn "],["vmath"," gamma returns the gamma function of x.   special ifs are:  gamma(+inf) = +inf  ","vmath.html#gamma","fn "],["vmath"," log_gamma returns the natural logarithm and sign (-1 or +1) of Gamma(x).   spec","vmath.html#log_gamma","fn "],["vmath","","vmath.html#log_gamma_sign","fn "],["vmath","","vmath.html#hypot","fn "],["vmath","","vmath.html#acosh","fn "],["vmath","","vmath.html#asinh","fn "],["vmath","","vmath.html#atanh","fn "],["vmath"," atan returns the arctangent, in radians, of x.   special cases are:  atan(Â±0) ","vmath.html#atan","fn "],["vmath"," atan2 returns the arc tangent of y/x, using  the signs of the two to determine ","vmath.html#atan2","fn "],["vmath"," asin returns the arcsine, in radians, of x.   special cases are:  asin(Â±0) = Â","vmath.html#asin","fn "],["vmath"," acos returns the arccosine, in radians, of x.   special case is:  acos(x) = nan","vmath.html#acos","fn "],["vmath","","vmath.html#log","fn "],["vmath","","vmath.html#log_n","fn "],["vmath"," log10 returns the decimal logarithm of x.  The special cases are the same as fo","vmath.html#log10","fn "],["vmath"," log2 returns the binary logarithm of x.  The special cases are the same as for ","vmath.html#log2","fn "],["vmath","","vmath.html#log1p","fn "],["vmath"," log_b returns the binary exponent of x.   special cases are:  log_b(Â±inf) = +i","vmath.html#log_b","fn "],["vmath"," ilog_b returns the binary exponent of x as an integer.   special cases are:  il","vmath.html#ilog_b","fn "],["vmath"," degrees convert from degrees to radians. ","vmath.html#degrees","fn "],["vmath"," radians convert from radians to degrees. ","vmath.html#radians","fn "],["vmath"," max returns the maximum value of the two provided. ","vmath.html#max","fn "],["vmath"," min returns the minimum value of the two provided. ","vmath.html#min","fn "],["vmath","","vmath.html#minmax","fn "],["vmath"," modf returns integer and fractional floating-point numbers  that sum to f. Both","vmath.html#modf","fn "],["vmath"," nextafter32 returns the next representable f32 value after x towards y.   speci","vmath.html#nextafter32","fn "],["vmath"," nextafter returns the next representable f64 value after x towards y.   special","vmath.html#nextafter","fn "],["vmath"," pow returns base raised to the provided power. ","vmath.html#pow","fn "],["vmath"," pow10 returns 10**n, the base-10 exponential of n.   special cases are:  pow10(","vmath.html#pow10","fn "],["vmath"," copysign returns a value with the magnitude of x and the sign of y ","vmath.html#copysign","fn "],["vmath"," signbit returns a value with the boolean representation of the sign for x ","vmath.html#signbit","fn "],["vmath","","vmath.html#sin","fn "],["vmath","","vmath.html#cos","fn "],["vmath","","vmath.html#sincos","fn "],["vmath"," sinh calculates hyperbolic sine. ","vmath.html#sinh","fn "],["vmath"," cosh returns the hyperbolic cosine of x.   special cases are:  cosh(Â±0) = 1  c","vmath.html#cosh","fn "],["vmath"," special cases are:  sqrt(+inf) = +inf  sqrt(Â±0) = Â±0  sqrt(x < 0) = nan  sqrt","vmath.html#sqrt","fn "],["vmath","","vmath.html#tan","fn "],["vmath","","vmath.html#cot","fn "],["vmath"," tanh returns the hyperbolic tangent of x.   special cases are:  tanh(Â±0) = Â±0","vmath.html#tanh","fn "],["vmath"," f32_bits returns the IEEE 754 binary representation of f,  with the sign bit of","vmath.html#f32_bits","fn "],["vmath"," f32_from_bits returns the floating-point number corresponding  to the IEEE 754 ","vmath.html#f32_from_bits","fn "],["vmath"," f64_bits returns the IEEE 754 binary representation of f,  with the sign bit of","vmath.html#f64_bits","fn "],["vmath"," f64_from_bits returns the floating-point number corresponding  to the IEEE 754 ","vmath.html#f64_from_bits","fn "],["vmath.bits"," --- LeadingZeros ---  leading_zeros_8 returns the number of leading zero bits i","vmath.bits.html#leading_zeros_8","fn "],["vmath.bits"," leading_zeros_16 returns the number of leading zero bits in x; the result is 16","vmath.bits.html#leading_zeros_16","fn "],["vmath.bits"," leading_zeros_32 returns the number of leading zero bits in x; the result is 32","vmath.bits.html#leading_zeros_32","fn "],["vmath.bits"," leading_zeros_64 returns the number of leading zero bits in x; the result is 64","vmath.bits.html#leading_zeros_64","fn "],["vmath.bits"," --- TrailingZeros ---  trailing_zeros_8 returns the number of trailing zero bit","vmath.bits.html#trailing_zeros_8","fn "],["vmath.bits"," trailing_zeros_16 returns the number of trailing zero bits in x; the result is ","vmath.bits.html#trailing_zeros_16","fn "],["vmath.bits"," trailing_zeros_32 returns the number of trailing zero bits in x; the result is ","vmath.bits.html#trailing_zeros_32","fn "],["vmath.bits"," trailing_zeros_64 returns the number of trailing zero bits in x; the result is ","vmath.bits.html#trailing_zeros_64","fn "],["vmath.bits"," --- OnesCount ---  ones_count_8 returns the number of one bits (\"population co","vmath.bits.html#ones_count_8","fn "],["vmath.bits"," ones_count_16 returns the number of one bits (\"population count\") in x. ","vmath.bits.html#ones_count_16","fn "],["vmath.bits"," ones_count_32 returns the number of one bits (\"population count\") in x. ","vmath.bits.html#ones_count_32","fn "],["vmath.bits"," ones_count_64 returns the number of one bits (\"population count\") in x. ","vmath.bits.html#ones_count_64","fn "],["vmath.bits"," --- RotateLeft ---  rotate_left_8 returns the value of x rotated left by (k mod","vmath.bits.html#rotate_left_8","fn "],["vmath.bits"," rotate_left_16 returns the value of x rotated left by (k mod 16) bits.  To rota","vmath.bits.html#rotate_left_16","fn "],["vmath.bits"," rotate_left_32 returns the value of x rotated left by (k mod 32) bits.  To rota","vmath.bits.html#rotate_left_32","fn "],["vmath.bits"," rotate_left_64 returns the value of x rotated left by (k mod 64) bits.  To rota","vmath.bits.html#rotate_left_64","fn "],["vmath.bits"," --- Reverse ---  reverse_8 returns the value of x with its bits in reversed ord","vmath.bits.html#reverse_8","fn "],["vmath.bits"," reverse_16 returns the value of x with its bits in reversed order. ","vmath.bits.html#reverse_16","fn "],["vmath.bits"," reverse_32 returns the value of x with its bits in reversed order. ","vmath.bits.html#reverse_32","fn "],["vmath.bits"," reverse_64 returns the value of x with its bits in reversed order. ","vmath.bits.html#reverse_64","fn "],["vmath.bits"," --- ReverseBytes ---  reverse_bytes_16 returns the value of x with its bytes in","vmath.bits.html#reverse_bytes_16","fn "],["vmath.bits"," reverse_bytes_32 returns the value of x with its bytes in reversed order.   Thi","vmath.bits.html#reverse_bytes_32","fn "],["vmath.bits"," reverse_bytes_64 returns the value of x with its bytes in reversed order.   Thi","vmath.bits.html#reverse_bytes_64","fn "],["vmath.bits"," --- Len ---  len_8 returns the minimum number of bits required to represent x; ","vmath.bits.html#len_8","fn "],["vmath.bits"," len_16 returns the minimum number of bits required to represent x; the result i","vmath.bits.html#len_16","fn "],["vmath.bits"," len_32 returns the minimum number of bits required to represent x; the result i","vmath.bits.html#len_32","fn "],["vmath.bits"," len_64 returns the minimum number of bits required to represent x; the result i","vmath.bits.html#len_64","fn "],["vmath.bits"," --- Add with carry ---  Add returns the sum with carry of x, y and carry: sum =","vmath.bits.html#add_32","fn "],["vmath.bits"," add_64 returns the sum with carry of x, y and carry: sum = x + y + carry.  The ","vmath.bits.html#add_64","fn "],["vmath.bits"," --- Subtract with borrow ---  Sub returns the difference of x, y and borrow: di","vmath.bits.html#sub_32","fn "],["vmath.bits"," sub_64 returns the difference of x, y and borrow: diff = x - y - borrow.  The b","vmath.bits.html#sub_64","fn "],["vmath.bits"," mul_32 returns the 64-bit product of x and y: (hi, lo) = x * y  with the produc","vmath.bits.html#mul_32","fn "],["vmath.bits"," mul_64 returns the 128-bit product of x and y: (hi, lo) = x * y  with the produ","vmath.bits.html#mul_64","fn "],["vmath.bits"," --- Full-width divide ---  div_32 returns the quotient and remainder of (hi, lo","vmath.bits.html#div_32","fn "],["vmath.bits"," div_64 returns the quotient and remainder of (hi, lo) divided by y:  quo = (hi,","vmath.bits.html#div_64","fn "],["vmath.bits"," rem_32 returns the remainder of (hi, lo) divided by y. Rem32 panics  for y == 0","vmath.bits.html#rem_32","fn "],["vmath.bits"," rem_64 returns the remainder of (hi, lo) divided by y. Rem64 panics  for y == 0","vmath.bits.html#rem_64","fn "],["vmath.complex","","vmath.complex.html#Complex","struct "],["vmath.complex"," To String method ","vmath.complex.html#Complex.str","fn (Complex)"],["vmath.complex"," Complex Modulus value  mod() and abs() return the same ","vmath.complex.html#Complex.abs","fn (Complex)"],["vmath.complex","","vmath.complex.html#Complex.mod","fn (Complex)"],["vmath.complex"," Complex Angle ","vmath.complex.html#Complex.angle","fn (Complex)"],["vmath.complex"," Complex Addition c1 + c2 ","vmath.complex.html#Complex.+","fn (Complex)"],["vmath.complex"," Complex Substraction c1 - c2 ","vmath.complex.html#Complex.-","fn (Complex)"],["vmath.complex"," Complex Multiplication c1 * c2 ","vmath.complex.html#Complex.*","fn (Complex)"],["vmath.complex"," Complex Division c1 / c2 ","vmath.complex.html#Complex./","fn (Complex)"],["vmath.complex"," Complex Addition c1.add(c2) ","vmath.complex.html#Complex.add","fn (Complex)"],["vmath.complex"," Complex Subtraction c1.subtract(c2) ","vmath.complex.html#Complex.subtract","fn (Complex)"],["vmath.complex"," Complex Multiplication c1.multiply(c2) ","vmath.complex.html#Complex.multiply","fn (Complex)"],["vmath.complex"," Complex Division c1.divide(c2) ","vmath.complex.html#Complex.divide","fn (Complex)"],["vmath.complex"," Complex Conjugate ","vmath.complex.html#Complex.conjugate","fn (Complex)"],["vmath.complex"," Complex Additive Inverse  Based on  http://tutorial.vmath.lamar.edu/Extras/Comp","vmath.complex.html#Complex.addinv","fn (Complex)"],["vmath.complex"," Complex Multiplicative Inverse  Based on  http://tutorial.vmath.lamar.edu/Extra","vmath.complex.html#Complex.mulinv","fn (Complex)"],["vmath.complex"," Complex Power  Based on  https://www.khanacademy.org/math/precalculus/imaginary","vmath.complex.html#Complex.pow","fn (Complex)"],["vmath.complex"," Complex nth root ","vmath.complex.html#Complex.root","fn (Complex)"],["vmath.complex"," Complex Exponential  Using Euler's Identity  Based on  https://www.vmath.wisc.e","vmath.complex.html#Complex.exp","fn (Complex)"],["vmath.complex"," Complex Natural Logarithm  Based on  http://www.chemistrylearning.com/logarithm","vmath.complex.html#Complex.ln","fn (Complex)"],["vmath.complex"," Complex Log Base Complex  Based on  http://www.milefoot.com/math/complex/summar","vmath.complex.html#Complex.log","fn (Complex)"],["vmath.complex"," Complex Argument  Based on  http://mathworld.wolfram.com/ComplexArgument.html ","vmath.complex.html#Complex.arg","fn (Complex)"],["vmath.complex"," Complex raised to Complex Power  Based on  http://mathworld.wolfram.com/Complex","vmath.complex.html#Complex.cpow","fn (Complex)"],["vmath.complex"," Complex Sin  Based on  http://www.milefoot.com/math/complex/functionsofi.htm ","vmath.complex.html#Complex.sin","fn (Complex)"],["vmath.complex"," Complex Cosine  Based on  http://www.milefoot.com/math/complex/functionsofi.htm","vmath.complex.html#Complex.cos","fn (Complex)"],["vmath.complex"," Complex Tangent  Based on  http://www.milefoot.com/math/complex/functionsofi.ht","vmath.complex.html#Complex.tan","fn (Complex)"],["vmath.complex"," Complex Cotangent  Based on  http://www.suitcaseofdreams.net/Trigonometric_Func","vmath.complex.html#Complex.cot","fn (Complex)"],["vmath.complex"," Complex Secant  Based on  http://www.suitcaseofdreams.net/Trigonometric_Functio","vmath.complex.html#Complex.sec","fn (Complex)"],["vmath.complex"," Complex Cosecant  Based on  http://www.suitcaseofdreams.net/Trigonometric_Funct","vmath.complex.html#Complex.csc","fn (Complex)"],["vmath.complex"," Complex Arc Sin / Sin Inverse  Based on  http://www.milefoot.com/math/complex/s","vmath.complex.html#Complex.asin","fn (Complex)"],["vmath.complex"," Complex Arc Consine / Consine Inverse  Based on  http://www.milefoot.com/math/c","vmath.complex.html#Complex.acos","fn (Complex)"],["vmath.complex"," Complex Arc Tangent / Tangent Inverse  Based on  http://www.milefoot.com/math/c","vmath.complex.html#Complex.atan","fn (Complex)"],["vmath.complex"," Complex Arc Cotangent / Cotangent Inverse  Based on  http://www.suitcaseofdream","vmath.complex.html#Complex.acot","fn (Complex)"],["vmath.complex"," Complex Arc Secant / Secant Inverse  Based on  http://www.suitcaseofdreams.net/","vmath.complex.html#Complex.asec","fn (Complex)"],["vmath.complex"," Complex Arc Cosecant / Cosecant Inverse  Based on  http://www.suitcaseofdreams.","vmath.complex.html#Complex.acsc","fn (Complex)"],["vmath.complex"," Complex Hyperbolic Sin  Based on  http://www.milefoot.com/math/complex/function","vmath.complex.html#Complex.sinh","fn (Complex)"],["vmath.complex"," Complex Hyperbolic Cosine  Based on  http://www.milefoot.com/math/complex/funct","vmath.complex.html#Complex.cosh","fn (Complex)"],["vmath.complex"," Complex Hyperbolic Tangent  Based on  http://www.milefoot.com/math/complex/func","vmath.complex.html#Complex.tanh","fn (Complex)"],["vmath.complex"," Complex Hyperbolic Cotangent  Based on  http://www.suitcaseofdreams.net/Hyperbo","vmath.complex.html#Complex.coth","fn (Complex)"],["vmath.complex"," Complex Hyperbolic Secant  Based on  http://www.suitcaseofdreams.net/Hyperbolic","vmath.complex.html#Complex.sech","fn (Complex)"],["vmath.complex"," Complex Hyperbolic Cosecant  Based on  http://www.suitcaseofdreams.net/Hyperbol","vmath.complex.html#Complex.csch","fn (Complex)"],["vmath.complex"," Complex Hyperbolic Arc Sin / Sin Inverse  Based on  http://www.suitcaseofdreams","vmath.complex.html#Complex.asinh","fn (Complex)"],["vmath.complex"," Complex Hyperbolic Arc Consine / Consine Inverse  Based on  http://www.suitcase","vmath.complex.html#Complex.acosh","fn (Complex)"],["vmath.complex"," Complex Hyperbolic Arc Tangent / Tangent Inverse  Based on  http://www.suitcase","vmath.complex.html#Complex.atanh","fn (Complex)"],["vmath.complex"," Complex Hyperbolic Arc Cotangent / Cotangent Inverse  Based on  http://www.suit","vmath.complex.html#Complex.acoth","fn (Complex)"],["vmath.complex"," Complex Hyperbolic Arc Secant / Secant Inverse  Based on  http://www.suitcaseof","vmath.complex.html#Complex.acsch","fn (Complex)"],["vmath.complex"," Complex Equals ","vmath.complex.html#Complex.equals","fn (Complex)"],["vmath.complex","","vmath.complex.html#complex","fn "],["vmath.fractions"," approximate returns a Fraction that approcimates the given value to  within the","vmath.fractions.html#approximate","fn "],["vmath.fractions"," approximate_with_eps returns a Fraction ","vmath.fractions.html#approximate_with_eps","fn "],["vmath.fractions"," A factory function for creating a Fraction, adds a boundary condition  to ensur","vmath.fractions.html#fraction","fn "],["vmath.fractions","","vmath.fractions.html#Fraction","type "],["vmath.fractions"," To String method ","vmath.fractions.html#Fraction.str","fn (Fraction)"],["vmath.fractions"," Fraction add using operator overloading ","vmath.fractions.html#Fraction.+","fn (Fraction)"],["vmath.fractions"," Fraction subtract using operator overloading ","vmath.fractions.html#Fraction.-","fn (Fraction)"],["vmath.fractions"," Fraction multiply using operator overloading ","vmath.fractions.html#Fraction.*","fn (Fraction)"],["vmath.fractions"," Fraction divide using operator overloading ","vmath.fractions.html#Fraction./","fn (Fraction)"],["vmath.fractions"," Fraction add method. Deprecated. Use the operator instead. ","vmath.fractions.html#Fraction.add","fn (Fraction)"],["vmath.fractions"," Fraction subtract method. Deprecated. Use the operator instead. ","vmath.fractions.html#Fraction.subtract","fn (Fraction)"],["vmath.fractions"," Fraction multiply method. Deprecated. Use the operator instead. ","vmath.fractions.html#Fraction.multiply","fn (Fraction)"],["vmath.fractions"," Fraction divide method. Deprecated. Use the operator instead. ","vmath.fractions.html#Fraction.divide","fn (Fraction)"],["vmath.fractions"," Fraction negate method ","vmath.fractions.html#Fraction.negate","fn (Fraction)"],["vmath.fractions"," Fraction reciprocal method ","vmath.fractions.html#Fraction.reciprocal","fn (Fraction)"],["vmath.fractions"," Fraction method which reduces the fraction ","vmath.fractions.html#Fraction.reduce","fn (Fraction)"],["vmath.fractions"," f64 converts the Fraction to 64-bit floating point ","vmath.fractions.html#Fraction.f64","fn (Fraction)"],["vmath.fractions"," +-----------------------------+  | Public comparison functions |  +------------","vmath.fractions.html#Fraction.equals","fn (Fraction)"],["vmath.fractions"," ge returns true if f1 >= f2 ","vmath.fractions.html#Fraction.ge","fn (Fraction)"],["vmath.fractions"," gt returns true if f1 > f2 ","vmath.fractions.html#Fraction.gt","fn (Fraction)"],["vmath.fractions"," le returns true if f1 <= f2 ","vmath.fractions.html#Fraction.le","fn (Fraction)"],["vmath.fractions"," lt returns true if f1 < f2 ","vmath.fractions.html#Fraction.lt","fn (Fraction)"],];
