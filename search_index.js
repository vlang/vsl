var searchModuleIndex = ["vsl","vsl.blas","vsl.blas.vlas","vsl.blas.vlas.internal.float64","vsl.consts","vsl.deriv","vsl.diff","vsl.dist","vsl.easings","vsl.errors","vsl.fit","vsl.fun","vsl.gm","vsl.graph","vsl.internal","vsl.iter","vsl.la","vsl.ml","vsl.poly","vsl.quaternion","vsl.roots","vsl.stats","vsl.util","vsl.vmath","vsl.vmath.bits","vsl.vmath.complex","vsl.vmath.fractions","vsl.vmath.vimpl",];
var searchIndex = ["ArbitraryFn","DfFn","FdfFn","VectorValuedFn","Function","eval","safe_eval","FunctionFdf","eval_f","eval_df","eval_f_df","FunctionVec","eval","c_trans","c_uplo","l_uplo","job_vlr","slice_to_col_major","col_major_to_slice","print_col_major","print_col_major_v","print_col_major_py","slice_to_col_major_complex","col_major_complex_to_slice","print_col_major_complex","print_col_major_complex_v","print_col_major_omplex_py","get_join_complex","get_split_complex","join_complex","split_complex","extract_row","extract_col","extract_row_complex","extract_col_complex","eigenvecs_build","eigenvecs_build_both","dgesv","dgesvd","dgetrf","dgetri","dpotrf","dgeev","dlange","set_num_threads","ddot","dscal","daxpy","dgemv","dgemm","dger","dnrm2","dsyrk","Transpose","Uplo","Diagonal","dgemm","dgemv","dnrm2","dasum","idamax","dswap","dcopy","daxpy","drotg","drot","dscal","ddot","dger","dgbmv","dtrmv","dtrsv","dsymv","dtbmv","dtpmv","dtbsv","dsbmv","dsyr","dsyr2","dtpsv","dspmv","dspr","dspr2","dsyrk","axpy_unitary","axpy_unitary_to","axpy_inc","axpy_inc_to","dot_unitary","dot_inc","ger","gemv_n","gemv_t","l2_norm_unitary","l2_norm_inc","l2_distance_unitary","scal_unitary","scal_unitary_to","scal_inc","scal_inc_to","central","forward","backward","backward","forward","central","text_hist","build_text_hist","Histogram","find_bin","count","gen_labels","density_area","new_histogram","EasingFn","linear_interpolation","quadratic_ease_in","quadratic_ease_out","quadratic_ease_in_out","cubic_ease_in","cubic_ease_out","cubic_ease_in_out","quartic_ease_in","quartic_ease_out","quartic_ease_in_out","quintic_ease_in","quintic_ease_out","quintic_ease_in_out","sine_ease_in","sine_ease_out","sine_ease_in_out","circular_ease_in","circular_ease_out","circular_ease_in_out","exponential_ease_in","exponential_ease_out","exponential_ease_in_out","elastic_ease_in","elastic_ease_out","elastic_ease_in_out","back_ease_in","back_ease_out","back_ease_in_out","bounce_ease_in","bounce_ease_out","bounce_ease_in_out","animate","ErrorCode","vsl_error","vsl_panic","vsl_error_message","vsl_panic_message","str_error","linear","linear_sigma","bessel_j0","bessel_j1","bessel_jn","bessel_y0","bessel_y1","bessel_yn","pzero","pone","qzero","qone","cgamma","clog_gamma","ChebSeries","eval_e","choose","digamma","psi","erf","erfc","beta","binomial","uint_binomial","rbinomial","n_combos_w_replacement","suqcos","suqsin","atan2p","atan2pdeg","ramp","heav","sign","boxcar","rect","hat","hatd1","sramp","srampd1","srampd2","logistic","logistic_d1","sabs","sabs_d1","sabs_d2","exp_pix","exp_mix","sinc","neg_one_pow_n","imag_pow_n","imag_x_pow_n","powp","pow2","pow3","gamma","log_gamma","log_gamma_sign","hypot","hypot_e","sin_e","cos_e","sin","cos","Point","clone","disp","str","Segment","len","new_scaled","vector","str","new_point","dist_point_point","new_segment","vector_dot","vector_norm","vector_new","vector_add","dist_point_line","points_lims","is_point_in","is_point_in_line","BinEntry","Bin","str","Bins","append","clear","find_bin_by_index","calc_index","find_closest","find_closest_and_append","find_along_segment","get_limits","nactive","nentries","summary","str","new_bins","PointsDiffFn","SorthestPaths","Graph","nverts","get_edge","shortest_paths","path","calc_dist","str_dist_matrix","get_adj","new_graph","combinations","CombinationsIter","next","new_combinations_iter","combinations_with_replacement","CombinationsWithReplacementIter","next","new_combinations_with_replacement_iter","Counter","next","new_count_iter","Cycler","next","new_cycle_iter","Repeater","next","new_repeat_iter","PermutationsIter","next","new_permutations_iter","permutations","ProductIterator","next","new_product_iterator","product","vector_rms_error","vector_dot","vector_add","vector_max_diff","vector_scale_abs","matrix_vector_mul","matrix_tr_vector_mul","vector_vector_tr_mul","matrix_vector_mul_add","matrix_matrix_mul","matrix_tr_matrix_mul","matrix_matrix_tr_mul","matrix_tr_matrix_tr_mul","matrix_matrix_muladd","matrix_tr_matrix_muladd","matrix_matrix_tr_muladd","matrix_tr_matrix_tr_mul_add","matrix_add","den_solve","Matrix","set_from_deep2","set_diag","set","get","get_deep2","clone","transpose","copy_into","add","fill","clear_rc","clear_bry","max_diff","largest","col","get_row","get_col","extract_cols","set_col","norm_frob","norm_inf","apply","det","str","print","print_v","print_py","new_matrix","matrix_deep2","matrix_raw","safe_print","matrix_inv_small","matrix_svd","matrix_inv","matrix_cond_num","SparseConfig","set_mumps_symmetry","set_umfpack_symmetry","set_mumps_ordering","set_mumps_scaling","new_sparse_config","Triplet","init","put","put_matrix_and_matrix_t","put_cc_matrix_and_matrix_t","start","len","max","size","to_dense","CCMatrix","new_triplet","VectorApplyFn","vector_apply","vector_apply_func","vector_unit","vector_accum","vector_norm","vector_rms","vector_norm_diff","vector_largest","Data","set","clone","add_observer","notify_update","new_data","data_from_raw_x","data_from_raw_xy","Kmeans","update","nb_classes","set_centroids","find_closest_centroids","compute_centroids","train","new_kmeans","TrainConfig","LinReg","name","predict","cost","gradients","train","add_observer","notify_update","calce","new_lin_reg","ParamsReg","init","backup","restore","set_params","set_param","get_param","set_thetas","get_thetas","access_thetas","access_bias","set_theta","get_theta","set_bias","get_bias","set_lambda","get_lambda","set_degree","get_degree","add_observer","notify_update","new_params_reg","Stat","name","update","sum_vars","copy_into","stat_from_data","eval","eval_derivs","solve_quadratic","solve_cubic","companion_matrix","balance_companion_matrix","add","substract","multiply","Quaternion","*","+","-","/","abs","add","angle","conjugate","copy","divide","equal","exp","inverse","is_finite","is_greater","is_greaterequal","is_inf","is_less","is_lessequal","is_nan","is_zero","lerp","log","multiply","nlerp","norm","normalized","opposite","parity_antisymmetric_part","parity_conjugate","parity_symmetric_part","pow","rotation_chordal_distance","rotation_intrinsic_distance","rotor_chordal_distance","rotor_intrinsic_distance","scalar_add","scalar_divide","scalar_multiply","scalar_pow","scalar_subtract","slerp","sqrt","squad","str","subtract","x_parity_antisymmetric_part","x_parity_conjugate","x_parity_symmetric_part","y_parity_antisymmetric_part","y_parity_conjugate","y_parity_symmetric_part","z_parity_antisymmetric_part","z_parity_conjugate","z_parity_symmetric_part","quaternion","id","from_axis_anglef3","from_spherical_coords","from_euler_angles","bisection","brent","newton","newton_bisection","freq","mean","geometric_mean","harmonic_mean","median_for_sorted_data","mode","rms","population_variance","population_variance_mean","sample_variance","sample_variance_mean","population_stddev","population_stddev_mean","sample_stddev","sample_stddev_mean","absdev","absdev_mean","tss","tss_mean","min","max","minmax","min_index","max_index","minmax_index","range","covariance","covariance_mean","lag1_autocorrelation","lag1_autocorrelation_mean","kurtosis","kurtosis_mean_stddev","skew","skew_mean_stddev","quantile_for_sorted_data","int_ints_map_append","str_ints_map_append","str_flts_map_append","Observer","Observable","add_observer","notify_update","imax","imin","arange","range","get_many","lin_space","stepped_range","move_ith_to_end","inf","nan","is_nan","is_inf","is_finite","normalize","acosh","asinh","atanh","cot","expm1","ilog_b","frexp","ldexp","log1p","log_b","log_gamma_sign","minmax","nextafter","nextafter32","modf","round_to_even","pow10","sincos","abs","acos","asin","atan","atan2","cbrt","ceil","copysign","cos","cosh","degrees","digits","exp","erf","erfc","exp2","factorial","log_factorial","floor","fmod","gamma","gcd","hypot","lcm","log","log2","log10","log_gamma","log_n","max","min","mod","pow","radians","round","signbit","sin","sinh","sqrt","tan","tanh","trunc","f32_bits","f32_from_bits","f64_bits","f64_from_bits","leading_zeros_8","leading_zeros_16","leading_zeros_32","leading_zeros_64","trailing_zeros_8","trailing_zeros_16","trailing_zeros_32","trailing_zeros_64","ones_count_8","ones_count_16","ones_count_32","ones_count_64","rotate_left_8","rotate_left_16","rotate_left_32","rotate_left_64","reverse_8","reverse_16","reverse_32","reverse_64","reverse_bytes_16","reverse_bytes_32","reverse_bytes_64","len_8","len_16","len_32","len_64","add_32","add_64","sub_32","sub_64","mul_32","mul_64","div_32","div_64","rem_32","rem_64","Complex","str","abs","mod","angle","+","-","*","/","add","subtract","multiply","divide","conjugate","addinv","mulinv","pow","root","exp","ln","log","arg","cpow","sin","cos","tan","cot","sec","csc","asin","acos","atan","acot","asec","acsc","sinh","cosh","tanh","coth","sech","csch","asinh","acosh","atanh","acoth","acsch","equals","complex","approximate","approximate_with_eps","fraction","Fraction","str","+","-","*","/","add","subtract","multiply","divide","negate","reciprocal","reduce","f64","equals","ge","gt","le","lt","abs","inf","nan","is_nan","is_inf","is_finite","normalize","cbrt","ChebSeries","digits","mod","fmod","gcd","lcm","erf","erfc","exp","exp2","ldexp","frexp","expm1","factorial","log_factorial","floor","ceil","trunc","round","round_to_even","gamma","log_gamma","log_gamma_sign","hypot","acosh","asinh","atanh","atan","atan2","asin","acos","log","log_n","log10","log2","log1p","log_b","ilog_b","degrees","radians","max","min","minmax","modf","nextafter32","nextafter","pow","pow10","copysign","signbit","sin","cos","sincos","sinh","cosh","sqrt","tan","cot","tanh","f32_bits","f32_from_bits","f64_bits","f64_from_bits",];
var searchModuleData = [[" ","vsl.html"],["# Basic Linear Algebra System","vsl.blas.html"],[" ","vsl.blas.vlas.html"],[" ","vsl.blas.vlas.internal.float64.html"],["# Constants","vsl.consts.html"],["# Numerical Differentiation","vsl.deriv.html"],["# Numerical Differentiation","vsl.diff.html"],["# Probability Distributions algorithms","vsl.dist.html"],["# Easing Functions","vsl.easings.html"],[" ","vsl.errors.html"],[" ","vsl.fit.html"],[" ","vsl.fun.html"],["# Geometry algorithms and structures","vsl.gm.html"],["# Graph theory structures and algorithms","vsl.graph.html"],[" ","vsl.internal.html"],["# Iterator Tools","vsl.iter.html"],[" ","vsl.la.html"],[" ","vsl.ml.html"],["# Polynomials","vsl.poly.html"],["# Quaternions","vsl.quaternion.html"],["# One Dimensional Root-Finding","vsl.roots.html"],["# Statistics","vsl.stats.html"],[" ","vsl.util.html"],["# VSL Math Library","vsl.vmath.html"],[" ","vsl.vmath.bits.html"],["# Complex Numbers","vsl.vmath.complex.html"],[" ","vsl.vmath.fractions.html"],[" ","vsl.vmath.vimpl.html"],];
var searchData = [["vsl","","vsl.html#ArbitraryFn","type "],["vsl","","vsl.html#DfFn","type "],["vsl","","vsl.html#FdfFn","type "],["vsl","","vsl.html#VectorValuedFn","type "],["vsl"," Definition of an arbitrary function with parameters ","vsl.html#Function","struct "],["vsl","","vsl.html#Function.eval","fn (Function)"],["vsl"," Call the pointed-to function with argument x, put its result in y, and  return ","vsl.html#Function.safe_eval","fn (Function)"],["vsl"," Definition of an arbitrary function returning two values, r1, r2 ","vsl.html#FunctionFdf","struct "],["vsl","","vsl.html#FunctionFdf.eval_f","fn (FunctionFdf)"],["vsl","","vsl.html#FunctionFdf.eval_df","fn (FunctionFdf)"],["vsl","","vsl.html#FunctionFdf.eval_f_df","fn (FunctionFdf)"],["vsl"," Definition of an arbitrary vector-valued function with parameters ","vsl.html#FunctionVec","struct "],["vsl","","vsl.html#FunctionVec.eval","fn (FunctionVec)"],["vsl.blas","","vsl.blas.html#c_trans","fn "],["vsl.blas","","vsl.blas.html#c_uplo","fn "],["vsl.blas","","vsl.blas.html#l_uplo","fn "],["vsl.blas","","vsl.blas.html#job_vlr","fn "],["vsl.blas"," slice_to_col_major converts nested slice into an array representing a col-major","vsl.blas.html#slice_to_col_major","fn "],["vsl.blas"," col_major_to_slice converts col-major matrix to nested slice ","vsl.blas.html#col_major_to_slice","fn "],["vsl.blas"," print_col_major prints matrix (without commas or brackets) ","vsl.blas.html#print_col_major","fn "],["vsl.blas"," print_col_major_v prints matrix in v format ","vsl.blas.html#print_col_major_v","fn "],["vsl.blas"," print_col_major_py prints matrix in Python format ","vsl.blas.html#print_col_major_py","fn "],["vsl.blas"," slice_to_col_major_complex converts nested slice into an array representing a c","vsl.blas.html#slice_to_col_major_complex","fn "],["vsl.blas"," col_major_complex_to_slice converts col-major matrix to nested slice ","vsl.blas.html#col_major_complex_to_slice","fn "],["vsl.blas"," print_col_major_complex prints matrix (without commas or brackets).  _**NOTE**:","vsl.blas.html#print_col_major_complex","fn "],["vsl.blas"," print_col_major_complex_v prints matrix in v format  _**NOTE**: if non-empty, n","vsl.blas.html#print_col_major_complex_v","fn "],["vsl.blas"," print_col_major_omplex_py prints matrix in Python format  _**NOTE**: if non-emp","vsl.blas.html#print_col_major_omplex_py","fn "],["vsl.blas"," get_join_complex joins real and imag parts of array ","vsl.blas.html#get_join_complex","fn "],["vsl.blas"," get_split_complex splits real and imag parts of array ","vsl.blas.html#get_split_complex","fn "],["vsl.blas"," join_complex joins real and imag parts of array ","vsl.blas.html#join_complex","fn "],["vsl.blas"," split_complex splits real and imag parts of array ","vsl.blas.html#split_complex","fn "],["vsl.blas"," extract_row extracts i row from (m,n) col-major matrix ","vsl.blas.html#extract_row","fn "],["vsl.blas"," extract_col extracts j column from (m,n) col-major matrix ","vsl.blas.html#extract_col","fn "],["vsl.blas"," extract_row_complex extracts i row from (m,n) col-major matrix (complex version","vsl.blas.html#extract_row_complex","fn "],["vsl.blas"," extract_col_complex extracts j column from (m,n) col-major matrix (complex vers","vsl.blas.html#extract_col_complex","fn "],["vsl.blas"," eigenvecs_build builds complex eigenvectros created by Dgeev function   **input","vsl.blas.html#eigenvecs_build","fn "],["vsl.blas"," eigenvecs_build_both builds complex left and right eigenvectros created by Dgee","vsl.blas.html#eigenvecs_build_both","fn "],["vsl.blas","","vsl.blas.html#dgesv","fn "],["vsl.blas"," dgesvd computes the singular value decomposition (SVD) of a real M-by-N matrix ","vsl.blas.html#dgesvd","fn "],["vsl.blas"," dgetrf computes an LU factorization of a general M-by-N matrix A using partial ","vsl.blas.html#dgetrf","fn "],["vsl.blas"," dgetri computes the inverse of a matrix using the LU factorization computed by ","vsl.blas.html#dgetri","fn "],["vsl.blas"," dpotrf computes the Cholesky factorization of a real symmetric positive definit","vsl.blas.html#dpotrf","fn "],["vsl.blas"," dgeev computes for an N-by-N real nonsymmetric matrix A, the  eigenvalues and, ","vsl.blas.html#dgeev","fn "],["vsl.blas","","vsl.blas.html#dlange","fn "],["vsl.blas"," set_num_threads sets the number of threads in VLAS ","vsl.blas.html#set_num_threads","fn "],["vsl.blas"," ddot forms the dot product of two vectors. Uses unrolled loops for increments e","vsl.blas.html#ddot","fn "],["vsl.blas"," dscal scales a vector by a constant. Uses unrolled loops for increment equal to","vsl.blas.html#dscal","fn "],["vsl.blas"," daxpy computes constant times a vector plus a vector.   See: http://www.netlib.","vsl.blas.html#daxpy","fn "],["vsl.blas"," dgemv performs one of the matrix-vector operations   See: http://www.netlib.org","vsl.blas.html#dgemv","fn "],["vsl.blas"," dgemm performs one of the matrix-matrix operations   false,false:  C_{m,n} := Î","vsl.blas.html#dgemm","fn "],["vsl.blas"," dger performs the rank 1 operation   See: http://www.netlib.org/lapack/explore-","vsl.blas.html#dger","fn "],["vsl.blas","","vsl.blas.html#dnrm2","fn "],["vsl.blas"," dsyrk performs one of the symmetric rank k operations   See: http://www.netlib.","vsl.blas.html#dsyrk","fn "],["vsl.blas.vlas","","vsl.blas.vlas.html#Transpose","type "],["vsl.blas.vlas","","vsl.blas.vlas.html#Uplo","type "],["vsl.blas.vlas","","vsl.blas.vlas.html#Diagonal","type "],["vsl.blas.vlas"," dgemm performs one of the matrix-matrix operations   C = alpha * A * B + beta *","vsl.blas.vlas.html#dgemm","fn "],["vsl.blas.vlas"," dgemv computes   y = alpha * A * x + beta * y   if trans_a = blas_no_trans   y ","vsl.blas.vlas.html#dgemv","fn "],["vsl.blas.vlas"," dnrm2 computes the Euclidean norm of a vector,   sqrt(\sum_i x[i] * x[i]).  Thi","vsl.blas.vlas.html#dnrm2","fn "],["vsl.blas.vlas"," dasum computes the sum of the absolute values of the elements of x.   \sum_i |x","vsl.blas.vlas.html#dasum","fn "],["vsl.blas.vlas"," idamax returns the index of an element of x with the largest absolute value.  I","vsl.blas.vlas.html#idamax","fn "],["vsl.blas.vlas"," dswap exchanges the elements of two vectors.   x[i], y[i] = y[i], x[i] for all ","vsl.blas.vlas.html#dswap","fn "],["vsl.blas.vlas"," dcopy copies the elements of x into the elements of y.   y[i] = x[i] for all i ","vsl.blas.vlas.html#dcopy","fn "],["vsl.blas.vlas"," daxpy adds alpha times x to y   y[i] += alpha * x[i] for all i ","vsl.blas.vlas.html#daxpy","fn "],["vsl.blas.vlas"," drotg computes the plane rotation    _    _      _ _       _ _   |  c s |    | ","vsl.blas.vlas.html#drotg","fn "],["vsl.blas.vlas"," drot applies a plane transformation.   x[i] = c * x[i] + s * y[i]   y[i] = c * ","vsl.blas.vlas.html#drot","fn "],["vsl.blas.vlas"," dscal scales x by alpha.   x[i] *= alpha  dscal has no effect if incx < 0. ","vsl.blas.vlas.html#dscal","fn "],["vsl.blas.vlas"," ddot computes the dot product of the two vectors   \sum_i x[i]*y[i] ","vsl.blas.vlas.html#ddot","fn "],["vsl.blas.vlas"," dger performs the rank-one operation   A += alpha * x * yáµ€  where A is an mÃ—","vsl.blas.vlas.html#dger","fn "],["vsl.blas.vlas"," dgbmv performs one of the matrix-vector operations   y = alpha * A * x + beta *","vsl.blas.vlas.html#dgbmv","fn "],["vsl.blas.vlas"," dtrmv performs one of the matrix-vector operations   x = A * x   if trans_a == ","vsl.blas.vlas.html#dtrmv","fn "],["vsl.blas.vlas"," dtrsv solves one of the systems of equations   A * x = b   if trans_a == blas_n","vsl.blas.vlas.html#dtrsv","fn "],["vsl.blas.vlas"," dsymv performs the matrix-vector operation   y = alpha * A * x + beta * y  wher","vsl.blas.vlas.html#dsymv","fn "],["vsl.blas.vlas"," dtbmv performs one of the matrix-vector operations   x = A * x   if trans_a == ","vsl.blas.vlas.html#dtbmv","fn "],["vsl.blas.vlas"," dtpmv performs one of the matrix-vector operations   x = A * x   if trans_a == ","vsl.blas.vlas.html#dtpmv","fn "],["vsl.blas.vlas"," dtbsv solves one of the systems of equations   A * x = b   if trans_a == blas_n","vsl.blas.vlas.html#dtbsv","fn "],["vsl.blas.vlas"," dsbmv performs the matrix-vector operation   y = alpha * A * x + beta * y  wher","vsl.blas.vlas.html#dsbmv","fn "],["vsl.blas.vlas"," dsyr performs the symmetric rank-one update   A += alpha * x * xáµ€  where A is","vsl.blas.vlas.html#dsyr","fn "],["vsl.blas.vlas"," dsyr2 performs the symmetric rank-two update   A += alpha * x * yáµ€ + alpha * ","vsl.blas.vlas.html#dsyr2","fn "],["vsl.blas.vlas"," dtpsv solves one of the systems of equations   A * x = b   if trans_a == blas_n","vsl.blas.vlas.html#dtpsv","fn "],["vsl.blas.vlas"," dspmv performs the matrix-vector operation   y = alpha * A * x + beta * y  wher","vsl.blas.vlas.html#dspmv","fn "],["vsl.blas.vlas"," dspr performs the symmetric rank-one operation   A += alpha * x * xáµ€  where A","vsl.blas.vlas.html#dspr","fn "],["vsl.blas.vlas"," dspr2 performs the symmetric rank-2 update   A += alpha * x * yáµ€ + alpha * y ","vsl.blas.vlas.html#dspr2","fn "],["vsl.blas.vlas"," dsyrk performs one of the symmetric rank-k operations   C = alpha * A * Aáµ€ + ","vsl.blas.vlas.html#dsyrk","fn "],["vsl.blas.vlas.internal.float64"," axpy_unitary ","vsl.blas.vlas.internal.float64.html#axpy_unitary","fn "],["vsl.blas.vlas.internal.float64"," axpy_unitary_to ","vsl.blas.vlas.internal.float64.html#axpy_unitary_to","fn "],["vsl.blas.vlas.internal.float64"," axpy_inc ","vsl.blas.vlas.internal.float64.html#axpy_inc","fn "],["vsl.blas.vlas.internal.float64"," axpy_inc_to ","vsl.blas.vlas.internal.float64.html#axpy_inc_to","fn "],["vsl.blas.vlas.internal.float64"," dot_unitary ","vsl.blas.vlas.internal.float64.html#dot_unitary","fn "],["vsl.blas.vlas.internal.float64"," dot_inc ","vsl.blas.vlas.internal.float64.html#dot_inc","fn "],["vsl.blas.vlas.internal.float64"," ger performs the rank-one operation   A += alpha * x * yáµ€  where A is an mÃ—n","vsl.blas.vlas.internal.float64.html#ger","fn "],["vsl.blas.vlas.internal.float64"," gemv_n computes   y = alpha * A * x + beta * y  where A is an mÃ—n dense matrix","vsl.blas.vlas.internal.float64.html#gemv_n","fn "],["vsl.blas.vlas.internal.float64"," gemv_t computes   y = alpha * Aáµ€ * x + beta * y  where A is an mÃ—n dense mat","vsl.blas.vlas.internal.float64.html#gemv_t","fn "],["vsl.blas.vlas.internal.float64"," l2_norm_unitary returns the L2-norm of x. ","vsl.blas.vlas.internal.float64.html#l2_norm_unitary","fn "],["vsl.blas.vlas.internal.float64"," l2_norm_inc returns the L2-norm of x. ","vsl.blas.vlas.internal.float64.html#l2_norm_inc","fn "],["vsl.blas.vlas.internal.float64"," l2_distance_unitary returns the L2-norm of x-y. ","vsl.blas.vlas.internal.float64.html#l2_distance_unitary","fn "],["vsl.blas.vlas.internal.float64"," scal_unitary ","vsl.blas.vlas.internal.float64.html#scal_unitary","fn "],["vsl.blas.vlas.internal.float64"," scal_unitary_to ","vsl.blas.vlas.internal.float64.html#scal_unitary_to","fn "],["vsl.blas.vlas.internal.float64"," scal_inc ","vsl.blas.vlas.internal.float64.html#scal_inc","fn "],["vsl.blas.vlas.internal.float64"," scal_inc_to ","vsl.blas.vlas.internal.float64.html#scal_inc_to","fn "],["vsl.deriv","","vsl.deriv.html#central","fn "],["vsl.deriv","","vsl.deriv.html#forward","fn "],["vsl.deriv","","vsl.deriv.html#backward","fn "],["vsl.diff","","vsl.diff.html#backward","fn "],["vsl.diff","","vsl.diff.html#forward","fn "],["vsl.diff","","vsl.diff.html#central","fn "],["vsl.dist"," text_hist prints a text histogram ","vsl.dist.html#text_hist","fn "],["vsl.dist"," build_text_hist builds a text histogram ","vsl.dist.html#build_text_hist","fn "],["vsl.dist"," Histogram holds data for computing/plotting histograms ","vsl.dist.html#Histogram","struct "],["vsl.dist"," find_bin finds where x falls in  returns -1 if x is outside the range ","vsl.dist.html#Histogram.find_bin","fn (Histogram)"],["vsl.dist"," count counts how many items fall within each bin ","vsl.dist.html#Histogram.count","fn (Histogram)"],["vsl.dist"," gen_labels generate nice labels identifying bins ","vsl.dist.html#Histogram.gen_labels","fn (Histogram)"],["vsl.dist"," density_area computes the area of the density diagram   nsamples -- number of s","vsl.dist.html#Histogram.density_area","fn (Histogram)"],["vsl.dist"," new_histogram returns an histogram struct from a given list of stations ","vsl.dist.html#new_histogram","fn "],["vsl.easings","","vsl.easings.html#EasingFn","type "],["vsl.easings"," linear_interpolation is a method of curve fitting using linear polynomials to c","vsl.easings.html#linear_interpolation","fn "],["vsl.easings"," quadratic_ease_in eases in with a power of 2 ","vsl.easings.html#quadratic_ease_in","fn "],["vsl.easings"," quadratic_easing_eases out with a power of 2 ","vsl.easings.html#quadratic_ease_out","fn "],["vsl.easings"," quadratic_easing_in_out speeds up function's growth in a power of 2, then slows","vsl.easings.html#quadratic_ease_in_out","fn "],["vsl.easings"," cubic_ease_in eases in with a power of 3 ","vsl.easings.html#cubic_ease_in","fn "],["vsl.easings"," cubic_ease_out eases out with a power of 3 ","vsl.easings.html#cubic_ease_out","fn "],["vsl.easings"," cubic_ease_in_out speeds up function's growth in a power of 3, then slows down ","vsl.easings.html#cubic_ease_in_out","fn "],["vsl.easings"," quartic_ease_in eases in with a power of 4 ","vsl.easings.html#quartic_ease_in","fn "],["vsl.easings"," quartic_ease_out eases out with a power of 4 ","vsl.easings.html#quartic_ease_out","fn "],["vsl.easings"," quartic_ease_in_out speeds up function's growth in a power of 4, then slows dow","vsl.easings.html#quartic_ease_in_out","fn "],["vsl.easings"," quintic_ease_in eases in with a power of 5 ","vsl.easings.html#quintic_ease_in","fn "],["vsl.easings"," quintic_ease_out eases out with a power of 5 ","vsl.easings.html#quintic_ease_out","fn "],["vsl.easings"," quintic_ease_in_out speeds up function's growth in a power of 5, then slows dow","vsl.easings.html#quintic_ease_in_out","fn "],["vsl.easings"," sine_ease_in accelerates using a sine formula ","vsl.easings.html#sine_ease_in","fn "],["vsl.easings"," sine_ease_out decelerates using a sine formula ","vsl.easings.html#sine_ease_out","fn "],["vsl.easings"," sine_ease_in_out accelerates and decelerates using a sine formula ","vsl.easings.html#sine_ease_in_out","fn "],["vsl.easings"," circular_ease_in accelerates using a circular function ","vsl.easings.html#circular_ease_in","fn "],["vsl.easings"," circular_ease_out decelerates using a circular function ","vsl.easings.html#circular_ease_out","fn "],["vsl.easings"," circular_ease_in_out accelerates and decelerates using a circular function ","vsl.easings.html#circular_ease_in_out","fn "],["vsl.easings"," exponential_ease_in accelerates using an exponential formula ","vsl.easings.html#exponential_ease_in","fn "],["vsl.easings"," exponential_ease_out decelerates using an exponential formula ","vsl.easings.html#exponential_ease_out","fn "],["vsl.easings"," exponential_ease_in_out accelerates and decelerates using an exponential formul","vsl.easings.html#exponential_ease_in_out","fn "],["vsl.easings"," elastic_ease_in resembles a spring oscillating back and forth, then accelerates","vsl.easings.html#elastic_ease_in","fn "],["vsl.easings"," elastic_ease_out resembles a spring oscillating back and forth, then decelerate","vsl.easings.html#elastic_ease_out","fn "],["vsl.easings"," elastic_ease_in_out resembles a spring oscillating back and forth before it beg","vsl.easings.html#elastic_ease_in_out","fn "],["vsl.easings"," back_ease_in retracts the motion slightly before it begins to accelerate ","vsl.easings.html#back_ease_in","fn "],["vsl.easings"," back_ease_out retracts the motion slightly before it begins to decelerate ","vsl.easings.html#back_ease_out","fn "],["vsl.easings"," back_ease_in_out retracts the motion slightly before it begins to accelerate, t","vsl.easings.html#back_ease_in_out","fn "],["vsl.easings"," bounce_ease_in creates a bouncing effect, then accelerates ","vsl.easings.html#bounce_ease_in","fn "],["vsl.easings"," bounce_ease_out creates a bouncing effect, then decelerates ","vsl.easings.html#bounce_ease_out","fn "],["vsl.easings"," bounce_ease_in_out creates a bouncing effect before it begins to accelerate, th","vsl.easings.html#bounce_ease_in_out","fn "],["vsl.easings"," animate returns []f64 of length \"frames\" using the easing function provided w","vsl.easings.html#animate","fn "],["vsl.errors","","vsl.errors.html#ErrorCode","enum "],["vsl.errors","","vsl.errors.html#vsl_error","fn "],["vsl.errors","","vsl.errors.html#vsl_panic","fn "],["vsl.errors","","vsl.errors.html#vsl_error_message","fn "],["vsl.errors","","vsl.errors.html#vsl_panic_message","fn "],["vsl.errors","","vsl.errors.html#str_error","fn "],["vsl.fit"," linear computes linear fitting parameters. Errors on y-direction only   `y(x) =","vsl.fit.html#linear","fn "],["vsl.fit"," linear_sigma computes linear fitting parameters and variances (sigma_a, sigma_b","vsl.fit.html#linear_sigma","fn "],["vsl.fun"," bessel_j0 returns the order-zero Bessel function of the first kind.   special c","vsl.fun.html#bessel_j0","fn "],["vsl.fun"," bessel_j1 returns the order-one Bessel function of the first kind.   special ca","vsl.fun.html#bessel_j1","fn "],["vsl.fun"," bessel_jn returns the order-n Bessel function of the first kind.   special case","vsl.fun.html#bessel_jn","fn "],["vsl.fun"," bessel_y0 returns the order-zero Bessel function of the second kind.   special ","vsl.fun.html#bessel_y0","fn "],["vsl.fun"," bessel_y1 returns the order-one Bessel function of the second kind.   special c","vsl.fun.html#bessel_y1","fn "],["vsl.fun"," bessel_yn returns the order-n Bessel function of the second kind.   special cas","vsl.fun.html#bessel_yn","fn "],["vsl.fun"," The asymptotic expansions of pzero is  1 - 9/128 s**2 + 11025/98304 s**4 - ...,","vsl.fun.html#pzero","fn "],["vsl.fun"," For x >= 8, the asymptotic expansions of pone is  1 + 15/128 s**2 - 4725/2**15 ","vsl.fun.html#pone","fn "],["vsl.fun"," For x >= 8, the asymptotic expansions of qzero is  -1/8 s + 75/1024 s**3 - ...,","vsl.fun.html#qzero","fn "],["vsl.fun"," For x >= 8, the asymptotic expansions of qone is  3/8 s - 105/1024 s**3 - ..., ","vsl.fun.html#qone","fn "],["vsl.fun"," gamma computes the gamma function value ","vsl.fun.html#cgamma","fn "],["vsl.fun"," log_gamma computes the log-gamma function value ","vsl.fun.html#clog_gamma","fn "],["vsl.fun"," data for a Chebyshev series over a given interval ","vsl.fun.html#ChebSeries","struct "],["vsl.fun","","vsl.fun.html#ChebSeries.eval_e","fn (ChebSeries)"],["vsl.fun"," Compute the binomial coefficient ","vsl.fun.html#choose","fn "],["vsl.fun","","vsl.fun.html#digamma","fn "],["vsl.fun","","vsl.fun.html#psi","fn "],["vsl.fun"," erf returns the error function of x.   special cases are:  erf(+inf) = 1  erf(-","vsl.fun.html#erf","fn "],["vsl.fun"," erfc returns the complementary error function of x.   special cases are:  erfc(","vsl.fun.html#erfc","fn "],["vsl.fun"," beta computes the beta function by calling the log_gamma_sign function ","vsl.fun.html#beta","fn "],["vsl.fun"," binomial comptues the binomial coefficient (n k)^t ","vsl.fun.html#binomial","fn "],["vsl.fun"," uint_binomial implements the binomial coefficient using u64. panic happens on o","vsl.fun.html#uint_binomial","fn "],["vsl.fun"," rbinomial computes the binomial coefficient with real (non-negative) arguments ","vsl.fun.html#rbinomial","fn "],["vsl.fun"," (n+r-1)! / r! / (n-1)! when n > 0. ","vsl.fun.html#n_combos_w_replacement","fn "],["vsl.fun"," suqcos implements the superquadric auxiliary function that uses cos(x) ","vsl.fun.html#suqcos","fn "],["vsl.fun"," suqsin implements the superquadric auxiliary function that uses sin(x) ","vsl.fun.html#suqsin","fn "],["vsl.fun"," atan2p implements a positive version of atan2, in such a way that: 0 â‰¤ Î± â‰¤","vsl.fun.html#atan2p","fn "],["vsl.fun"," atan2pdeg implements a positive version of atan2, in such a way that: 0 â‰¤ Î± ","vsl.fun.html#atan2pdeg","fn "],["vsl.fun"," ramp function => macaulay brackets ","vsl.fun.html#ramp","fn "],["vsl.fun"," heav computes the heaviside step function (== derivative of ramp(x))           ","vsl.fun.html#heav","fn "],["vsl.fun"," sign implements the sign function ","vsl.fun.html#sign","fn "],["vsl.fun"," boxcar implements the boxcar function   `boxcar(x;a,b) = heav(x-a) - heav(x-b)`","vsl.fun.html#boxcar","fn "],["vsl.fun"," rect implements the rectangular function   `rect(x) = boxcar(x;-0.5,0.5)` ","vsl.fun.html#rect","fn "],["vsl.fun"," hat implements the hat function ","vsl.fun.html#hat","fn "],["vsl.fun"," hatd1 returns the first derivative of the hat function  _**NOTE**: the disconti","vsl.fun.html#hatd1","fn "],["vsl.fun"," sramp implements a smooth ramp function. ramp ","vsl.fun.html#sramp","fn "],["vsl.fun"," srampd1 returns the first derivative of sramp ","vsl.fun.html#srampd1","fn "],["vsl.fun"," srampd2 returns the second derivative of sramp ","vsl.fun.html#srampd2","fn "],["vsl.fun"," logistic implements the sigmoid/logistic function ","vsl.fun.html#logistic","fn "],["vsl.fun"," logistic_d1 implements the first derivative of the sigmoid/logistic function ","vsl.fun.html#logistic_d1","fn "],["vsl.fun"," sabs implements a smooth abs function: sabs(x) = x*x / (sign(x)*x + eps) ","vsl.fun.html#sabs","fn "],["vsl.fun"," sabs_d1 returns the first derivative of sabs ","vsl.fun.html#sabs_d1","fn "],["vsl.fun"," sabs_d2 returns the first derivative of sabs ","vsl.fun.html#sabs_d2","fn "],["vsl.fun"," exp_pix uses euler's formula to compute exp(+iâ‹…x) = cos(x) + iâ‹…sin(x) ","vsl.fun.html#exp_pix","fn "],["vsl.fun"," exp_mix uses euler's formula to compute exp(-iâ‹…x) = cos(x) - iâ‹…sin(x) ","vsl.fun.html#exp_mix","fn "],["vsl.fun"," sinc computes the sine cardinal (sinc) function     sinc(x) = |     1      if x","vsl.fun.html#sinc","fn "],["vsl.fun"," neg_one_pow_n computes (-1)â¿ ","vsl.fun.html#neg_one_pow_n","fn "],["vsl.fun"," imag_pow_n computes iâ¿ = (âˆš-1)â¿ ","vsl.fun.html#imag_pow_n","fn "],["vsl.fun"," imag_x_pow_n computes (xâ‹…i)â¿ ","vsl.fun.html#imag_x_pow_n","fn "],["vsl.fun"," powp computes real raised to positive integer xâ¿ ","vsl.fun.html#powp","fn "],["vsl.fun"," pow2 computes xÂ² ","vsl.fun.html#pow2","fn "],["vsl.fun"," pow3 computes xÂ³ ","vsl.fun.html#pow3","fn "],["vsl.fun"," gamma returns the gamma function of x.   special ifs are:  gamma(+inf) = +inf  ","vsl.fun.html#gamma","fn "],["vsl.fun"," log_gamma returns the natural logarithm and sign (-1 or +1) of Gamma(x).   spec","vsl.fun.html#log_gamma","fn "],["vsl.fun","","vsl.fun.html#log_gamma_sign","fn "],["vsl.fun","","vsl.fun.html#hypot","fn "],["vsl.fun","","vsl.fun.html#hypot_e","fn "],["vsl.fun","","vsl.fun.html#sin_e","fn "],["vsl.fun","","vsl.fun.html#cos_e","fn "],["vsl.fun","","vsl.fun.html#sin","fn "],["vsl.fun","","vsl.fun.html#cos","fn "],["vsl.gm"," Point holds the Cartesian coordinates of a point in 3D space ","vsl.gm.html#Point","struct "],["vsl.gm"," clone creates a new copy of Point ","vsl.gm.html#Point.clone","fn (Point)"],["vsl.gm"," disp creates a new copy of Point displaced by dx, dy, dz ","vsl.gm.html#Point.disp","fn (Point)"],["vsl.gm"," str outputs Point ","vsl.gm.html#Point.str","fn (Point)"],["vsl.gm"," Segment represents a directed segment from a to b ","vsl.gm.html#Segment","struct "],["vsl.gm"," len computes the length of Segment == Euclidean norm ","vsl.gm.html#Segment.len","fn (Segment)"],["vsl.gm"," New creates a new Segment scaled by m and starting from A ","vsl.gm.html#Segment.new_scaled","fn (Segment)"],["vsl.gm"," vector returns the vector representing Segment from A to B (scaled by m) ","vsl.gm.html#Segment.vector","fn (Segment)"],["vsl.gm"," str outputs Segment ","vsl.gm.html#Segment.str","fn (Segment)"],["vsl.gm"," new_point creates a new point ","vsl.gm.html#new_point","fn "],["vsl.gm"," dist_point_point computes the unsigned distance from a to b ","vsl.gm.html#dist_point_point","fn "],["vsl.gm"," new_segment creates a new segment from a to b ","vsl.gm.html#new_segment","fn "],["vsl.gm"," vector_dot returns the dot product between two vectors ","vsl.gm.html#vector_dot","fn "],["vsl.gm"," vector_norm returns the length (Euclidean norm) of a vector ","vsl.gm.html#vector_norm","fn "],["vsl.gm"," vector_new returns a new vector scaled by m ","vsl.gm.html#vector_new","fn "],["vsl.gm"," vector_add returns a new vector by adding two other vectors   w := Î±*u + Î²*v ","vsl.gm.html#vector_add","fn "],["vsl.gm"," dist_point_line computes the distance from p to line passing through a -> b ","vsl.gm.html#dist_point_line","fn "],["vsl.gm"," points_lims returns the limits of a set of points ","vsl.gm.html#points_lims","fn "],["vsl.gm"," is_point_in returns whether p is inside box with cmin and cmax ","vsl.gm.html#is_point_in","fn "],["vsl.gm"," is_point_in_line returns whether p is inside line passing through a and b ","vsl.gm.html#is_point_in_line","fn "],["vsl.gm"," BinEntry holds data of an entry to bin ","vsl.gm.html#BinEntry","struct "],["vsl.gm"," Bin defines one bin in Bins (holds entries for search) ","vsl.gm.html#Bin","struct "],["vsl.gm"," str returns the string representation of one Bin ","vsl.gm.html#Bin.str","fn (Bin)"],["vsl.gm"," Bins implements a set of bins holding entries and is used to fast search entrie","vsl.gm.html#Bins","struct "],["vsl.gm"," append adds a new entry {x, id, something} into the bins structure ","vsl.gm.html#Bins.append","fn (Bins)"],["vsl.gm"," clear clears all biBinsns ","vsl.gm.html#Bins.clear","fn (Bins)"],["vsl.gm"," find_bin_by_index finds or allocate new bin corresponding to index idx ","vsl.gm.html#Bins.find_bin_by_index","fn (Bins)"],["vsl.gm"," calc_index calculates the bin index where the point x is  returns -1 if out-of-","vsl.gm.html#Bins.calc_index","fn (Bins)"],["vsl.gm"," find_closest returns the id of the entry whose coordinates are closest to x    ","vsl.gm.html#Bins.find_closest","fn (Bins)"],["vsl.gm"," find_closest_and_append finds closest point and, if not found, append to bins w","vsl.gm.html#Bins.find_closest_and_append","fn (Bins)"],["vsl.gm"," find_along_segment gets the ids of entries that lie close to a segment   Note: ","vsl.gm.html#Bins.find_along_segment","fn (Bins)"],["vsl.gm"," get_limits returns limigs of a specific bin ","vsl.gm.html#Bins.get_limits","fn (Bins)"],["vsl.gm"," nactive returns the number of active bins; i.e. non-nil bins ","vsl.gm.html#Bins.nactive","fn (Bins)"],["vsl.gm"," nentries returns the total number of entries (in active bins) ","vsl.gm.html#Bins.nentries","fn (Bins)"],["vsl.gm"," summary returns the summary of this Bins' data ","vsl.gm.html#Bins.summary","fn (Bins)"],["vsl.gm"," str returns the string representation of a set of Bins ","vsl.gm.html#Bins.str","fn (Bins)"],["vsl.gm"," new_bins initialise bins structure    xmin -- [ndim] min/initial coordinates of","vsl.gm.html#new_bins","fn "],["vsl.gm","","vsl.gm.html#PointsDiffFn","type "],["vsl.graph","","vsl.graph.html#SorthestPaths","enum "],["vsl.graph"," Graph defines a graph structure ","vsl.graph.html#Graph","struct "],["vsl.graph"," nverts returns the number of vertices ","vsl.graph.html#Graph.nverts","fn (Graph)"],["vsl.graph"," get_edge performs a lookup on key2edge map and returs id of edge for given node","vsl.graph.html#Graph.get_edge","fn (Graph)"],["vsl.graph","","vsl.graph.html#Graph.shortest_paths","fn (Graph)"],["vsl.graph"," path returns the path from source (s) to destination (t)  Note: shortest_paths ","vsl.graph.html#Graph.path","fn (Graph)"],["vsl.graph"," calc_dist computes distances beetween all vertices and initialises 'next' matri","vsl.graph.html#Graph.calc_dist","fn (Graph)"],["vsl.graph"," str_dist_matrix returns a string representation of dist matrix ","vsl.graph.html#Graph.str_dist_matrix","fn (Graph)"],["vsl.graph"," get_adj returns adjacency list as a compressed storage format for METIS ","vsl.graph.html#Graph.get_adj","fn (Graph)"],["vsl.graph"," new_graph initialises graph  edges    -- [nedges][2] edges (connectivity)  weig","vsl.graph.html#new_graph","fn "],["vsl.iter"," combinations will return an array of all length `r` combinations of `data`  Whi","vsl.iter.html#combinations","fn "],["vsl.iter","","vsl.iter.html#CombinationsIter","struct "],["vsl.iter"," next will return next combination if possible ","vsl.iter.html#CombinationsIter.next","fn (CombinationsIter)"],["vsl.iter"," new_combinations_iter will return an iterator that allows  lazy computation for","vsl.iter.html#new_combinations_iter","fn "],["vsl.iter"," combinations_with_replacement will return r length subsequences of elements fro","vsl.iter.html#combinations_with_replacement","fn "],["vsl.iter","","vsl.iter.html#CombinationsWithReplacementIter","struct "],["vsl.iter"," next will return next combination if possible ","vsl.iter.html#CombinationsWithReplacementIter.next","fn (CombinationsWithReplacementIter)"],["vsl.iter"," new_combinations_with_replacement_iter will return an iterator that allows  laz","vsl.iter.html#new_combinations_with_replacement_iter","fn "],["vsl.iter","","vsl.iter.html#Counter","struct "],["vsl.iter","","vsl.iter.html#Counter.next","fn (Counter)"],["vsl.iter","","vsl.iter.html#new_count_iter","fn "],["vsl.iter","","vsl.iter.html#Cycler","struct "],["vsl.iter","","vsl.iter.html#Cycler.next","fn (Cycler)"],["vsl.iter","","vsl.iter.html#new_cycle_iter","fn "],["vsl.iter","","vsl.iter.html#Repeater","struct "],["vsl.iter","","vsl.iter.html#Repeater.next","fn (Repeater)"],["vsl.iter","","vsl.iter.html#new_repeat_iter","fn "],["vsl.iter","","vsl.iter.html#PermutationsIter","struct "],["vsl.iter"," next will return next permutation if possible ","vsl.iter.html#PermutationsIter.next","fn (PermutationsIter)"],["vsl.iter"," new_permutations_iter will return an iterator that allows  lazy computation for","vsl.iter.html#new_permutations_iter","fn "],["vsl.iter"," permutations returns successive `r` length permutations of elements in `data` ","vsl.iter.html#permutations","fn "],["vsl.iter","","vsl.iter.html#ProductIterator","struct "],["vsl.iter","","vsl.iter.html#ProductIterator.next","fn (ProductIterator)"],["vsl.iter","","vsl.iter.html#new_product_iterator","fn "],["vsl.iter"," Cartesian product of the arrays in `data` ","vsl.iter.html#product","fn "],["vsl.la","","vsl.la.html#vector_rms_error","fn "],["vsl.la"," vector_dot returns the dot product between two vectors:  s := uãƒ»v ","vsl.la.html#vector_dot","fn "],["vsl.la"," vector_add adds the scaled components of two vectors  res := alphaâ‹…u + betaâ‹","vsl.la.html#vector_add","fn "],["vsl.la"," vector_max_diff returns the maximum absolute difference between two vectors  ma","vsl.la.html#vector_max_diff","fn "],["vsl.la"," vector_scale_abs creates a \"scale\" vector using the absolute value of another","vsl.la.html#vector_scale_abs","fn "],["vsl.la"," matrix_vector_mul returns the matrix-vector multiplication   v = alphaâ‹…aâ‹…u ","vsl.la.html#matrix_vector_mul","fn "],["vsl.la"," matrix_tr_vector_mul returns the transpose(matrix)-vector multiplication   v = ","vsl.la.html#matrix_tr_vector_mul","fn "],["vsl.la"," vector_vector_tr_mul returns the matrix = vector-transpose(vector) multiplicati","vsl.la.html#vector_vector_tr_mul","fn "],["vsl.la"," matrix_vector_mul_add returns the matrix-vector multiplication with addition   ","vsl.la.html#matrix_vector_mul_add","fn "],["vsl.la"," matrix_matrix_mul returns the matrix multiplication (scaled)    c := alphaâ‹…aâ","vsl.la.html#matrix_matrix_mul","fn "],["vsl.la"," matrix_tr_matrix_mul returns the matrix multiplication (scaled) with transposed","vsl.la.html#matrix_tr_matrix_mul","fn "],["vsl.la"," matrix_matrix_tr_mul returns the matrix multiplication (scaled) with transposed","vsl.la.html#matrix_matrix_tr_mul","fn "],["vsl.la"," matrix_tr_matrix_tr_mul returns the matrix multiplication (scaled) with transpo","vsl.la.html#matrix_tr_matrix_tr_mul","fn "],["vsl.la"," matrix_matrix_muladd returns the matrix multiplication (scaled)    c += alphaâ‹","vsl.la.html#matrix_matrix_muladd","fn "],["vsl.la"," matrix_tr_matrix_muladd returns the matrix multiplication (scaled) with transpo","vsl.la.html#matrix_tr_matrix_muladd","fn "],["vsl.la"," matrix_matrix_tr_muladd returns the matrix multiplication (scaled) with transpo","vsl.la.html#matrix_matrix_tr_muladd","fn "],["vsl.la"," matrix_tr_matrix_tr_mul_add returns the matrix multiplication (scaled) with tra","vsl.la.html#matrix_tr_matrix_tr_mul_add","fn "],["vsl.la"," matrix_add adds the scaled components of two matrices    res := alphaâ‹…a + bet","vsl.la.html#matrix_add","fn "],["vsl.la"," den_solve solves dense linear system using LAPACK (OpenBLaS)     Given:  a â‹… ","vsl.la.html#den_solve","fn "],["vsl.la","","vsl.la.html#Matrix","struct "],["vsl.la"," set_from_deep2 sets matrix with data from a nested slice (Deep2) structure ","vsl.la.html#Matrix.set_from_deep2","fn (Matrix)"],["vsl.la"," set_diag sets diagonal matrix with diagonal components equal to val ","vsl.la.html#Matrix.set_diag","fn (Matrix)"],["vsl.la"," set sets value ","vsl.la.html#Matrix.set","fn (Matrix)"],["vsl.la"," get gets value ","vsl.la.html#Matrix.get","fn (Matrix)"],["vsl.la"," get_deep2 returns nested slice representation ","vsl.la.html#Matrix.get_deep2","fn (Matrix)"],["vsl.la"," clone returns a copy of this matrix ","vsl.la.html#Matrix.clone","fn (Matrix)"],["vsl.la"," transpose returns the transpose matrix ","vsl.la.html#Matrix.transpose","fn (Matrix)"],["vsl.la"," copy_into copies the scaled components of this matrix into another one (result)","vsl.la.html#Matrix.copy_into","fn (Matrix)"],["vsl.la"," add adds value to (i,j) location ","vsl.la.html#Matrix.add","fn (Matrix)"],["vsl.la"," fill fills this matrix with a single number val  aij = val ","vsl.la.html#Matrix.fill","fn (Matrix)"],["vsl.la","","vsl.la.html#Matrix.clear_rc","fn (Matrix)"],["vsl.la","","vsl.la.html#Matrix.clear_bry","fn (Matrix)"],["vsl.la"," max_diff returns the maximum difference between the components of this and anot","vsl.la.html#Matrix.max_diff","fn (Matrix)"],["vsl.la"," largest returns the largest component |a[ij]| of this matrix, normalised by den","vsl.la.html#Matrix.largest","fn (Matrix)"],["vsl.la"," col access column j of this matrix. No copies are made since the internal data ","vsl.la.html#Matrix.col","fn (Matrix)"],["vsl.la"," get_row returns row i of this matrix ","vsl.la.html#Matrix.get_row","fn (Matrix)"],["vsl.la"," get_col returns column j of this matrix ","vsl.la.html#Matrix.get_col","fn (Matrix)"],["vsl.la"," extract_cols returns columns from j=start to j=endp1-1  start -- first column  ","vsl.la.html#Matrix.extract_cols","fn (Matrix)"],["vsl.la"," set_col sets the values of a column j with a single value ","vsl.la.html#Matrix.set_col","fn (Matrix)"],["vsl.la"," norm_frob returns the Frobenius norm of this matrix  nrm := â€–aâ€–_F = sqrt(Î£","vsl.la.html#Matrix.norm_frob","fn (Matrix)"],["vsl.la"," norm_inf returns the infinite norm of this matrix  nrm := â€–aâ€–_âˆž = max_i (","vsl.la.html#Matrix.norm_inf","fn (Matrix)"],["vsl.la"," apply sets this matrix with the scaled components of another matrix  this := al","vsl.la.html#Matrix.apply","fn (Matrix)"],["vsl.la"," det computes the determinant of matrix using the LU factorization  NOTE: this m","vsl.la.html#Matrix.det","fn (Matrix)"],["vsl.la","","vsl.la.html#Matrix.str","fn (Matrix)"],["vsl.la"," print prints matrix (without commas or brackets) ","vsl.la.html#Matrix.print","fn (Matrix)"],["vsl.la"," print_v prints matrix in V format ","vsl.la.html#Matrix.print_v","fn (Matrix)"],["vsl.la"," print_py prints matrix in Python format ","vsl.la.html#Matrix.print_py","fn (Matrix)"],["vsl.la"," matrix allocates a new (empty) Matrix with given (m,n) (row/col sizes) ","vsl.la.html#new_matrix","fn "],["vsl.la"," matrix_deep2 allocates a new Matrix from given (Deep2) nested slice.  NOTE: mak","vsl.la.html#matrix_deep2","fn "],["vsl.la"," matrix_raw creates a new Matrix using given raw data  Input:  rawdata -- data o","vsl.la.html#matrix_raw","fn "],["vsl.la","","vsl.la.html#safe_print","fn "],["vsl.la"," matrix_inv_small computes the inverse of small matrices of size 1x1, 2x2, or 3x","vsl.la.html#matrix_inv_small","fn "],["vsl.la"," matrix_svd performs the SVD decomposition  Input:  a     -- matrix a  copy_a --","vsl.la.html#matrix_svd","fn "],["vsl.la"," matrix_inv computes the inverse of a general matrix (square or not). It also co","vsl.la.html#matrix_inv","fn "],["vsl.la"," matrix_cond_num returns the condition number of a square matrix using the inver","vsl.la.html#matrix_cond_num","fn "],["vsl.la"," The SparseConfig structure holds configuration arguments for sparse solvers ","vsl.la.html#SparseConfig","struct "],["vsl.la"," set_mumps_symmetry sets symmetry options for MUMPS solver ","vsl.la.html#SparseConfig.set_mumps_symmetry","fn (SparseConfig)"],["vsl.la"," set_umfpack_symmetry sets symmetry options for UMFPACK solver ","vsl.la.html#SparseConfig.set_umfpack_symmetry","fn (SparseConfig)"],["vsl.la"," set_mumps_ordering sets ordering for MUMPS solver  ordering -- \"\" or \"amf\" ","vsl.la.html#SparseConfig.set_mumps_ordering","fn (SparseConfig)"],["vsl.la"," set_mumps_scaling sets scaling for MUMPS solver  scaling -- \"\" or \"rcit\" [d","vsl.la.html#SparseConfig.set_mumps_scaling","fn (SparseConfig)"],["vsl.la"," new_sparse_config returns a new SparseConfig  Input:   comm -- may be nil ","vsl.la.html#new_sparse_config","fn "],["vsl.la"," Triplet is a simple representation of a sparse matrix, where the indices and va","vsl.la.html#Triplet","struct "],["vsl.la"," init allocates all memory required to hold a sparse matrix in triplet form ","vsl.la.html#Triplet.init","fn (Triplet)"],["vsl.la"," put inserts an element to a pre-allocated (with init) triplet matrix ","vsl.la.html#Triplet.put","fn (Triplet)"],["vsl.la","","vsl.la.html#Triplet.put_matrix_and_matrix_t","fn (Triplet)"],["vsl.la","","vsl.la.html#Triplet.put_cc_matrix_and_matrix_t","fn (Triplet)"],["vsl.la"," start (re)starts index for inserting items using the put command ","vsl.la.html#Triplet.start","fn (Triplet)"],["vsl.la"," Len returns the number of items just inserted in the triplet ","vsl.la.html#Triplet.len","fn (Triplet)"],["vsl.la"," max returns the maximum number of items that can be inserted in the triplet ","vsl.la.html#Triplet.max","fn (Triplet)"],["vsl.la"," size returns the row/column size of the matrix represented by the Triplet ","vsl.la.html#Triplet.size","fn (Triplet)"],["vsl.la"," to_dense returns the dense matrix corresponding to this Triplet ","vsl.la.html#Triplet.to_dense","fn (Triplet)"],["vsl.la"," CCMatrix represents a sparse matrix using the so-called \"column-compressed for","vsl.la.html#CCMatrix","struct "],["vsl.la"," new_triplet returns a new Triplet. This is a wrapper to new(Triplet) followed b","vsl.la.html#new_triplet","fn "],["vsl.la","","vsl.la.html#VectorApplyFn","type "],["vsl.la"," apply sets this []f64 with the scaled components of another []f64  this := a * ","vsl.la.html#vector_apply","fn "],["vsl.la"," apply_func runs a function over all components of a []f64  vi = f(i,vi) ","vsl.la.html#vector_apply_func","fn "],["vsl.la"," unit returns the unit []f64 parallel to this []f64  b := a / norm(a) ","vsl.la.html#vector_unit","fn "],["vsl.la"," accum sum/accumulates all components in a []f64  sum := Î£_i v[i] ","vsl.la.html#vector_accum","fn "],["vsl.la"," norm returns the Euclidean norm of a []f64:  nrm := â€–vâ€– ","vsl.la.html#vector_norm","fn "],["vsl.la"," rms returns the root-mean-square of this []f64  ","vsl.la.html#vector_rms","fn "],["vsl.la"," norm_diff returns the Euclidean norm of the difference:  nrm := ||u - v|| ","vsl.la.html#vector_norm_diff","fn "],["vsl.la"," largest returns the largest component |u[i]| of this []f64, normalised by den  ","vsl.la.html#vector_largest","fn "],["vsl.ml","","vsl.ml.html#Data","struct "],["vsl.ml"," set sets x matrix and y vector [optional] and notify observers  Input:  x -- x ","vsl.ml.html#Data.set","fn (Data)"],["vsl.ml"," clone returns a deep copy of this object ","vsl.ml.html#Data.clone","fn (Data)"],["vsl.ml"," add_observer adds an object to the list of interested observers ","vsl.ml.html#Data.add_observer","fn (Data)"],["vsl.ml"," notify_update notifies observers of updates ","vsl.ml.html#Data.notify_update","fn (Data)"],["vsl.ml"," data returns a new object to hold ML data  Input:  nb_samples  -- number of dat","vsl.ml.html#new_data","fn "],["vsl.ml"," data_from_raw_x returns a new object with data set from raw x values  Input:  x","vsl.ml.html#data_from_raw_x","fn "],["vsl.ml"," data_from_raw_xy returns a new object with data set from raw Xy values  Input: ","vsl.ml.html#data_from_raw_xy","fn "],["vsl.ml"," Kmeans implements the K-means model (Observer of Data) ","vsl.ml.html#Kmeans","struct "],["vsl.ml"," update perform updates after data has been changed (as an Observer) ","vsl.ml.html#Kmeans.update","fn (Kmeans)"],["vsl.ml"," nb_classes returns the number of classes ","vsl.ml.html#Kmeans.nb_classes","fn (Kmeans)"],["vsl.ml"," set_centroids sets centroids; e.g. trial centroids    xc -- [nb_class][nb_featu","vsl.ml.html#Kmeans.set_centroids","fn (Kmeans)"],["vsl.ml"," find_closest_centroids finds closest centroids to each sample ","vsl.ml.html#Kmeans.find_closest_centroids","fn (Kmeans)"],["vsl.ml"," compute_centroids update centroids based on new classes information (from find_","vsl.ml.html#Kmeans.compute_centroids","fn (Kmeans)"],["vsl.ml"," train trains model ","vsl.ml.html#Kmeans.train","fn (Kmeans)"],["vsl.ml"," new_kmeans returns a new K-means model ","vsl.ml.html#new_kmeans","fn "],["vsl.ml","","vsl.ml.html#TrainConfig","struct "],["vsl.ml"," LinReg implements a linear regression model ","vsl.ml.html#LinReg","struct "],["vsl.ml"," name returns the name of this LinReg object (thus defining the Observer interfa","vsl.ml.html#LinReg.name","fn (LinReg)"],["vsl.ml"," predict returns the model evaluation @ {x;theta,b}    Input:      x -- vector o","vsl.ml.html#LinReg.predict","fn (LinReg)"],["vsl.ml"," cost returns the cost c(x;theta,b)    Input:      data -- x,y data      params ","vsl.ml.html#LinReg.cost","fn (LinReg)"],["vsl.ml"," gradients returns âˆ‚C/âˆ‚theta and âˆ‚C/âˆ‚b    Output:      dcdtheta -- âˆ‚C/","vsl.ml.html#LinReg.gradients","fn (LinReg)"],["vsl.ml"," train finds theta and b using closed-form solution    Input:      data -- x,y d","vsl.ml.html#LinReg.train","fn (LinReg)"],["vsl.ml"," add_observer adds an object to the list of interested observers ","vsl.ml.html#LinReg.add_observer","fn (LinReg)"],["vsl.ml"," notify_update notifies observers of updates ","vsl.ml.html#LinReg.notify_update","fn (LinReg)"],["vsl.ml"," calce calculates e vector (save into o.e)   Output: e = bâ‹…o + xâ‹…theta - y ","vsl.ml.html#LinReg.calce","fn (LinReg)"],["vsl.ml"," new_lin_reg returns a new LinReg object    Input:      data   -- x,y data      ","vsl.ml.html#new_lin_reg","fn "],["vsl.ml","","vsl.ml.html#ParamsReg","struct "],["vsl.ml"," init initializes ParamsReg with nb_features (number of features) ","vsl.ml.html#ParamsReg.init","fn (ParamsReg)"],["vsl.ml"," backup creates an internal copy of parameters ","vsl.ml.html#ParamsReg.backup","fn (ParamsReg)"],["vsl.ml"," restore restores an internal copy of parameters and notifies observers ","vsl.ml.html#ParamsReg.restore","fn (ParamsReg)"],["vsl.ml"," set_params sets theta and b and notifies observers ","vsl.ml.html#ParamsReg.set_params","fn (ParamsReg)"],["vsl.ml"," set_param sets either theta or b (use negative indices for b). Notifies observe","vsl.ml.html#ParamsReg.set_param","fn (ParamsReg)"],["vsl.ml"," get_param returns either theta or b (use negative indices for b)   i -- index o","vsl.ml.html#ParamsReg.get_param","fn (ParamsReg)"],["vsl.ml"," set_thetas sets the whole vector theta and notifies observers ","vsl.ml.html#ParamsReg.set_thetas","fn (ParamsReg)"],["vsl.ml"," get_thetas gets a copy of theta ","vsl.ml.html#ParamsReg.get_thetas","fn (ParamsReg)"],["vsl.ml"," access_thetas returns access (slice) to theta ","vsl.ml.html#ParamsReg.access_thetas","fn (ParamsReg)"],["vsl.ml"," access_bias returns access (pointer) to b ","vsl.ml.html#ParamsReg.access_bias","fn (ParamsReg)"],["vsl.ml"," set_theta sets one component of theta and notifies observers ","vsl.ml.html#ParamsReg.set_theta","fn (ParamsReg)"],["vsl.ml"," get_theta returns the value of theta[i] ","vsl.ml.html#ParamsReg.get_theta","fn (ParamsReg)"],["vsl.ml"," set_bias sets b and notifies observers ","vsl.ml.html#ParamsReg.set_bias","fn (ParamsReg)"],["vsl.ml"," get_bias gets a copy of b ","vsl.ml.html#ParamsReg.get_bias","fn (ParamsReg)"],["vsl.ml"," set_lambda sets lambda and notifies observers ","vsl.ml.html#ParamsReg.set_lambda","fn (ParamsReg)"],["vsl.ml"," get_lambda gets a copy of lambda ","vsl.ml.html#ParamsReg.get_lambda","fn (ParamsReg)"],["vsl.ml"," set_degree sets p and notifies observers ","vsl.ml.html#ParamsReg.set_degree","fn (ParamsReg)"],["vsl.ml"," get_degree gets a copy of p ","vsl.ml.html#ParamsReg.get_degree","fn (ParamsReg)"],["vsl.ml"," add_observer adds an object to the list of interested observers ","vsl.ml.html#ParamsReg.add_observer","fn (ParamsReg)"],["vsl.ml"," notify_update notifies observers of updates ","vsl.ml.html#ParamsReg.notify_update","fn (ParamsReg)"],["vsl.ml"," new_params_reg returns a new object to hold regression parameters ","vsl.ml.html#new_params_reg","fn "],["vsl.ml"," Stat holds statistics about data   NOTE: Stat is an Observer of Data; thus, dat","vsl.ml.html#Stat","struct "],["vsl.ml"," name returns the name of this stat object (thus defining the Observer interface","vsl.ml.html#Stat.name","fn (Stat)"],["vsl.ml"," update compute statistics for given data (an Observer of Data) ","vsl.ml.html#Stat.update","fn (Stat)"],["vsl.ml"," sum_vars computes the sums along the columns of X and y  Output:  t -- scalar t","vsl.ml.html#Stat.sum_vars","fn (Stat)"],["vsl.ml"," copy_into copies stat into p ","vsl.ml.html#Stat.copy_into","fn (Stat)"],["vsl.ml"," stat returns a new Stat object ","vsl.ml.html#stat_from_data","fn "],["vsl.poly","","vsl.poly.html#eval","fn "],["vsl.poly","","vsl.poly.html#eval_derivs","fn "],["vsl.poly","","vsl.poly.html#solve_quadratic","fn "],["vsl.poly","","vsl.poly.html#solve_cubic","fn "],["vsl.poly","","vsl.poly.html#companion_matrix","fn "],["vsl.poly","","vsl.poly.html#balance_companion_matrix","fn "],["vsl.poly"," Arithmetic operations on polynomials   In the following descriptions a, b, c ar","vsl.poly.html#add","fn "],["vsl.poly","","vsl.poly.html#substract","fn "],["vsl.poly","","vsl.poly.html#multiply","fn "],["vsl.quaternion","","vsl.quaternion.html#Quaternion","struct "],["vsl.quaternion","","vsl.quaternion.html#Quaternion.*","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.+","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.-","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion./","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.abs","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.add","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.angle","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.conjugate","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.copy","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.divide","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.equal","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.exp","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.inverse","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.is_finite","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.is_greater","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.is_greaterequal","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.is_inf","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.is_less","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.is_lessequal","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.is_nan","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.is_zero","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.lerp","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.log","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.multiply","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.nlerp","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.norm","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.normalized","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.opposite","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.parity_antisymmetric_part","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.parity_conjugate","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.parity_symmetric_part","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.pow","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.rotation_chordal_distance","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.rotation_intrinsic_distance","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.rotor_chordal_distance","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.rotor_intrinsic_distance","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.scalar_add","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.scalar_divide","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.scalar_multiply","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.scalar_pow","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.scalar_subtract","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.slerp","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.sqrt","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.squad","fn (Quaternion)"],["vsl.quaternion"," To String method  w + xi + yj + zk ","vsl.quaternion.html#Quaternion.str","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.subtract","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.x_parity_antisymmetric_part","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.x_parity_conjugate","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.x_parity_symmetric_part","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.y_parity_antisymmetric_part","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.y_parity_conjugate","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.y_parity_symmetric_part","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.z_parity_antisymmetric_part","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.z_parity_conjugate","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#Quaternion.z_parity_symmetric_part","fn (Quaternion)"],["vsl.quaternion","","vsl.quaternion.html#quaternion","fn "],["vsl.quaternion","","vsl.quaternion.html#id","fn "],["vsl.quaternion","","vsl.quaternion.html#from_axis_anglef3","fn "],["vsl.quaternion","","vsl.quaternion.html#from_spherical_coords","fn "],["vsl.quaternion","","vsl.quaternion.html#from_euler_angles","fn "],["vsl.roots"," Find the root of a function using a bisection method ","vsl.roots.html#bisection","fn "],["vsl.roots"," Search for the root of func in the interval [x1, x2] with a  given tolerance ","vsl.roots.html#brent","fn "],["vsl.roots"," Find the root of a function using Newton's algorithm with the Armijo line  sear","vsl.roots.html#newton","fn "],["vsl.roots"," Find the root of a function by combining Newton's method with the bisection  me","vsl.roots.html#newton_bisection","fn "],["vsl.stats"," Measure of Occurance  Frequency of a given number  Based on  https://www.mathsi","vsl.stats.html#freq","fn "],["vsl.stats"," Measure of Central Tendancy  Mean of the given input array  Based on  https://w","vsl.stats.html#mean","fn "],["vsl.stats"," Measure of Central Tendancy  Geometric Mean of the given input array  Based on ","vsl.stats.html#geometric_mean","fn "],["vsl.stats"," Measure of Central Tendancy  Harmonic Mean of the given input array  Based on  ","vsl.stats.html#harmonic_mean","fn "],["vsl.stats"," Measure of Central Tendancy  Median of the given input array ( input array is a","vsl.stats.html#median_for_sorted_data","fn "],["vsl.stats"," Measure of Central Tendancy  Mode of the given input array  Based on  https://w","vsl.stats.html#mode","fn "],["vsl.stats"," Root Mean Square of the given input array  Based on  https://en.wikipedia.org/w","vsl.stats.html#rms","fn "],["vsl.stats"," Measure of Dispersion / Spread  Population Variance of the given input array  B","vsl.stats.html#population_variance","fn "],["vsl.stats"," Measure of Dispersion / Spread  Population Variance of the given input array  B","vsl.stats.html#population_variance_mean","fn "],["vsl.stats"," Measure of Dispersion / Spread  Sample Variance of the given input array  Based","vsl.stats.html#sample_variance","fn "],["vsl.stats"," Measure of Dispersion / Spread  Sample Variance of the given input array  Based","vsl.stats.html#sample_variance_mean","fn "],["vsl.stats"," Measure of Dispersion / Spread  Population Standard Deviation of the given inpu","vsl.stats.html#population_stddev","fn "],["vsl.stats"," Measure of Dispersion / Spread  Population Standard Deviation of the given inpu","vsl.stats.html#population_stddev_mean","fn "],["vsl.stats"," Measure of Dispersion / Spread  Sample Standard Deviation of the given input ar","vsl.stats.html#sample_stddev","fn "],["vsl.stats"," Measure of Dispersion / Spread  Sample Standard Deviation of the given input ar","vsl.stats.html#sample_stddev_mean","fn "],["vsl.stats"," Measure of Dispersion / Spread  Mean Absolute Deviation of the given input arra","vsl.stats.html#absdev","fn "],["vsl.stats"," Measure of Dispersion / Spread  Mean Absolute Deviation of the given input arra","vsl.stats.html#absdev_mean","fn "],["vsl.stats"," Sum of squares ","vsl.stats.html#tss","fn "],["vsl.stats"," Sum of squares about the mean ","vsl.stats.html#tss_mean","fn "],["vsl.stats"," Minimum of the given input array ","vsl.stats.html#min","fn "],["vsl.stats"," Maximum of the given input array ","vsl.stats.html#max","fn "],["vsl.stats"," Minimum and maximum of the given input array ","vsl.stats.html#minmax","fn "],["vsl.stats"," Minimum of the given input array ","vsl.stats.html#min_index","fn "],["vsl.stats"," Maximum of the given input array ","vsl.stats.html#max_index","fn "],["vsl.stats"," Minimum and maximum of the given input array ","vsl.stats.html#minmax_index","fn "],["vsl.stats"," Measure of Dispersion / Spread  Range ( Maximum - Minimum ) of the given input ","vsl.stats.html#range","fn "],["vsl.stats","","vsl.stats.html#covariance","fn "],["vsl.stats"," Compute the covariance of a dataset using  the recurrence relation ","vsl.stats.html#covariance_mean","fn "],["vsl.stats","","vsl.stats.html#lag1_autocorrelation","fn "],["vsl.stats"," Compute the lag-1 autocorrelation of a dataset using  the recurrence relation ","vsl.stats.html#lag1_autocorrelation_mean","fn "],["vsl.stats","","vsl.stats.html#kurtosis","fn "],["vsl.stats"," Takes a dataset and finds the kurtosis  using the fourth moment the deviations,","vsl.stats.html#kurtosis_mean_stddev","fn "],["vsl.stats","","vsl.stats.html#skew","fn "],["vsl.stats","","vsl.stats.html#skew_mean_stddev","fn "],["vsl.stats","","vsl.stats.html#quantile_for_sorted_data","fn "],["vsl.util"," int_ints_map_append appends a new item to a map of slice.  Note: this function ","vsl.util.html#int_ints_map_append","fn "],["vsl.util"," str_ints_map_append appends a new item to a map of slice.  Note: this function ","vsl.util.html#str_ints_map_append","fn "],["vsl.util"," str_flts_map_append appends a new item to a map of slice.  Note: this function ","vsl.util.html#str_flts_map_append","fn "],["vsl.util"," Observer is an interface to objects that need to observe something  the data ob","vsl.util.html#Observer","interface "],["vsl.util"," Observable indicates that an object is observable; i.e. it has a list of intere","vsl.util.html#Observable","struct "],["vsl.util"," add_observer adds an object to the list of interested observers ","vsl.util.html#Observable.add_observer","fn (Observable)"],["vsl.util"," notify_update notifies observers of updates ","vsl.util.html#Observable.notify_update","fn (Observable)"],["vsl.util"," imax returns the maximum value of the two provided. ","vsl.util.html#imax","fn "],["vsl.util"," imin returns the minimum value of the two provided. ","vsl.util.html#imin","fn "],["vsl.util"," range returns a list with int values in the interval [0, n) ","vsl.util.html#arange","fn "],["vsl.util"," range returns a list with int values in the interval [start, stop) ","vsl.util.html#range","fn "],["vsl.util"," get_many returns an array containing the values in the given idxs ","vsl.util.html#get_many","fn "],["vsl.util"," lin_space returns evenly spaced numbers over a specified closed interval. ","vsl.util.html#lin_space","fn "],["vsl.util"," Mimics python's range() with a step argument ","vsl.util.html#stepped_range","fn "],["vsl.util"," move_ith_to_end removes element at i from the array, and puts it at the end  is","vsl.util.html#move_ith_to_end","fn "],["vsl.vmath"," inf returns positive infinity if sign >= 0, negative infinity if sign < 0. ","vsl.vmath.html#inf","fn "],["vsl.vmath"," nan returns an IEEE 754 ``not-a-number'' value. ","vsl.vmath.html#nan","fn "],["vsl.vmath"," is_nan reports whether f is an IEEE 754 ``not-a-number'' value. ","vsl.vmath.html#is_nan","fn "],["vsl.vmath"," is_inf reports whether f is an infinity, according to sign.  If sign > 0, is_in","vsl.vmath.html#is_inf","fn "],["vsl.vmath","","vsl.vmath.html#is_finite","fn "],["vsl.vmath"," normalize returns a normal number y and exponent exp  satisfying x == y Ã— 2**e","vsl.vmath.html#normalize","fn "],["vsl.vmath","","vsl.vmath.html#acosh","fn "],["vsl.vmath","","vsl.vmath.html#asinh","fn "],["vsl.vmath","","vsl.vmath.html#atanh","fn "],["vsl.vmath","","vsl.vmath.html#cot","fn "],["vsl.vmath","","vsl.vmath.html#expm1","fn "],["vsl.vmath","","vsl.vmath.html#ilog_b","fn "],["vsl.vmath","","vsl.vmath.html#frexp","fn "],["vsl.vmath","","vsl.vmath.html#ldexp","fn "],["vsl.vmath","","vsl.vmath.html#log1p","fn "],["vsl.vmath","","vsl.vmath.html#log_b","fn "],["vsl.vmath","","vsl.vmath.html#log_gamma_sign","fn "],["vsl.vmath","","vsl.vmath.html#minmax","fn "],["vsl.vmath","","vsl.vmath.html#nextafter","fn "],["vsl.vmath","","vsl.vmath.html#nextafter32","fn "],["vsl.vmath"," modf returns integer and fractional floating-point numbers  that sum to f. Both","vsl.vmath.html#modf","fn "],["vsl.vmath","","vsl.vmath.html#round_to_even","fn "],["vsl.vmath","","vsl.vmath.html#pow10","fn "],["vsl.vmath","","vsl.vmath.html#sincos","fn "],["vsl.vmath"," Returns the absolute value. ","vsl.vmath.html#abs","fn "],["vsl.vmath"," acos calculates inverse cosine (arccosine). ","vsl.vmath.html#acos","fn "],["vsl.vmath"," asin calculates inverse sine (arcsine). ","vsl.vmath.html#asin","fn "],["vsl.vmath"," atan calculates inverse tangent (arctangent). ","vsl.vmath.html#atan","fn "],["vsl.vmath"," atan2 calculates inverse tangent with two arguments, returns the angle between ","vsl.vmath.html#atan2","fn "],["vsl.vmath"," cbrt calculates cubic root. ","vsl.vmath.html#cbrt","fn "],["vsl.vmath"," ceil returns the nearest f64 greater or equal to the provided value. ","vsl.vmath.html#ceil","fn "],["vsl.vmath"," copysign returns a value with the magnitude of x and the sign of y ","vsl.vmath.html#copysign","fn "],["vsl.vmath"," cos calculates cosine. ","vsl.vmath.html#cos","fn "],["vsl.vmath"," cosh calculates hyperbolic cosine. ","vsl.vmath.html#cosh","fn "],["vsl.vmath"," degrees convert from degrees to radians. ","vsl.vmath.html#degrees","fn "],["vsl.vmath"," digits returns an array of the digits of n in the given base. ","vsl.vmath.html#digits","fn "],["vsl.vmath"," exp calculates exponent of the number (math.pow(math.E, a)). ","vsl.vmath.html#exp","fn "],["vsl.vmath"," erf computes the error function value ","vsl.vmath.html#erf","fn "],["vsl.vmath"," erfc computes the complementary error function value ","vsl.vmath.html#erfc","fn "],["vsl.vmath"," exp2 returns the base-2 exponential function of a (math.pow(2, a)). ","vsl.vmath.html#exp2","fn "],["vsl.vmath"," factorial calculates the factorial of the provided value. ","vsl.vmath.html#factorial","fn "],["vsl.vmath"," log_factorial calculates the log-factorial of the provided value. ","vsl.vmath.html#log_factorial","fn "],["vsl.vmath"," floor returns the nearest f64 lower or equal of the provided value. ","vsl.vmath.html#floor","fn "],["vsl.vmath","","vsl.vmath.html#fmod","fn "],["vsl.vmath"," gamma computes the gamma function value ","vsl.vmath.html#gamma","fn "],["vsl.vmath"," gcd calculates greatest common (positive) divisor (or zero if a and b are both ","vsl.vmath.html#gcd","fn "],["vsl.vmath"," Returns hypotenuse of a right triangle. ","vsl.vmath.html#hypot","fn "],["vsl.vmath"," lcm calculates least common (non-negative) multiple. ","vsl.vmath.html#lcm","fn "],["vsl.vmath"," log calculates natural (base-e) logarithm of the provided value. ","vsl.vmath.html#log","fn "],["vsl.vmath"," log2 calculates base-2 logarithm of the provided value. ","vsl.vmath.html#log2","fn "],["vsl.vmath"," log10 calculates the common (base-10) logarithm of the provided value. ","vsl.vmath.html#log10","fn "],["vsl.vmath"," log_gamma computes the log-gamma function value ","vsl.vmath.html#log_gamma","fn "],["vsl.vmath"," log_n calculates base-N logarithm of the provided value. ","vsl.vmath.html#log_n","fn "],["vsl.vmath"," max returns the maximum value of the two provided. ","vsl.vmath.html#max","fn "],["vsl.vmath"," min returns the minimum value of the two provided. ","vsl.vmath.html#min","fn "],["vsl.vmath"," mod returns the floating-point remainder of number / denom (rounded towards zer","vsl.vmath.html#mod","fn "],["vsl.vmath"," pow returns base raised to the provided power. ","vsl.vmath.html#pow","fn "],["vsl.vmath"," radians convert from radians to degrees. ","vsl.vmath.html#radians","fn "],["vsl.vmath"," round returns the integer nearest to the provided value. ","vsl.vmath.html#round","fn "],["vsl.vmath"," signbit returns a value with the boolean representation of the sign for x ","vsl.vmath.html#signbit","fn "],["vsl.vmath"," sin calculates sine. ","vsl.vmath.html#sin","fn "],["vsl.vmath"," sinh calculates hyperbolic sine. ","vsl.vmath.html#sinh","fn "],["vsl.vmath"," sqrt calculates square-root of the provided value. ","vsl.vmath.html#sqrt","fn "],["vsl.vmath"," tan calculates tangent. ","vsl.vmath.html#tan","fn "],["vsl.vmath"," tanh calculates hyperbolic tangent. ","vsl.vmath.html#tanh","fn "],["vsl.vmath"," trunc rounds a toward zero, returning the nearest integral value that is not  l","vsl.vmath.html#trunc","fn "],["vsl.vmath"," f32_bits returns the IEEE 754 binary representation of f,  with the sign bit of","vsl.vmath.html#f32_bits","fn "],["vsl.vmath"," f32_from_bits returns the floating-point number corresponding  to the IEEE 754 ","vsl.vmath.html#f32_from_bits","fn "],["vsl.vmath"," f64_bits returns the IEEE 754 binary representation of f,  with the sign bit of","vsl.vmath.html#f64_bits","fn "],["vsl.vmath"," f64_from_bits returns the floating-point number corresponding  to the IEEE 754 ","vsl.vmath.html#f64_from_bits","fn "],["vsl.vmath.bits"," --- LeadingZeros ---  leading_zeros_8 returns the number of leading zero bits i","vsl.vmath.bits.html#leading_zeros_8","fn "],["vsl.vmath.bits"," leading_zeros_16 returns the number of leading zero bits in x; the result is 16","vsl.vmath.bits.html#leading_zeros_16","fn "],["vsl.vmath.bits"," leading_zeros_32 returns the number of leading zero bits in x; the result is 32","vsl.vmath.bits.html#leading_zeros_32","fn "],["vsl.vmath.bits"," leading_zeros_64 returns the number of leading zero bits in x; the result is 64","vsl.vmath.bits.html#leading_zeros_64","fn "],["vsl.vmath.bits"," --- TrailingZeros ---  trailing_zeros_8 returns the number of trailing zero bit","vsl.vmath.bits.html#trailing_zeros_8","fn "],["vsl.vmath.bits"," trailing_zeros_16 returns the number of trailing zero bits in x; the result is ","vsl.vmath.bits.html#trailing_zeros_16","fn "],["vsl.vmath.bits"," trailing_zeros_32 returns the number of trailing zero bits in x; the result is ","vsl.vmath.bits.html#trailing_zeros_32","fn "],["vsl.vmath.bits"," trailing_zeros_64 returns the number of trailing zero bits in x; the result is ","vsl.vmath.bits.html#trailing_zeros_64","fn "],["vsl.vmath.bits"," --- OnesCount ---  ones_count_8 returns the number of one bits (\"population co","vsl.vmath.bits.html#ones_count_8","fn "],["vsl.vmath.bits"," ones_count_16 returns the number of one bits (\"population count\") in x. ","vsl.vmath.bits.html#ones_count_16","fn "],["vsl.vmath.bits"," ones_count_32 returns the number of one bits (\"population count\") in x. ","vsl.vmath.bits.html#ones_count_32","fn "],["vsl.vmath.bits"," ones_count_64 returns the number of one bits (\"population count\") in x. ","vsl.vmath.bits.html#ones_count_64","fn "],["vsl.vmath.bits"," --- RotateLeft ---  rotate_left_8 returns the value of x rotated left by (k mod","vsl.vmath.bits.html#rotate_left_8","fn "],["vsl.vmath.bits"," rotate_left_16 returns the value of x rotated left by (k mod 16) bits.  To rota","vsl.vmath.bits.html#rotate_left_16","fn "],["vsl.vmath.bits"," rotate_left_32 returns the value of x rotated left by (k mod 32) bits.  To rota","vsl.vmath.bits.html#rotate_left_32","fn "],["vsl.vmath.bits"," rotate_left_64 returns the value of x rotated left by (k mod 64) bits.  To rota","vsl.vmath.bits.html#rotate_left_64","fn "],["vsl.vmath.bits"," --- Reverse ---  reverse_8 returns the value of x with its bits in reversed ord","vsl.vmath.bits.html#reverse_8","fn "],["vsl.vmath.bits"," reverse_16 returns the value of x with its bits in reversed order. ","vsl.vmath.bits.html#reverse_16","fn "],["vsl.vmath.bits"," reverse_32 returns the value of x with its bits in reversed order. ","vsl.vmath.bits.html#reverse_32","fn "],["vsl.vmath.bits"," reverse_64 returns the value of x with its bits in reversed order. ","vsl.vmath.bits.html#reverse_64","fn "],["vsl.vmath.bits"," --- ReverseBytes ---  reverse_bytes_16 returns the value of x with its bytes in","vsl.vmath.bits.html#reverse_bytes_16","fn "],["vsl.vmath.bits"," reverse_bytes_32 returns the value of x with its bytes in reversed order.   Thi","vsl.vmath.bits.html#reverse_bytes_32","fn "],["vsl.vmath.bits"," reverse_bytes_64 returns the value of x with its bytes in reversed order.   Thi","vsl.vmath.bits.html#reverse_bytes_64","fn "],["vsl.vmath.bits"," --- Len ---  len_8 returns the minimum number of bits required to represent x; ","vsl.vmath.bits.html#len_8","fn "],["vsl.vmath.bits"," len_16 returns the minimum number of bits required to represent x; the result i","vsl.vmath.bits.html#len_16","fn "],["vsl.vmath.bits"," len_32 returns the minimum number of bits required to represent x; the result i","vsl.vmath.bits.html#len_32","fn "],["vsl.vmath.bits"," len_64 returns the minimum number of bits required to represent x; the result i","vsl.vmath.bits.html#len_64","fn "],["vsl.vmath.bits"," --- Add with carry ---  Add returns the sum with carry of x, y and carry: sum =","vsl.vmath.bits.html#add_32","fn "],["vsl.vmath.bits"," add_64 returns the sum with carry of x, y and carry: sum = x + y + carry.  The ","vsl.vmath.bits.html#add_64","fn "],["vsl.vmath.bits"," --- Subtract with borrow ---  Sub returns the difference of x, y and borrow: di","vsl.vmath.bits.html#sub_32","fn "],["vsl.vmath.bits"," sub_64 returns the difference of x, y and borrow: diff = x - y - borrow.  The b","vsl.vmath.bits.html#sub_64","fn "],["vsl.vmath.bits"," mul_32 returns the 64-bit product of x and y: (hi, lo) = x * y  with the produc","vsl.vmath.bits.html#mul_32","fn "],["vsl.vmath.bits"," mul_64 returns the 128-bit product of x and y: (hi, lo) = x * y  with the produ","vsl.vmath.bits.html#mul_64","fn "],["vsl.vmath.bits"," --- Full-width divide ---  div_32 returns the quotient and remainder of (hi, lo","vsl.vmath.bits.html#div_32","fn "],["vsl.vmath.bits"," div_64 returns the quotient and remainder of (hi, lo) divided by y:  quo = (hi,","vsl.vmath.bits.html#div_64","fn "],["vsl.vmath.bits"," rem_32 returns the remainder of (hi, lo) divided by y. Rem32 panics  for y == 0","vsl.vmath.bits.html#rem_32","fn "],["vsl.vmath.bits"," rem_64 returns the remainder of (hi, lo) divided by y. Rem64 panics  for y == 0","vsl.vmath.bits.html#rem_64","fn "],["vsl.vmath.complex","","vsl.vmath.complex.html#Complex","struct "],["vsl.vmath.complex"," To String method ","vsl.vmath.complex.html#Complex.str","fn (Complex)"],["vsl.vmath.complex"," Complex Modulus value  mod() and abs() return the same ","vsl.vmath.complex.html#Complex.abs","fn (Complex)"],["vsl.vmath.complex","","vsl.vmath.complex.html#Complex.mod","fn (Complex)"],["vsl.vmath.complex"," Complex Angle ","vsl.vmath.complex.html#Complex.angle","fn (Complex)"],["vsl.vmath.complex"," Complex Addition c1 + c2 ","vsl.vmath.complex.html#Complex.+","fn (Complex)"],["vsl.vmath.complex"," Complex Substraction c1 - c2 ","vsl.vmath.complex.html#Complex.-","fn (Complex)"],["vsl.vmath.complex"," Complex Multiplication c1 * c2 ","vsl.vmath.complex.html#Complex.*","fn (Complex)"],["vsl.vmath.complex"," Complex Division c1 / c2 ","vsl.vmath.complex.html#Complex./","fn (Complex)"],["vsl.vmath.complex"," Complex Addition c1.add(c2) ","vsl.vmath.complex.html#Complex.add","fn (Complex)"],["vsl.vmath.complex"," Complex Subtraction c1.subtract(c2) ","vsl.vmath.complex.html#Complex.subtract","fn (Complex)"],["vsl.vmath.complex"," Complex Multiplication c1.multiply(c2) ","vsl.vmath.complex.html#Complex.multiply","fn (Complex)"],["vsl.vmath.complex"," Complex Division c1.divide(c2) ","vsl.vmath.complex.html#Complex.divide","fn (Complex)"],["vsl.vmath.complex"," Complex Conjugate ","vsl.vmath.complex.html#Complex.conjugate","fn (Complex)"],["vsl.vmath.complex"," Complex Additive Inverse  Based on  http://tutorial.vmath.lamar.edu/Extras/Comp","vsl.vmath.complex.html#Complex.addinv","fn (Complex)"],["vsl.vmath.complex"," Complex Multiplicative Inverse  Based on  http://tutorial.vmath.lamar.edu/Extra","vsl.vmath.complex.html#Complex.mulinv","fn (Complex)"],["vsl.vmath.complex"," Complex Power  Based on  https://www.khanacademy.org/math/precalculus/imaginary","vsl.vmath.complex.html#Complex.pow","fn (Complex)"],["vsl.vmath.complex"," Complex nth root ","vsl.vmath.complex.html#Complex.root","fn (Complex)"],["vsl.vmath.complex"," Complex Exponential  Using Euler's Identity  Based on  https://www.vmath.wisc.e","vsl.vmath.complex.html#Complex.exp","fn (Complex)"],["vsl.vmath.complex"," Complex Natural Logarithm  Based on  http://www.chemistrylearning.com/logarithm","vsl.vmath.complex.html#Complex.ln","fn (Complex)"],["vsl.vmath.complex"," Complex Log Base Complex  Based on  http://www.milefoot.com/math/complex/summar","vsl.vmath.complex.html#Complex.log","fn (Complex)"],["vsl.vmath.complex"," Complex Argument  Based on  http://mathworld.wolfram.com/ComplexArgument.html ","vsl.vmath.complex.html#Complex.arg","fn (Complex)"],["vsl.vmath.complex"," Complex raised to Complex Power  Based on  http://mathworld.wolfram.com/Complex","vsl.vmath.complex.html#Complex.cpow","fn (Complex)"],["vsl.vmath.complex"," Complex Sin  Based on  http://www.milefoot.com/math/complex/functionsofi.htm ","vsl.vmath.complex.html#Complex.sin","fn (Complex)"],["vsl.vmath.complex"," Complex Cosine  Based on  http://www.milefoot.com/math/complex/functionsofi.htm","vsl.vmath.complex.html#Complex.cos","fn (Complex)"],["vsl.vmath.complex"," Complex Tangent  Based on  http://www.milefoot.com/math/complex/functionsofi.ht","vsl.vmath.complex.html#Complex.tan","fn (Complex)"],["vsl.vmath.complex"," Complex Cotangent  Based on  http://www.suitcaseofdreams.net/Trigonometric_Func","vsl.vmath.complex.html#Complex.cot","fn (Complex)"],["vsl.vmath.complex"," Complex Secant  Based on  http://www.suitcaseofdreams.net/Trigonometric_Functio","vsl.vmath.complex.html#Complex.sec","fn (Complex)"],["vsl.vmath.complex"," Complex Cosecant  Based on  http://www.suitcaseofdreams.net/Trigonometric_Funct","vsl.vmath.complex.html#Complex.csc","fn (Complex)"],["vsl.vmath.complex"," Complex Arc Sin / Sin Inverse  Based on  http://www.milefoot.com/math/complex/s","vsl.vmath.complex.html#Complex.asin","fn (Complex)"],["vsl.vmath.complex"," Complex Arc Consine / Consine Inverse  Based on  http://www.milefoot.com/math/c","vsl.vmath.complex.html#Complex.acos","fn (Complex)"],["vsl.vmath.complex"," Complex Arc Tangent / Tangent Inverse  Based on  http://www.milefoot.com/math/c","vsl.vmath.complex.html#Complex.atan","fn (Complex)"],["vsl.vmath.complex"," Complex Arc Cotangent / Cotangent Inverse  Based on  http://www.suitcaseofdream","vsl.vmath.complex.html#Complex.acot","fn (Complex)"],["vsl.vmath.complex"," Complex Arc Secant / Secant Inverse  Based on  http://www.suitcaseofdreams.net/","vsl.vmath.complex.html#Complex.asec","fn (Complex)"],["vsl.vmath.complex"," Complex Arc Cosecant / Cosecant Inverse  Based on  http://www.suitcaseofdreams.","vsl.vmath.complex.html#Complex.acsc","fn (Complex)"],["vsl.vmath.complex"," Complex Hyperbolic Sin  Based on  http://www.milefoot.com/math/complex/function","vsl.vmath.complex.html#Complex.sinh","fn (Complex)"],["vsl.vmath.complex"," Complex Hyperbolic Cosine  Based on  http://www.milefoot.com/math/complex/funct","vsl.vmath.complex.html#Complex.cosh","fn (Complex)"],["vsl.vmath.complex"," Complex Hyperbolic Tangent  Based on  http://www.milefoot.com/math/complex/func","vsl.vmath.complex.html#Complex.tanh","fn (Complex)"],["vsl.vmath.complex"," Complex Hyperbolic Cotangent  Based on  http://www.suitcaseofdreams.net/Hyperbo","vsl.vmath.complex.html#Complex.coth","fn (Complex)"],["vsl.vmath.complex"," Complex Hyperbolic Secant  Based on  http://www.suitcaseofdreams.net/Hyperbolic","vsl.vmath.complex.html#Complex.sech","fn (Complex)"],["vsl.vmath.complex"," Complex Hyperbolic Cosecant  Based on  http://www.suitcaseofdreams.net/Hyperbol","vsl.vmath.complex.html#Complex.csch","fn (Complex)"],["vsl.vmath.complex"," Complex Hyperbolic Arc Sin / Sin Inverse  Based on  http://www.suitcaseofdreams","vsl.vmath.complex.html#Complex.asinh","fn (Complex)"],["vsl.vmath.complex"," Complex Hyperbolic Arc Consine / Consine Inverse  Based on  http://www.suitcase","vsl.vmath.complex.html#Complex.acosh","fn (Complex)"],["vsl.vmath.complex"," Complex Hyperbolic Arc Tangent / Tangent Inverse  Based on  http://www.suitcase","vsl.vmath.complex.html#Complex.atanh","fn (Complex)"],["vsl.vmath.complex"," Complex Hyperbolic Arc Cotangent / Cotangent Inverse  Based on  http://www.suit","vsl.vmath.complex.html#Complex.acoth","fn (Complex)"],["vsl.vmath.complex"," Complex Hyperbolic Arc Secant / Secant Inverse  Based on  http://www.suitcaseof","vsl.vmath.complex.html#Complex.acsch","fn (Complex)"],["vsl.vmath.complex"," Complex Equals ","vsl.vmath.complex.html#Complex.equals","fn (Complex)"],["vsl.vmath.complex","","vsl.vmath.complex.html#complex","fn "],["vsl.vmath.fractions"," approximate returns a Fraction that approcimates the given value to  within the","vsl.vmath.fractions.html#approximate","fn "],["vsl.vmath.fractions"," approximate_with_eps returns a Fraction ","vsl.vmath.fractions.html#approximate_with_eps","fn "],["vsl.vmath.fractions"," A factory function for creating a Fraction, adds a boundary condition  to ensur","vsl.vmath.fractions.html#fraction","fn "],["vsl.vmath.fractions","","vsl.vmath.fractions.html#Fraction","type "],["vsl.vmath.fractions"," To String method ","vsl.vmath.fractions.html#Fraction.str","fn (Fraction)"],["vsl.vmath.fractions"," Fraction add using operator overloading ","vsl.vmath.fractions.html#Fraction.+","fn (Fraction)"],["vsl.vmath.fractions"," Fraction subtract using operator overloading ","vsl.vmath.fractions.html#Fraction.-","fn (Fraction)"],["vsl.vmath.fractions"," Fraction multiply using operator overloading ","vsl.vmath.fractions.html#Fraction.*","fn (Fraction)"],["vsl.vmath.fractions"," Fraction divide using operator overloading ","vsl.vmath.fractions.html#Fraction./","fn (Fraction)"],["vsl.vmath.fractions"," Fraction add method. Deprecated. Use the operator instead. ","vsl.vmath.fractions.html#Fraction.add","fn (Fraction)"],["vsl.vmath.fractions"," Fraction subtract method. Deprecated. Use the operator instead. ","vsl.vmath.fractions.html#Fraction.subtract","fn (Fraction)"],["vsl.vmath.fractions"," Fraction multiply method. Deprecated. Use the operator instead. ","vsl.vmath.fractions.html#Fraction.multiply","fn (Fraction)"],["vsl.vmath.fractions"," Fraction divide method. Deprecated. Use the operator instead. ","vsl.vmath.fractions.html#Fraction.divide","fn (Fraction)"],["vsl.vmath.fractions"," Fraction negate method ","vsl.vmath.fractions.html#Fraction.negate","fn (Fraction)"],["vsl.vmath.fractions"," Fraction reciprocal method ","vsl.vmath.fractions.html#Fraction.reciprocal","fn (Fraction)"],["vsl.vmath.fractions"," Fraction method which reduces the fraction ","vsl.vmath.fractions.html#Fraction.reduce","fn (Fraction)"],["vsl.vmath.fractions"," f64 converts the Fraction to 64-bit floating point ","vsl.vmath.fractions.html#Fraction.f64","fn (Fraction)"],["vsl.vmath.fractions"," +-----------------------------+  | Public comparison functions |  +------------","vsl.vmath.fractions.html#Fraction.equals","fn (Fraction)"],["vsl.vmath.fractions"," ge returns true if f1 >= f2 ","vsl.vmath.fractions.html#Fraction.ge","fn (Fraction)"],["vsl.vmath.fractions"," gt returns true if f1 > f2 ","vsl.vmath.fractions.html#Fraction.gt","fn (Fraction)"],["vsl.vmath.fractions"," le returns true if f1 <= f2 ","vsl.vmath.fractions.html#Fraction.le","fn (Fraction)"],["vsl.vmath.fractions"," lt returns true if f1 < f2 ","vsl.vmath.fractions.html#Fraction.lt","fn (Fraction)"],["vsl.vmath.vimpl"," Returns the absolute value. ","vsl.vmath.vimpl.html#abs","fn "],["vsl.vmath.vimpl"," inf returns positive infinity if sign >= 0, negative infinity if sign < 0. ","vsl.vmath.vimpl.html#inf","fn "],["vsl.vmath.vimpl"," nan returns an IEEE 754 ``not-a-number'' value. ","vsl.vmath.vimpl.html#nan","fn "],["vsl.vmath.vimpl"," is_nan reports whether f is an IEEE 754 ``not-a-number'' value. ","vsl.vmath.vimpl.html#is_nan","fn "],["vsl.vmath.vimpl"," is_inf reports whether f is an infinity, according to sign.  If sign > 0, is_in","vsl.vmath.vimpl.html#is_inf","fn "],["vsl.vmath.vimpl","","vsl.vmath.vimpl.html#is_finite","fn "],["vsl.vmath.vimpl"," normalize returns a normal number y and exponent exp  satisfying x == y Ã— 2**e","vsl.vmath.vimpl.html#normalize","fn "],["vsl.vmath.vimpl"," cbrt returns the cube root of x.   special cases are:  cbrt(Â±0) = Â±0  cbrt(Â±","vsl.vmath.vimpl.html#cbrt","fn "],["vsl.vmath.vimpl"," data for a Chebyshev series over a given interval ","vsl.vmath.vimpl.html#ChebSeries","struct "],["vsl.vmath.vimpl"," digits returns an array of the digits of n in the given base. ","vsl.vmath.vimpl.html#digits","fn "],["vsl.vmath.vimpl"," Floating-point mod function.  mod returns the floating-point remainder of x/y. ","vsl.vmath.vimpl.html#mod","fn "],["vsl.vmath.vimpl","","vsl.vmath.vimpl.html#fmod","fn "],["vsl.vmath.vimpl"," gcd calculates greatest common (positive) divisor (or zero if a and b are both ","vsl.vmath.vimpl.html#gcd","fn "],["vsl.vmath.vimpl"," lcm calculates least common (non-negative) multiple. ","vsl.vmath.vimpl.html#lcm","fn "],["vsl.vmath.vimpl"," erf returns the error function of x.   special cases are:  erf(+inf) = 1  erf(-","vsl.vmath.vimpl.html#erf","fn "],["vsl.vmath.vimpl"," erfc returns the complementary error function of x.   special cases are:  erfc(","vsl.vmath.vimpl.html#erfc","fn "],["vsl.vmath.vimpl"," exp returns e**x, the base-e exponential of x.   special cases are:  exp(+inf) ","vsl.vmath.vimpl.html#exp","fn "],["vsl.vmath.vimpl"," exp2 returns 2**x, the base-2 exponential of x.   special cases are the same as","vsl.vmath.vimpl.html#exp2","fn "],["vsl.vmath.vimpl","","vsl.vmath.vimpl.html#ldexp","fn "],["vsl.vmath.vimpl"," frexp breaks f into a normalized fraction  and an integral power of two.  It re","vsl.vmath.vimpl.html#frexp","fn "],["vsl.vmath.vimpl"," special cases are:  expm1(+inf) = +inf  expm1(-inf) = -1  expm1(nan) = nan ","vsl.vmath.vimpl.html#expm1","fn "],["vsl.vmath.vimpl"," factorial calculates the factorial of the provided value. ","vsl.vmath.vimpl.html#factorial","fn "],["vsl.vmath.vimpl"," log_factorial calculates the log-factorial of the provided value. ","vsl.vmath.vimpl.html#log_factorial","fn "],["vsl.vmath.vimpl"," floor returns the greatest integer value less than or equal to x.   special cas","vsl.vmath.vimpl.html#floor","fn "],["vsl.vmath.vimpl"," ceil returns the least integer value greater than or equal to x.   special case","vsl.vmath.vimpl.html#ceil","fn "],["vsl.vmath.vimpl"," trunc returns the integer value of x.   special cases are:  trunc(Â±0) = Â±0  t","vsl.vmath.vimpl.html#trunc","fn "],["vsl.vmath.vimpl"," round returns the nearest integer, rounding half away from zero.   special case","vsl.vmath.vimpl.html#round","fn "],["vsl.vmath.vimpl"," round_to_even returns the nearest integer, rounding ties to even.   special cas","vsl.vmath.vimpl.html#round_to_even","fn "],["vsl.vmath.vimpl"," gamma returns the gamma function of x.   special ifs are:  gamma(+inf) = +inf  ","vsl.vmath.vimpl.html#gamma","fn "],["vsl.vmath.vimpl"," log_gamma returns the natural logarithm and sign (-1 or +1) of Gamma(x).   spec","vsl.vmath.vimpl.html#log_gamma","fn "],["vsl.vmath.vimpl","","vsl.vmath.vimpl.html#log_gamma_sign","fn "],["vsl.vmath.vimpl","","vsl.vmath.vimpl.html#hypot","fn "],["vsl.vmath.vimpl","","vsl.vmath.vimpl.html#acosh","fn "],["vsl.vmath.vimpl","","vsl.vmath.vimpl.html#asinh","fn "],["vsl.vmath.vimpl","","vsl.vmath.vimpl.html#atanh","fn "],["vsl.vmath.vimpl"," atan returns the arctangent, in radians, of x.   special cases are:  atan(Â±0) ","vsl.vmath.vimpl.html#atan","fn "],["vsl.vmath.vimpl"," atan2 returns the arc tangent of y/x, using  the signs of the two to determine ","vsl.vmath.vimpl.html#atan2","fn "],["vsl.vmath.vimpl"," asin returns the arcsine, in radians, of x.   special cases are:  asin(Â±0) = Â","vsl.vmath.vimpl.html#asin","fn "],["vsl.vmath.vimpl"," acos returns the arccosine, in radians, of x.   special case is:  acos(x) = nan","vsl.vmath.vimpl.html#acos","fn "],["vsl.vmath.vimpl","","vsl.vmath.vimpl.html#log","fn "],["vsl.vmath.vimpl","","vsl.vmath.vimpl.html#log_n","fn "],["vsl.vmath.vimpl"," log10 returns the decimal logarithm of x.  The special cases are the same as fo","vsl.vmath.vimpl.html#log10","fn "],["vsl.vmath.vimpl"," log2 returns the binary logarithm of x.  The special cases are the same as for ","vsl.vmath.vimpl.html#log2","fn "],["vsl.vmath.vimpl","","vsl.vmath.vimpl.html#log1p","fn "],["vsl.vmath.vimpl"," log_b returns the binary exponent of x.   special cases are:  log_b(Â±inf) = +i","vsl.vmath.vimpl.html#log_b","fn "],["vsl.vmath.vimpl"," ilog_b returns the binary exponent of x as an integer.   special cases are:  il","vsl.vmath.vimpl.html#ilog_b","fn "],["vsl.vmath.vimpl"," degrees convert from degrees to radians. ","vsl.vmath.vimpl.html#degrees","fn "],["vsl.vmath.vimpl"," radians convert from radians to degrees. ","vsl.vmath.vimpl.html#radians","fn "],["vsl.vmath.vimpl"," max returns the maximum value of the two provided. ","vsl.vmath.vimpl.html#max","fn "],["vsl.vmath.vimpl"," min returns the minimum value of the two provided. ","vsl.vmath.vimpl.html#min","fn "],["vsl.vmath.vimpl","","vsl.vmath.vimpl.html#minmax","fn "],["vsl.vmath.vimpl"," modf returns integer and fractional floating-point numbers  that sum to f. Both","vsl.vmath.vimpl.html#modf","fn "],["vsl.vmath.vimpl"," nextafter32 returns the next representable f32 value after x towards y.   speci","vsl.vmath.vimpl.html#nextafter32","fn "],["vsl.vmath.vimpl"," nextafter returns the next representable f64 value after x towards y.   special","vsl.vmath.vimpl.html#nextafter","fn "],["vsl.vmath.vimpl"," pow returns base raised to the provided power. ","vsl.vmath.vimpl.html#pow","fn "],["vsl.vmath.vimpl"," pow10 returns 10**n, the base-10 exponential of n.   special cases are:  pow10(","vsl.vmath.vimpl.html#pow10","fn "],["vsl.vmath.vimpl"," copysign returns a value with the magnitude of x and the sign of y ","vsl.vmath.vimpl.html#copysign","fn "],["vsl.vmath.vimpl"," signbit returns a value with the boolean representation of the sign for x ","vsl.vmath.vimpl.html#signbit","fn "],["vsl.vmath.vimpl","","vsl.vmath.vimpl.html#sin","fn "],["vsl.vmath.vimpl","","vsl.vmath.vimpl.html#cos","fn "],["vsl.vmath.vimpl","","vsl.vmath.vimpl.html#sincos","fn "],["vsl.vmath.vimpl"," sinh calculates hyperbolic sine. ","vsl.vmath.vimpl.html#sinh","fn "],["vsl.vmath.vimpl"," cosh returns the hyperbolic cosine of x.   special cases are:  cosh(Â±0) = 1  c","vsl.vmath.vimpl.html#cosh","fn "],["vsl.vmath.vimpl"," special cases are:  sqrt(+inf) = +inf  sqrt(Â±0) = Â±0  sqrt(x < 0) = nan  sqrt","vsl.vmath.vimpl.html#sqrt","fn "],["vsl.vmath.vimpl","","vsl.vmath.vimpl.html#tan","fn "],["vsl.vmath.vimpl","","vsl.vmath.vimpl.html#cot","fn "],["vsl.vmath.vimpl"," tanh returns the hyperbolic tangent of x.   special cases are:  tanh(Â±0) = Â±0","vsl.vmath.vimpl.html#tanh","fn "],["vsl.vmath.vimpl"," f32_bits returns the IEEE 754 binary representation of f,  with the sign bit of","vsl.vmath.vimpl.html#f32_bits","fn "],["vsl.vmath.vimpl"," f32_from_bits returns the floating-point number corresponding  to the IEEE 754 ","vsl.vmath.vimpl.html#f32_from_bits","fn "],["vsl.vmath.vimpl"," f64_bits returns the IEEE 754 binary representation of f,  with the sign bit of","vsl.vmath.vimpl.html#f64_bits","fn "],["vsl.vmath.vimpl"," f64_from_bits returns the floating-point number corresponding  to the IEEE 754 ","vsl.vmath.vimpl.html#f64_from_bits","fn "],];
