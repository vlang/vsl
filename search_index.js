var searchModuleIndex = [
"README",
"blas",
"blas.blas64",
"consts",
"deriv",
"diff",
"dist",
"easings",
"errors",
"fft",
"fit",
"float.float32",
"float.float64",
"fun",
"func",
"gm",
"graph",
"inout.h5",
"internal.prec",
"iter",
"la",
"lapack",
"lapack.lapack64",
"ml",
"ml.nlp",
"mpi",
"noise",
"plot",
"poly",
"prime",
"quaternion",
"roots",
"util",
"vcl",
"vcl.internal.dl",
];

var searchIndex = [
"cm_ddot",
"cm_dscal",
"cm_daxpy",
"cm_dgemv",
"cm_dgemm",
"cm_dsyrk",
"cm_dtrsm",
"MemoryLayout",
"Transpose",
"Uplo",
"Diagonal",
"Side",
"slice_to_col_major",
"col_major_to_slice",
"print_col_major",
"print_col_major_v",
"print_col_major_py",
"slice_to_col_major_complex",
"col_major_complex_to_slice",
"print_col_major_complex",
"print_col_major_complex_v",
"print_col_major_omplex_py",
"get_join_complex",
"get_split_complex",
"join_complex",
"split_complex",
"extract_row",
"extract_col",
"extract_row_complex",
"extract_col_complex",
"eigenvecs_build",
"eigenvecs_build_both",
"to_blas64_layout",
"from_blas64_layout",
"to_blas64_transpose",
"from_blas64_transpose",
"to_blas64_uplo",
"from_blas64_uplo",
"to_blas64_diagonal",
"from_blas64_diagonal",
"to_blas64_side",
"from_blas64_side",
"set_num_threads",
"ddot",
"dasum",
"dnrm2",
"daxpy",
"dcopy",
"dswap",
"drot",
"dscal",
"idamax",
"dgemv",
"dger",
"dtrsv",
"dtrmv",
"dsyr",
"dsyr2",
"dgemm",
"dgbmv",
"dsymv",
"dsbmv",
"dtbmv",
"dtbsv",
"dtpmv",
"dtpsv",
"dspmv",
"dspr",
"dspr2",
"dsyrk",
"dsyr2k",
"dtrmm",
"dtrsm",
"cm_ddot",
"cm_dscal",
"cm_daxpy",
"cm_dgemv",
"cm_dgemm",
"cm_dsyrk",
"cm_dtrsm",
"MemoryLayout",
"Transpose",
"Uplo",
"Diagonal",
"Side",
"dgemm",
"dgemv",
"dnrm2",
"dasum",
"idamax",
"dswap",
"dcopy",
"daxpy",
"drotg",
"drot",
"dscal",
"ddot",
"dger",
"dgbmv",
"dtrmv",
"dtrsv",
"dsymv",
"dtbmv",
"dtpmv",
"dtbsv",
"dsbmv",
"dsyr",
"dsyr2",
"dtpsv",
"dspmv",
"dspr",
"dspr2",
"dsyrk",
"dsyr2k",
"dtrmm",
"dtrsm",
"central",
"forward",
"backward",
"partial",
"backward",
"forward",
"central",
"text_hist",
"build_text_hist",
"Histogram",
"find_bin",
"count",
"gen_labels",
"density_area",
"Histogram.new",
"EasingFn",
"linear_interpolation",
"quadratic_ease_in",
"quadratic_ease_out",
"quadratic_ease_in_out",
"cubic_ease_in",
"cubic_ease_out",
"cubic_ease_in_out",
"quartic_ease_in",
"quartic_ease_out",
"quartic_ease_in_out",
"quintic_ease_in",
"quintic_ease_out",
"quintic_ease_in_out",
"sine_ease_in",
"sine_ease_out",
"sine_ease_in_out",
"circular_ease_in",
"circular_ease_out",
"circular_ease_in_out",
"exponential_ease_in",
"exponential_ease_out",
"exponential_ease_in_out",
"elastic_ease_in",
"elastic_ease_out",
"elastic_ease_in_out",
"back_ease_in",
"back_ease_out",
"back_ease_in_out",
"bounce_ease_in",
"bounce_ease_out",
"bounce_ease_in_out",
"animate",
"ErrorCode",
"str",
"error",
"vsl_panic",
"error_message",
"create_plan",
"forward_fft",
"backward_fft",
"linear",
"linear_sigma",
"axpy_unitary",
"axpy_unitary_to",
"axpy_inc",
"axpy_inc_to",
"dot_unitary",
"dot_inc",
"arrays_tolerance",
"ger",
"gemv_n",
"gemv_t",
"l2_norm_unitary",
"l2_norm_inc",
"l2_distance_unitary",
"scal_unitary",
"scal_unitary_to",
"scal_inc",
"scal_inc_to",
"axpy_unitary",
"axpy_unitary_to",
"axpy_inc",
"axpy_inc_to",
"dot_unitary",
"dot_inc",
"IncSet.new",
"IncToSet.new",
"same",
"tolerance",
"arrays_tolerance",
"close",
"veryclose",
"soclose",
"alike",
"new_guarded_vector",
"all_nan",
"equal_strided",
"non_strided_write",
"guard_vector",
"is_valid_guard",
"guard_inc_vector",
"is_valid_inc_guard",
"random_slice",
"ger",
"gemv_n",
"gemv_t",
"l2_norm_unitary",
"l2_norm_inc",
"l2_distance_unitary",
"scal_unitary",
"scal_unitary_to",
"scal_inc",
"scal_inc_to",
"bessel_j0",
"bessel_j1",
"bessel_jn",
"bessel_y0",
"bessel_y1",
"bessel_yn",
"pzero",
"pone",
"qzero",
"qone",
"cgamma",
"clog_gamma",
"ChebSeries",
"eval_e",
"choose",
"InterpFn",
"DataInterp",
"reset",
"p",
"locate",
"hunt",
"DataInterp.new",
"lin_interp",
"poly_interp",
"digamma",
"psi",
"erf",
"erfc",
"fib",
"beta",
"binomial",
"uint_binomial",
"rbinomial",
"n_combos_w_replacement",
"suqcos",
"suqsin",
"atan2p",
"atan2pdeg",
"ramp",
"heav",
"sign",
"boxcar",
"rect",
"hat",
"hatd1",
"sramp",
"srampd1",
"srampd2",
"logistic",
"logistic_d1",
"sabs",
"sabs_d1",
"sabs_d2",
"exp_pix",
"exp_mix",
"sinc",
"neg_one_pow_n",
"imag_pow_n",
"imag_x_pow_n",
"powp",
"pow2",
"pow3",
"gamma",
"log_gamma",
"log_gamma_sign",
"hypot",
"hypot_e",
"InterpCubic",
"f",
"g",
"critical",
"fit_4points",
"fit_3points_d",
"InterpCubic.new",
"InterpQuad",
"f",
"g",
"optimum",
"fit_3points",
"fit_2points_d",
"InterpQuad.new",
"bessel_i0",
"bessel_i1",
"bessel_in",
"bessel_k0",
"bessel_k1",
"bessel_kn",
"Sinusoid",
"yessen",
"ybasis",
"approx_square_fourier",
"test_periodicity",
"Sinusoid.essential",
"Sinusoid.basis",
"sin_e",
"cos_e",
"sin",
"cos",
"ArbitraryFn",
"DfFn",
"FdfFn",
"VectorValuedFn",
"Fn",
"eval",
"safe_eval",
"Fn.new",
"FnFdf",
"eval_f",
"eval_df",
"eval_f_df",
"FnFdf.new",
"FnVec",
"eval",
"FnVec.new",
"Point",
"clone",
"disp",
"str",
"Segment",
"len",
"scaled",
"vector",
"str",
"Point.new",
"dist_point_point",
"Segment.new",
"vector_dot",
"vector_norm",
"vector_new",
"vector_add",
"dist_point_line",
"points_lims",
"is_point_in",
"is_point_in_line",
"BinEntry",
"Bin",
"str",
"Bins",
"append",
"clear",
"find_bin_by_index",
"calc_index",
"find_closest",
"find_closest_and_append",
"find_along_segment",
"get_limits",
"nactive",
"nentries",
"summary",
"str",
"Bins.new",
"PointsDiffFn",
"ShortestPaths",
"Graph",
"nverts",
"get_edge",
"shortest_paths",
"path",
"calc_dist",
"str_dist_matrix",
"get_adj",
"Graph.new",
"Hdf5File",
"write_dataset1d",
"write_dataset2d",
"write_dataset3d",
"write_attribute1d",
"write_attribute",
"read_dataset1d",
"read_dataset2d",
"read_dataset3d",
"read_attribute",
"read_attribute1d",
"close",
"Hdf5File.new",
"open_file",
"combinations",
"CombinationsIter",
"next",
"CombinationsIter.new",
"combinations_with_replacement",
"CombinationsWithReplacementIter",
"next",
"CombinationsWithReplacementIter.new",
"Counter",
"next",
"Counter.new",
"Cycler",
"next",
"Cycler.new",
"Repeater",
"next",
"Repeater.new",
"PermutationsIter",
"next",
"PermutationsIter.new",
"permutations",
"ProductIterator",
"next",
"ProductIterator.new",
"product",
"IntIterParams",
"IntIter.new",
"IntIter",
"next",
"FloatIterParams",
"FloatIter.new",
"FloatIter",
"next",
"LinearIterParams",
"LinearIter.new",
"LinearIter",
"next",
"LogIterParams",
"LogIter.new",
"LogIter",
"next",
"vector_rms_error",
"vector_dot",
"vector_add",
"vector_max_diff",
"vector_scale_abs",
"matrix_vector_mul",
"matrix_tr_vector_mul",
"vector_vector_tr_mul",
"matrix_vector_mul_add",
"matrix_matrix_mul",
"matrix_tr_matrix_mul",
"matrix_matrix_tr_mul",
"matrix_tr_matrix_tr_mul",
"matrix_matrix_muladd",
"matrix_tr_matrix_muladd",
"matrix_matrix_tr_muladd",
"matrix_tr_matrix_tr_mul_add",
"matrix_add",
"den_solve",
"jacobi",
"Matrix",
"Matrix.new",
"Matrix.deep2",
"Matrix.raw",
"Matrix[T]",
"set_from_deep2",
"set_diag",
"set",
"get",
"get_deep2",
"clone",
"transpose",
"copy_into",
"add",
"fill",
"clear_rc",
"clear_bry",
"max_diff",
"largest",
"col",
"get_row",
"get_col",
"extract_cols",
"extract_rows",
"set_row",
"set_col",
"split_by_col",
"split_by_row",
"norm_frob",
"norm_inf",
"apply",
"equals",
"str",
"print",
"print_v",
"print_py",
"safe_print",
"matrix_det",
"matrix_inv_small",
"matrix_svd",
"matrix_inv",
"matrix_cond_num",
"SparseConfig",
"set_mumps_symmetry",
"set_umfpack_symmetry",
"set_mumps_ordering",
"set_mumps_scaling",
"SparseConfig.new",
"SparseConfig.with_comm",
"Triplet",
"CCMatrix",
"Triplet.new",
"Triplet[T]",
"init",
"put",
"put_matrix_and_matrix_t",
"put_cc_matrix_and_matrix_t",
"start",
"len",
"max",
"size",
"to_dense",
"vector_apply",
"vector_apply_func",
"vector_unit",
"vector_accum",
"vector_norm",
"vector_rms",
"vector_norm_diff",
"vector_largest",
"Direct",
"Sort",
"StoreV",
"MatrixNorm",
"MatrixType",
"Pivot",
"ApplyOrtho",
"GenOrtho",
"SVDJob",
"GSVDJob",
"EigenVectorsComp",
"EigenVectorsJob",
"LeftEigenVectorsJob",
"RightEigenVectorsJob",
"BalanceJob",
"SchurJob",
"SchurComp",
"UpdateSchurComp",
"EigenVectorsSide",
"EigenVectorsHowMany",
"MaximizeNormXJob",
"OrthoComp",
"to_lapack64_direct",
"from_lapack64_direct",
"to_lapack64_sort",
"from_lapack64_sort",
"to_lapack64_storev",
"from_lapack64_storev",
"to_lapack64_matrix_norm",
"from_lapack64_matrix_norm",
"to_lapack64_matrix_type",
"from_lapack64_matrix_type",
"to_lapack64_pivot",
"from_lapack64_pivot",
"to_lapack64_apply_ortho",
"from_lapack64_apply_ortho",
"to_lapack64_gen_ortho",
"from_lapack64_gen_ortho",
"to_lapack64_svd_job",
"from_lapack64_svd_job",
"to_lapack64_gsvd_job",
"from_lapack64_gsvd_job",
"to_lapack64_eigen_vectors_comp",
"from_lapack64_eigen_vectors_comp",
"to_lapack64_eigen_vectors_job",
"from_lapack64_eigen_vectors_job",
"to_lapack64_left_eigen_vectors_job",
"from_lapack64_left_eigen_vectors_job",
"to_lapack64_right_eigen_vectors_job",
"from_lapack64_right_eigen_vectors_job",
"to_lapack64_balance_job",
"from_lapack64_balance_job",
"to_lapack64_schur_job",
"from_lapack64_schur_job",
"to_lapack64_schur_comp",
"from_lapack64_schur_comp",
"to_lapack64_update_schur_comp",
"from_lapack64_update_schur_comp",
"to_lapack64_eigen_vectors_side",
"from_lapack64_eigen_vectors_side",
"to_lapack64_eigen_vectors_how_many",
"from_lapack64_eigen_vectors_how_many",
"to_lapack64_maximize_norm_x_job",
"from_lapack64_maximize_norm_x_job",
"to_lapack64_ortho_comp",
"from_lapack64_ortho_comp",
"dgesv",
"dgesvd",
"dgetrf",
"dgetri",
"dpotrf",
"dgeev",
"dpotrf_standardized",
"dsyev_standardized",
"dgeev_standardized",
"dgeqrf_standardized",
"dorgqr_standardized",
"dsyev",
"dgeqrf",
"dorgqr",
"gesv",
"getrf",
"getri",
"potrf",
"geqrf",
"orgqr",
"geev",
"syev",
"gesvd",
"dlange",
"Direct",
"Sort",
"StoreV",
"MatrixNorm",
"MatrixType",
"Pivot",
"ApplyOrtho",
"GenOrtho",
"SVDJob",
"GSVDJob",
"EigenVectorsComp",
"EigenVectorsJob",
"LeftEigenVectorsJob",
"RightEigenVectorsJob",
"BalanceJob",
"SchurJob",
"SchurComp",
"UpdateSchurComp",
"EigenVectorsSide",
"EigenVectorsHowMany",
"MaximizeNormXJob",
"OrthoComp",
"dgebal",
"dgeev",
"dgehrd",
"dgeqr2",
"dgeqrf",
"dgesv",
"dgesvd",
"dgetf2",
"dgetrf",
"dgetri",
"dgetrs",
"dlacpy",
"dlae2",
"dlaev2",
"dlange",
"dlanst",
"dlansy",
"dlapy2",
"dlarf",
"dlarfb",
"dlarfg",
"dlarft",
"dlartg",
"dlascl",
"dlaset",
"dlasr",
"dlasrt",
"dlassq",
"dlaswp",
"dlatrd",
"dorg2l",
"dorg2r",
"dorgql",
"dorgqr",
"dorgtr",
"dpotf2",
"dpotrf",
"dsteqr",
"dsterf",
"dsyev",
"dsytd2",
"dsytrd",
"dtrti2",
"dtrtri",
"iladlc",
"iladlr",
"Data",
"Data.new",
"Data[T]",
"set",
"set_y",
"set_x",
"clone",
"clone_with_same_x",
"add_observer",
"notify_update",
"split",
"Data.from_raw_x",
"Data.from_raw_xy_sep",
"Data.from_raw_xy",
"Kmeans",
"name",
"update",
"nb_classes",
"set_centroids",
"find_closest_centroids",
"compute_centroids",
"train",
"str",
"get_plotter",
"Kmeans.new",
"TrainConfig",
"KNN",
"name",
"set_weights",
"update",
"train",
"predict",
"str",
"get_plotter",
"KNN.new",
"PredictConfig",
"LinReg",
"name",
"predict",
"cost",
"gradients",
"train",
"calce",
"str",
"get_plotter",
"LinReg.new",
"ParamsReg",
"ParamsReg.new",
"ParamsReg[T]",
"init",
"backup",
"restore",
"set_params",
"set_param",
"get_param",
"set_thetas",
"get_thetas",
"access_thetas",
"access_bias",
"set_theta",
"get_theta",
"set_bias",
"get_bias",
"set_lambda",
"get_lambda",
"set_degree",
"get_degree",
"add_observer",
"notify_update",
"Stat",
"Stat.from_data",
"Stat[T]",
"name",
"update",
"sum_vars",
"copy_into",
"str",
"most_frequent_ngrams",
"count_vectorize",
"LancasterStemmer",
"set_rules",
"stem",
"LancasterStemmer.new",
"term_frequencies",
"inverse_document_frequencies",
"term_idf",
"tf_idf",
"remove_punctuation",
"tokenize",
"remove_stopwords",
"remove_stopwords_en",
"ngrams",
"is_on",
"initialize",
"initialise",
"start_thread_safe",
"finalize",
"world_rank",
"world_size",
"Communicator",
"rank",
"size",
"abort",
"barrier",
"send_i32",
"recv_i32",
"send_u32",
"recv_u32",
"send_i64",
"recv_i64",
"send_u64",
"recv_u64",
"send_f32",
"recv_f32",
"send_f64",
"recv_f64",
"send_one_i32",
"recv_one_i32",
"send_one_u32",
"recv_one_u32",
"send_one_i64",
"recv_one_i64",
"send_one_u64",
"recv_one_u64",
"send_one_f32",
"recv_one_f32",
"send_one_f64",
"recv_one_f64",
"bcast_from_root_i32",
"bcast_from_root_u32",
"bcast_from_root_i64",
"bcast_from_root_u64",
"bcast_from_root_f32",
"bcast_from_root_f64",
"reduce_sum_i32",
"all_reduce_sum_i32",
"reduce_min_i32",
"all_reduce_min_i32",
"reduce_max_i32",
"all_reduce_max_i32",
"reduce_sum_u32",
"all_reduce_sum_u32",
"reduce_min_u32",
"all_reduce_min_u32",
"reduce_max_u32",
"all_reduce_max_u32",
"reduce_sum_i64",
"all_reduce_sum_i64",
"reduce_min_i64",
"all_reduce_min_i64",
"reduce_max_i64",
"all_reduce_max_i64",
"reduce_sum_u64",
"all_reduce_sum_u64",
"reduce_min_u64",
"all_reduce_min_u64",
"reduce_max_u64",
"all_reduce_max_u64",
"reduce_sum_f32",
"all_reduce_sum_f32",
"reduce_min_f32",
"all_reduce_min_f32",
"reduce_max_f32",
"all_reduce_max_f32",
"reduce_sum_f64",
"all_reduce_sum_f64",
"reduce_min_f64",
"all_reduce_min_f64",
"reduce_max_f64",
"all_reduce_max_f64",
"Communicator.new",
"Generator",
"perlin2d",
"perlin3d",
"randomize",
"simplex_1d",
"simplex_2d",
"simplex_3d",
"simplex_4d",
"Generator.new",
"Annotation",
"Axis",
"AxisTitle",
"RangeSlider",
"Font",
"Layout",
"Polar",
"RadialAxis",
"AngularAxis",
"Geo",
"GeoProjection",
"GeoRotation",
"GeoCenter",
"Mapbox",
"MapboxCenter",
"Light",
"Plot",
"annotation",
"bar",
"box",
"candlestick",
"chord",
"choropleth",
"contour",
"debug_json",
"density",
"densitymapbox",
"funnel",
"get_plotly_script",
"heatmap",
"histogram",
"histogram2d",
"layout",
"layout_json",
"line",
"network",
"parcoords",
"pie",
"ridgeline",
"sankey",
"scatter",
"scatter3d",
"scattermapbox",
"scatterpolar",
"show",
"sunburst",
"surface",
"to_json",
"traces_json",
"treemap",
"violin",
"waterfall",
"Plot.new",
"PlotConfig",
"PlotlyScriptConfig",
"TraceType",
"XType",
"YType",
"ZType",
"CommonTrace",
"ScatterTrace",
"PieTrace",
"HeatmapTrace",
"SurfaceTrace",
"Scatter3DTrace",
"BarTrace",
"HistogramTrace",
"LineTrace",
"BoxTrace",
"ViolinTrace",
"ContourTrace",
"WaterfallTrace",
"SunburstTrace",
"TreemapTrace",
"CandlestickTrace",
"FunnelTrace",
"ScatterPolarTrace",
"Marker",
"Line",
"Bins",
"Box",
"Contours",
"Connector",
"Decreasing",
"Increasing",
"Totals",
"PathBar",
"Trace",
"trace_type",
"Dimension",
"ParallelLine",
"SankeyNode",
"SankeyLink",
"NetworkNodes",
"NetworkEdges",
"Cluster",
"Histogram2DTrace",
"DensityTrace",
"RidgelineTrace",
"ParallelCoordinatesTrace",
"SankeyTrace",
"ChordTrace",
"NetworkTrace",
"ChoroplethTrace",
"ScatterMapboxTrace",
"DensityMapboxTrace",
"eval",
"eval_derivs",
"solve_quadratic",
"solve_cubic",
"companion_matrix",
"balance_companion_matrix",
"add",
"subtract",
"multiply",
"divide",
"is_prime",
"prime_sieve",
"Quaternion",
"*",
"+",
"-",
"/",
"abs",
"add",
"angle",
"conjugate",
"copy",
"divide",
"equal",
"exp",
"inverse",
"is_finite",
"is_greater",
"is_greaterequal",
"is_inf",
"is_less",
"is_lessequal",
"is_nan",
"is_zero",
"lerp",
"log",
"multiply",
"nlerp",
"norm",
"normalized",
"opposite",
"parity_antisymmetric_part",
"parity_conjugate",
"parity_symmetric_part",
"pow",
"rotation_chordal_distance",
"rotation_intrinsic_distance",
"rotor_chordal_distance",
"rotor_intrinsic_distance",
"scalar_add",
"scalar_divide",
"scalar_multiply",
"scalar_pow",
"scalar_subtract",
"slerp",
"sqrt",
"squad",
"str",
"subtract",
"x_parity_antisymmetric_part",
"x_parity_conjugate",
"x_parity_symmetric_part",
"y_parity_antisymmetric_part",
"y_parity_conjugate",
"y_parity_symmetric_part",
"z_parity_antisymmetric_part",
"z_parity_conjugate",
"z_parity_symmetric_part",
"quaternion",
"id",
"from_axis_anglef3",
"from_spherical_coords",
"from_euler_angles",
"Bisection",
"next",
"solve",
"BisectionParams",
"Bisection.new",
"BisectionIteration",
"Brent",
"Brent.new",
"BrentIteration",
"newton",
"newton_bisection",
"int_ints_map_append",
"str_ints_map_append",
"str_flts_map_append",
"Observer",
"Observable",
"add_observer",
"notify_update",
"arange",
"RangeStep",
"range",
"get_many",
"lin_space",
"move_ith_to_end",
"ImageChannelOrder",
"ImageChannelDataType",
"Bytes",
"size",
"release",
"load",
"data",
"map",
"buffer",
"Device",
"add_program",
"bytes",
"driver_version",
"extensions",
"from_image",
"image",
"kernel",
"name",
"open_clc_version",
"profile",
"release",
"str",
"vector",
"vendor",
"version",
"DeviceType",
"ErrVCL",
"err",
"error_from_code",
"error_or_default",
"typed_error",
"vcl_error",
"panic_on_error",
"Rect",
"IImage",
"Image",
"release",
"data",
"ArgumentType",
"UnsupportedArgumentTypeError",
"msg",
"Kernel",
"global",
"KernelWithGlobal",
"local",
"KernelCall",
"run",
"get_devices",
"get_default_device",
"Vector",
"Vector[T]",
"length",
"release",
"load",
"data",
"map",
"buffer",
"get_sym",
];

var searchModuleData = [
["<div align=\"center\"> <p> <img style=\"width: 200px\" width=\"200\" src=\"https","index.html"],
["This package implements Basic Linear Algebra System (BLAS) routines in V.","blas.html"],
["","blas.blas64.html"],
["This module provides a collection of physical constants in the MKSA system.","consts.html"],
["This module provides functions for computing numerical derivatives of functions.","deriv.html"],
["This module equips you with powerful functions for calculating numerical derivat","diff.html"],
["This module provides functions for computing probability distributions.","dist.html"],
["This is a pure V module that provides easing functions calculation.","easings.html"],
["","errors.html"],
["The `fft` package is a wrapper of the C language version of [PocketFFT](https://","fft.html"],
["","fit.html"],
["","float.float32.html"],
["","float.float64.html"],
["The `vsl.fun` module provides a comprehensive collection of special mathematical","fun.html"],
["","func.html"],
["This package provides some functions to help with the solution of geometry probl","gm.html"],
["This package implements algorithms for handling graphs and solving problems such","graph.html"],
["The functions described in this chapter will read or write data to a file in the","inout.h5.html"],
["","internal.prec.html"],
["This module provides two different ways of managing combinatorics. Let see an ex","iter.html"],
["The `vsl.la` module provides comprehensive linear algebra operations for scienti","la.html"],
["This package implements Linear Algebra routines in V.","lapack.html"],
["","lapack.lapack64.html"],
["VSL aims to provide a robust set of tools for scientific computing with an empha","ml.html"],
["This submodule offers tools for Natural Language Processing.","ml.nlp.html"],
["The `mpi` package is a simplified wrapper to the [OpenMPI](https://www.open-mpi.","mpi.html"],
["This module aims to to implement noise algorithms.","noise.html"],
["This library implements high-level plotting functions for scientific data visual","plot.html"],
["This chapter describes functions for evaluating and solving polynomials. There a","poly.html"],
["","prime.html"],
["The functions provided by this module add support for quaternions. The algorithm","quaternion.html"],
["The module `vsl.roots` contains functions for the root finding methods and relat","roots.html"],
["","util.html"],
["VCL is a high-level, V-native interface for GPU computing with OpenCL. It provid","vcl.html"],
["","vcl.internal.dl.html"],
];

var searchData = [
["blas","","blas.html#cm_ddot","fn "],
["blas","","blas.html#cm_dscal","fn "],
["blas","","blas.html#cm_daxpy","fn "],
["blas","","blas.html#cm_dgemv","fn "],
["blas","","blas.html#cm_dgemm","fn "],
["blas","","blas.html#cm_dsyrk","fn "],
["blas","","blas.html#cm_dtrsm","fn "],
["blas","MemoryLayout is used to specify the memory layout of a matrix.","blas.html#MemoryLayout","enum "],
["blas","Transpose is used to specify the transposition of a matrix.","blas.html#Transpose","enum "],
["blas","Uplo is used to specify whether the upper or lower triangle of a matrix is","blas.html#Uplo","enum "],
["blas","Diagonal is used to specify whether the diagonal of a matrix is unit or non-unit","blas.html#Diagonal","enum "],
["blas","Side is used to specify whether a matrix is on the left or right side in a matri","blas.html#Side","enum "],
["blas","slice_to_col_major converts nested slice into an array representing a col-major ","blas.html#slice_to_col_major","fn "],
["blas","col_major_to_slice converts col-major matrix to nested slice","blas.html#col_major_to_slice","fn "],
["blas","print_col_major prints matrix (without commas or brackets)","blas.html#print_col_major","fn "],
["blas","print_col_major_v prints matrix in v format","blas.html#print_col_major_v","fn "],
["blas","print_col_major_py prints matrix in Python format","blas.html#print_col_major_py","fn "],
["blas","slice_to_col_major_complex converts nested slice into an array representing a co","blas.html#slice_to_col_major_complex","fn "],
["blas","col_major_complex_to_slice converts col-major matrix to nested slice","blas.html#col_major_complex_to_slice","fn "],
["blas","print_col_major_complex prints matrix (without commas or brackets). _**NOTE**: i","blas.html#print_col_major_complex","fn "],
["blas","print_col_major_complex_v prints matrix in v format _**NOTE**: if non-empty, nfm","blas.html#print_col_major_complex_v","fn "],
["blas","print_col_major_omplex_py prints matrix in Python format _**NOTE**: if non-empty","blas.html#print_col_major_omplex_py","fn "],
["blas","get_join_complex joins real and imag parts of array","blas.html#get_join_complex","fn "],
["blas","get_split_complex splits real and imag parts of array","blas.html#get_split_complex","fn "],
["blas","join_complex joins real and imag parts of array","blas.html#join_complex","fn "],
["blas","split_complex splits real and imag parts of array","blas.html#split_complex","fn "],
["blas","extract_row extracts i row from (m,n) col-major matrix","blas.html#extract_row","fn "],
["blas","extract_col extracts j column from (m,n) col-major matrix","blas.html#extract_col","fn "],
["blas","extract_row_complex extracts i row from (m,n) col-major matrix (complex version)","blas.html#extract_row_complex","fn "],
["blas","extract_col_complex extracts j column from (m,n) col-major matrix (complex versi","blas.html#extract_col_complex","fn "],
["blas","eigenvecs_build builds complex eigenvectros created by Dgeev function","blas.html#eigenvecs_build","fn "],
["blas","eigenvecs_build_both builds complex left and right eigenvectros created by Dgeev","blas.html#eigenvecs_build_both","fn "],
["blas","Convert VSL MemoryLayout to blas64.MemoryLayout","blas.html#to_blas64_layout","fn "],
["blas","Convert blas64.MemoryLayout to VSL MemoryLayout","blas.html#from_blas64_layout","fn "],
["blas","Convert VSL Transpose to blas64.Transpose","blas.html#to_blas64_transpose","fn "],
["blas","Convert blas64.Transpose to VSL Transpose","blas.html#from_blas64_transpose","fn "],
["blas","Convert VSL Uplo to blas64.Uplo","blas.html#to_blas64_uplo","fn "],
["blas","Convert blas64.Uplo to VSL Uplo","blas.html#from_blas64_uplo","fn "],
["blas","Convert VSL Diagonal to blas64.Diagonal","blas.html#to_blas64_diagonal","fn "],
["blas","Convert blas64.Diagonal to VSL Diagonal","blas.html#from_blas64_diagonal","fn "],
["blas","Convert VSL Side to blas64.Side","blas.html#to_blas64_side","fn "],
["blas","Convert blas64.Side to VSL Side","blas.html#from_blas64_side","fn "],
["blas","set_num_threads sets the number of threads in BLAS","blas.html#set_num_threads","fn "],
["blas","ddot computes the dot product of two vectors.","blas.html#ddot","fn "],
["blas","dasum computes the sum of the absolute values of elements in a vector.","blas.html#dasum","fn "],
["blas","dnrm2 computes the Euclidean norm of a vector.","blas.html#dnrm2","fn "],
["blas","daxpy computes y := alpha * x + y.","blas.html#daxpy","fn "],
["blas","dcopy copies a vector x to a vector y.","blas.html#dcopy","fn "],
["blas","dswap swaps the elements of two vectors.","blas.html#dswap","fn "],
["blas","drot applies a plane rotation to points in the plane.","blas.html#drot","fn "],
["blas","dscal scales a vector by a constant.","blas.html#dscal","fn "],
["blas","idamax finds the index of the element with the maximum absolute value.","blas.html#idamax","fn "],
["blas","dgemv performs matrix-vector multiplication. Input matrices are expected in row-","blas.html#dgemv","fn "],
["blas","dger performs the rank-1 update of a matrix. Input matrix is expected in row-maj","blas.html#dger","fn "],
["blas","dtrsv solves a system of linear equations with a triangular matrix.","blas.html#dtrsv","fn "],
["blas","dtrmv performs matrix-vector operations using a triangular matrix.","blas.html#dtrmv","fn "],
["blas","dsyr performs a symmetric rank-1 update of a matrix.","blas.html#dsyr","fn "],
["blas","dsyr2 performs a symmetric rank-2 update of a matrix.","blas.html#dsyr2","fn "],
["blas","dgemm performs matrix-matrix multiplication. Input matrices are expected in row-","blas.html#dgemm","fn "],
["blas","dgbmv performs a matrix-vector multiplication with a band matrix.","blas.html#dgbmv","fn "],
["blas","dsymv performs a matrix-vector multiplication for a symmetric matrix.","blas.html#dsymv","fn "],
["blas","dsbmv performs a matrix-vector multiplication with a symmetric band matrix.","blas.html#dsbmv","fn "],
["blas","dtbmv performs a matrix-vector multiplication with a triangular band matrix.","blas.html#dtbmv","fn "],
["blas","dtbsv solves a system of linear equations with a triangular band matrix.","blas.html#dtbsv","fn "],
["blas","dtpmv performs a matrix-vector multiplication with a triangular packed matrix.","blas.html#dtpmv","fn "],
["blas","dtpsv solves a system of linear equations with a triangular packed matrix.","blas.html#dtpsv","fn "],
["blas","dspmv performs a matrix-vector multiplication with a symmetric packed matrix.","blas.html#dspmv","fn "],
["blas","dspr performs a symmetric rank-1 update for a packed matrix.","blas.html#dspr","fn "],
["blas","dspr2 performs a symmetric rank-2 update for a packed matrix.","blas.html#dspr2","fn "],
["blas","dsyrk performs a symmetric rank-k update.","blas.html#dsyrk","fn "],
["blas","dsyr2k performs a symmetric rank-2k update.","blas.html#dsyr2k","fn "],
["blas","dtrmm performs triangular matrix multiplication. Input matrices are expected in ","blas.html#dtrmm","fn "],
["blas","dtrsm solves triangular system of equations with multiple right-hand sides.","blas.html#dtrsm","fn "],
["blas.blas64","Column-major minimal BLAS subset used by lapack64","blas.blas64.html#cm_ddot","fn "],
["blas.blas64","","blas.blas64.html#cm_dscal","fn "],
["blas.blas64","","blas.blas64.html#cm_daxpy","fn "],
["blas.blas64","","blas.blas64.html#cm_dgemv","fn "],
["blas.blas64","","blas.blas64.html#cm_dgemm","fn "],
["blas.blas64","","blas.blas64.html#cm_dsyrk","fn "],
["blas.blas64","","blas.blas64.html#cm_dtrsm","fn "],
["blas.blas64","MemoryLayout is used to specify the memory layout of a matrix.","blas.blas64.html#MemoryLayout","enum "],
["blas.blas64","Transpose is used to specify the transposition of a matrix.","blas.blas64.html#Transpose","enum "],
["blas.blas64","Uplo is used to specify whether the upper or lower triangle of a matrix is","blas.blas64.html#Uplo","enum "],
["blas.blas64","Diagonal is used to specify whether the diagonal of a matrix is unit or non-unit","blas.blas64.html#Diagonal","enum "],
["blas.blas64","Side is used to specify whether a matrix is on the left or right side in a matri","blas.blas64.html#Side","enum "],
["blas.blas64","dgemm performs one of the matrix-matrix operations C = alpha * A * B + beta * C ","blas.blas64.html#dgemm","fn "],
["blas.blas64","dgemv computes y = alpha * A * x + beta * y   if trans_a = .no_trans y = alpha *","blas.blas64.html#dgemv","fn "],
["blas.blas64","dnrm2 computes the Euclidean norm of a vector, sqrt(\sum_i x[i] * x[i]). This fu","blas.blas64.html#dnrm2","fn "],
["blas.blas64","dasum computes the sum of the absolute values of the elements of x. \sum_i |x[i]","blas.blas64.html#dasum","fn "],
["blas.blas64","idamax returns the index of an element of x with the largest absolute value. If ","blas.blas64.html#idamax","fn "],
["blas.blas64","dswap exchanges the elements of two vectors. x[i], y[i] = y[i], x[i] for all i","blas.blas64.html#dswap","fn "],
["blas.blas64","dcopy copies the elements of x into the elements of y. y[i] = x[i] for all i","blas.blas64.html#dcopy","fn "],
["blas.blas64","daxpy adds alpha times x to y y[i] += alpha * x[i] for all i","blas.blas64.html#daxpy","fn "],
["blas.blas64","drotg computes the plane rotation","blas.blas64.html#drotg","fn "],
["blas.blas64","drot applies a plane transformation. x[i] = c * x[i] + s * y[i] y[i] = c * y[i] ","blas.blas64.html#drot","fn "],
["blas.blas64","dscal scales x by alpha. x[i] *= alpha dscal has no effect if incx < 0.","blas.blas64.html#dscal","fn "],
["blas.blas64","ddot computes the dot product of the two vectors \sum_i x[i]*y[i]","blas.blas64.html#ddot","fn "],
["blas.blas64","dger performs the rank-one operation A += alpha * x * y·µÄ where A is an m√ón de","blas.blas64.html#dger","fn "],
["blas.blas64","dgbmv performs one of the matrix-vector operations y = alpha * A * x + beta * y ","blas.blas64.html#dgbmv","fn "],
["blas.blas64","dtrmv performs one of the matrix-vector operations x = A * x   if trans_a == .no","blas.blas64.html#dtrmv","fn "],
["blas.blas64","dtrsv solves one of the systems of equations A * x = b   if trans_a == .no_trans","blas.blas64.html#dtrsv","fn "],
["blas.blas64","dsymv performs the matrix-vector operation y = alpha * A * x + beta * y where A ","blas.blas64.html#dsymv","fn "],
["blas.blas64","dtbmv performs one of the matrix-vector operations x = A * x   if trans_a == .no","blas.blas64.html#dtbmv","fn "],
["blas.blas64","dtpmv performs one of the matrix-vector operations x = A * x   if trans_a == .no","blas.blas64.html#dtpmv","fn "],
["blas.blas64","dtbsv solves one of the systems of equations A * x = b   if trans_a == .no_trans","blas.blas64.html#dtbsv","fn "],
["blas.blas64","dsbmv performs the matrix-vector operation y = alpha * A * x + beta * y where A ","blas.blas64.html#dsbmv","fn "],
["blas.blas64","dsyr performs the symmetric rank-one update A += alpha * x * x·µÄ where A is an ","blas.blas64.html#dsyr","fn "],
["blas.blas64","dsyr2 performs the symmetric rank-two update A += alpha * x * y·µÄ + alpha * y *","blas.blas64.html#dsyr2","fn "],
["blas.blas64","dtpsv solves one of the systems of equations A * x = b   if trans_a == .no_trans","blas.blas64.html#dtpsv","fn "],
["blas.blas64","dspmv performs the matrix-vector operation y = alpha * A * x + beta * y where A ","blas.blas64.html#dspmv","fn "],
["blas.blas64","dspr performs the symmetric rank-one operation A += alpha * x * x·µÄ where A is ","blas.blas64.html#dspr","fn "],
["blas.blas64","dspr2 performs the symmetric rank-2 update A += alpha * x * y·µÄ + alpha * y * x","blas.blas64.html#dspr2","fn "],
["blas.blas64","dsyrk performs one of the symmetric rank-k operations C = alpha * A * A·µÄ + bet","blas.blas64.html#dsyrk","fn "],
["blas.blas64","dsyr2k performs one of the symmetric rank 2k operations C = alpha * A * B·µÄ + a","blas.blas64.html#dsyr2k","fn "],
["blas.blas64","dtrmm performs one of the matrix-matrix operations B = alpha * A * B   if side =","blas.blas64.html#dtrmm","fn "],
["blas.blas64","dtrsm solves one of the matrix equations A * X = alpha * B   if trans_a == .no_t","blas.blas64.html#dtrsm","fn "],
["deriv","","deriv.html#central","fn "],
["deriv","","deriv.html#forward","fn "],
["deriv","","deriv.html#backward","fn "],
["deriv","","deriv.html#partial","fn "],
["diff","","diff.html#backward","fn "],
["diff","","diff.html#forward","fn "],
["diff","","diff.html#central","fn "],
["dist","text_hist prints a text histogram","dist.html#text_hist","fn "],
["dist","build_text_hist builds a text histogram","dist.html#build_text_hist","fn "],
["dist","","dist.html#Histogram","struct "],
["dist","find_bin finds where x falls in returns -1 if x is outside the range","dist.html#Histogram.find_bin","fn (Histogram)"],
["dist","count counts how many items fall within each bin","dist.html#Histogram.count","fn (Histogram)"],
["dist","gen_labels generate nice labels identifying bins","dist.html#Histogram.gen_labels","fn (Histogram)"],
["dist","density_area computes the area of the density diagram nsamples -- number of samp","dist.html#Histogram.density_area","fn (Histogram)"],
["dist","Histogram.new returns an histogram struct from a given list of stations","dist.html#Histogram.new","fn "],
["easings","","easings.html#EasingFn","type "],
["easings","linear_interpolation is a method of curve fitting using linear polynomials to co","easings.html#linear_interpolation","fn "],
["easings","quadratic_ease_in eases in with a power of 2","easings.html#quadratic_ease_in","fn "],
["easings","quadratic_easing_eases out with a power of 2","easings.html#quadratic_ease_out","fn "],
["easings","quadratic_easing_in_out speeds up function's growth in a power of 2, then slows ","easings.html#quadratic_ease_in_out","fn "],
["easings","cubic_ease_in eases in with a power of 3","easings.html#cubic_ease_in","fn "],
["easings","cubic_ease_out eases out with a power of 3","easings.html#cubic_ease_out","fn "],
["easings","cubic_ease_in_out speeds up function's growth in a power of 3, then slows down a","easings.html#cubic_ease_in_out","fn "],
["easings","quartic_ease_in eases in with a power of 4","easings.html#quartic_ease_in","fn "],
["easings","quartic_ease_out eases out with a power of 4","easings.html#quartic_ease_out","fn "],
["easings","quartic_ease_in_out speeds up function's growth in a power of 4, then slows down","easings.html#quartic_ease_in_out","fn "],
["easings","quintic_ease_in eases in with a power of 5","easings.html#quintic_ease_in","fn "],
["easings","quintic_ease_out eases out with a power of 5","easings.html#quintic_ease_out","fn "],
["easings","quintic_ease_in_out speeds up function's growth in a power of 5, then slows down","easings.html#quintic_ease_in_out","fn "],
["easings","sine_ease_in accelerates using a sine formula","easings.html#sine_ease_in","fn "],
["easings","sine_ease_out decelerates using a sine formula","easings.html#sine_ease_out","fn "],
["easings","sine_ease_in_out accelerates and decelerates using a sine formula","easings.html#sine_ease_in_out","fn "],
["easings","circular_ease_in accelerates using a circular function","easings.html#circular_ease_in","fn "],
["easings","circular_ease_out decelerates using a circular function","easings.html#circular_ease_out","fn "],
["easings","circular_ease_in_out accelerates and decelerates using a circular function","easings.html#circular_ease_in_out","fn "],
["easings","exponential_ease_in accelerates using an exponential formula","easings.html#exponential_ease_in","fn "],
["easings","exponential_ease_out decelerates using an exponential formula","easings.html#exponential_ease_out","fn "],
["easings","exponential_ease_in_out accelerates and decelerates using an exponential formula","easings.html#exponential_ease_in_out","fn "],
["easings","elastic_ease_in resembles a spring oscillating back and forth, then accelerates","easings.html#elastic_ease_in","fn "],
["easings","elastic_ease_out resembles a spring oscillating back and forth, then decelerates","easings.html#elastic_ease_out","fn "],
["easings","elastic_ease_in_out resembles a spring oscillating back and forth before it begi","easings.html#elastic_ease_in_out","fn "],
["easings","back_ease_in retracts the motion slightly before it begins to accelerate","easings.html#back_ease_in","fn "],
["easings","back_ease_out retracts the motion slightly before it begins to decelerate","easings.html#back_ease_out","fn "],
["easings","back_ease_in_out retracts the motion slightly before it begins to accelerate, th","easings.html#back_ease_in_out","fn "],
["easings","bounce_ease_in creates a bouncing effect, then accelerates","easings.html#bounce_ease_in","fn "],
["easings","bounce_ease_out creates a bouncing effect, then decelerates","easings.html#bounce_ease_out","fn "],
["easings","bounce_ease_in_out creates a bouncing effect before it begins to accelerate, the","easings.html#bounce_ease_in_out","fn "],
["easings","animate returns []f64 of length \"frames\" using the easing function provided wi","easings.html#animate","fn "],
["errors","","errors.html#ErrorCode","enum "],
["errors","","errors.html#ErrorCode.str","fn (ErrorCode)"],
["errors","","errors.html#error","fn "],
["errors","","errors.html#vsl_panic","fn "],
["errors","","errors.html#error_message","fn "],
["fft","create_plan returns a plan to compute a Fourier transform of the given array. A ","fft.html#create_plan","fn "],
["fft","forward_fft computes a Fourier transform defined by the plan p. The input is []f","fft.html#forward_fft","fn "],
["fft","backward_fft computes the backwards Fourier transform defined by the plan r.","fft.html#backward_fft","fn "],
["fit","linear computes linear fitting parameters. Errors on y-direction only","fit.html#linear","fn "],
["fit","linear_sigma computes linear fitting parameters and variances (sigma_a, sigma_b)","fit.html#linear_sigma","fn "],
["float.float32","axpy_unitary","float.float32.html#axpy_unitary","fn "],
["float.float32","axpy_unitary_to","float.float32.html#axpy_unitary_to","fn "],
["float.float32","axpy_inc","float.float32.html#axpy_inc","fn "],
["float.float32","axpy_inc_to","float.float32.html#axpy_inc_to","fn "],
["float.float32","dot_unitary","float.float32.html#dot_unitary","fn "],
["float.float32","dot_inc","float.float32.html#dot_inc","fn "],
["float.float32","","float.float32.html#arrays_tolerance","fn "],
["float.float32","ger performs the rank-one operation A += alpha * x * y·µÄ where A is an m√ón den","float.float32.html#ger","fn "],
["float.float32","gemv_n computes y = alpha * A * x + beta * y where A is an m√ón dense matrix, x ","float.float32.html#gemv_n","fn "],
["float.float32","gemv_t computes y = alpha * A·µÄ * x + beta * y where A is an m√ón dense matrix,","float.float32.html#gemv_t","fn "],
["float.float32","l2_norm_unitary returns the L2-norm of x.","float.float32.html#l2_norm_unitary","fn "],
["float.float32","l2_norm_inc returns the L2-norm of x.","float.float32.html#l2_norm_inc","fn "],
["float.float32","l2_distance_unitary returns the L2-norm of x-y.","float.float32.html#l2_distance_unitary","fn "],
["float.float32","scal_unitary","float.float32.html#scal_unitary","fn "],
["float.float32","scal_unitary_to","float.float32.html#scal_unitary_to","fn "],
["float.float32","scal_inc","float.float32.html#scal_inc","fn "],
["float.float32","scal_inc_to","float.float32.html#scal_inc_to","fn "],
["float.float64","axpy_unitary","float.float64.html#axpy_unitary","fn "],
["float.float64","axpy_unitary_to","float.float64.html#axpy_unitary_to","fn "],
["float.float64","axpy_inc","float.float64.html#axpy_inc","fn "],
["float.float64","axpy_inc_to","float.float64.html#axpy_inc_to","fn "],
["float.float64","dot_unitary","float.float64.html#dot_unitary","fn "],
["float.float64","dot_inc","float.float64.html#dot_inc","fn "],
["float.float64","IncSet.new will generate all (x,y) combinations of the input increment set.","float.float64.html#IncSet.new","fn "],
["float.float64","IncToSet.new will generate all (dst,x,y) combinations of the input increment set","float.float64.html#IncToSet.new","fn "],
["float.float64","same returns true when the inputs have the same value, allowing NaN equality.","float.float64.html#same","fn "],
["float.float64","","float.float64.html#tolerance","fn "],
["float.float64","","float.float64.html#arrays_tolerance","fn "],
["float.float64","","float.float64.html#close","fn "],
["float.float64","","float.float64.html#veryclose","fn "],
["float.float64","","float.float64.html#soclose","fn "],
["float.float64","","float.float64.html#alike","fn "],
["float.float64","new_guarded_vector allocates a new slice and returns it as three subslices. v is","float.float64.html#new_guarded_vector","fn "],
["float.float64","all_nan returns true if x contains only nan values, and false otherwise.","float.float64.html#all_nan","fn "],
["float.float64","equal_strided returns true if the strided vector x contains elements of the dens","float.float64.html#equal_strided","fn "],
["float.float64","non_strided_write returns false if all elements of x at non-stride indices are e","float.float64.html#non_strided_write","fn "],
["float.float64","guard_vector copies the source vector (vec) into a new slice with guards. Guards","float.float64.html#guard_vector","fn "],
["float.float64","is_valid_guard will test for violated guards, generated by guard_vector.","float.float64.html#is_valid_guard","fn "],
["float.float64","guard_inc_vector copies the source vector (vec) into a new incremented slice wit","float.float64.html#guard_inc_vector","fn "],
["float.float64","is_valid_inc_guard will test for violated guards, generated by guard_inc_vector.","float.float64.html#is_valid_inc_guard","fn "],
["float.float64","","float.float64.html#random_slice","fn "],
["float.float64","ger performs the rank-one operation A += alpha * x * y·µÄ where A is an m√ón den","float.float64.html#ger","fn "],
["float.float64","gemv_n computes y = alpha * A * x + beta * y where A is an m√ón dense matrix, x ","float.float64.html#gemv_n","fn "],
["float.float64","gemv_t computes y = alpha * A·µÄ * x + beta * y where A is an m√ón dense matrix,","float.float64.html#gemv_t","fn "],
["float.float64","l2_norm_unitary returns the L2-norm of x.","float.float64.html#l2_norm_unitary","fn "],
["float.float64","l2_norm_inc returns the L2-norm of x.","float.float64.html#l2_norm_inc","fn "],
["float.float64","l2_distance_unitary returns the L2-norm of x-y.","float.float64.html#l2_distance_unitary","fn "],
["float.float64","scal_unitary","float.float64.html#scal_unitary","fn "],
["float.float64","scal_unitary_to","float.float64.html#scal_unitary_to","fn "],
["float.float64","scal_inc","float.float64.html#scal_inc","fn "],
["float.float64","scal_inc_to","float.float64.html#scal_inc_to","fn "],
["fun","bessel_j0 returns the order-zero Bessel function of the first kind.","fun.html#bessel_j0","fn "],
["fun","bessel_j1 returns the order-one Bessel function of the first kind.","fun.html#bessel_j1","fn "],
["fun","bessel_jn returns the order-n Bessel function of the first kind.","fun.html#bessel_jn","fn "],
["fun","bessel_y0 returns the order-zero Bessel function of the second kind.","fun.html#bessel_y0","fn "],
["fun","bessel_y1 returns the order-one Bessel function of the second kind.","fun.html#bessel_y1","fn "],
["fun","bessel_yn returns the order-n Bessel function of the second kind.","fun.html#bessel_yn","fn "],
["fun","The asymptotic expansions of pzero is 1 - 9/128 s**2 + 11025/98304 s**4 - ..., w","fun.html#pzero","fn "],
["fun","For x >= 8, the asymptotic expansions of pone is 1 + 15/128 s**2 - 4725/2**15 s*","fun.html#pone","fn "],
["fun","For x >= 8, the asymptotic expansions of qzero is -1/8 s + 75/1024 s**3 - ..., w","fun.html#qzero","fn "],
["fun","For x >= 8, the asymptotic expansions of qone is 3/8 s - 105/1024 s**3 - ..., wh","fun.html#qone","fn "],
["fun","gamma computes the gamma function value","fun.html#cgamma","fn "],
["fun","log_gamma computes the log-gamma function value","fun.html#clog_gamma","fn "],
["fun","data for a Chebyshev series over a given interval","fun.html#ChebSeries","struct "],
["fun","","fun.html#ChebSeries.eval_e","fn (ChebSeries)"],
["fun","Compute the binomial coefficient","fun.html#choose","fn "],
["fun","InterpFn defines the type of the implementation of the data interpolation","fun.html#InterpFn","type "],
["fun","DataInterp implements numeric interpolators to be used with discrete data","fun.html#DataInterp","struct "],
["fun","reset re-assigns xx and yy data sets","fun.html#DataInterp.reset","fn (DataInterp)"],
["fun","p computes p(x); i.e. performs the interpolation","fun.html#DataInterp.p","fn (DataInterp)"],
["fun","locate returns a value j such that x is (insofar as possible) centered in the su","fun.html#DataInterp.locate","fn (DataInterp)"],
["fun","hunt returns a value j such that x is (insofar as possible) centered in the subr","fun.html#DataInterp.hunt","fn (DataInterp)"],
["fun","DataInterp.new creates new interpolator for data point sets xx and yy (with same","fun.html#DataInterp.new","fn "],
["fun","lin_interp implements linear interpolator","fun.html#lin_interp","fn "],
["fun","poly_interp performs a polynomial interpolation. this routine returns an interpo","fun.html#poly_interp","fn "],
["fun","","fun.html#digamma","fn "],
["fun","","fun.html#psi","fn "],
["fun","erf returns the error function of x.","fun.html#erf","fn "],
["fun","erfc returns the complementary error function of x.","fun.html#erfc","fn "],
["fun","fib returns the nth number in the Fibonacci sequence using O(1) space in O(logn)","fun.html#fib","fn "],
["fun","beta computes the beta function by calling the log_gamma_sign function","fun.html#beta","fn "],
["fun","binomial comptues the binomial coefficient (n k)^t","fun.html#binomial","fn "],
["fun","uint_binomial implements the binomial coefficient using u64. panic happens on ov","fun.html#uint_binomial","fn "],
["fun","rbinomial computes the binomial coefficient with real (non-negative) arguments b","fun.html#rbinomial","fn "],
["fun","(n+r-1)! / r! / (n-1)! when n > 0.","fun.html#n_combos_w_replacement","fn "],
["fun","suqcos implements the superquadric auxiliary function that uses cos(x)","fun.html#suqcos","fn "],
["fun","suqsin implements the superquadric auxiliary function that uses sin(x)","fun.html#suqsin","fn "],
["fun","atan2p implements a positive version of atan2, in such a way that: 0 ‚â§ Œ± ‚â§ ","fun.html#atan2p","fn "],
["fun","atan2pdeg implements a positive version of atan2, in such a way that: 0 ‚â§ Œ± ‚","fun.html#atan2pdeg","fn "],
["fun","ramp function => macaulay brackets","fun.html#ramp","fn "],
["fun","heav computes the heaviside step function (== derivative of ramp(x))","fun.html#heav","fn "],
["fun","sign implements the sign function","fun.html#sign","fn "],
["fun","boxcar implements the boxcar function","fun.html#boxcar","fn "],
["fun","rect implements the rectangular function","fun.html#rect","fn "],
["fun","hat implements the hat function","fun.html#hat","fn "],
["fun","hatd1 returns the first derivative of the hat function _**NOTE**: the discontinu","fun.html#hatd1","fn "],
["fun","sramp implements a smooth ramp function. ramp","fun.html#sramp","fn "],
["fun","srampd1 returns the first derivative of sramp","fun.html#srampd1","fn "],
["fun","srampd2 returns the second derivative of sramp","fun.html#srampd2","fn "],
["fun","logistic implements the sigmoid/logistic function","fun.html#logistic","fn "],
["fun","logistic_d1 implements the first derivative of the sigmoid/logistic function","fun.html#logistic_d1","fn "],
["fun","sabs implements a smooth abs f: sabs(x) = x*x / (sign(x)*x + eps)","fun.html#sabs","fn "],
["fun","sabs_d1 returns the first derivative of sabs","fun.html#sabs_d1","fn "],
["fun","sabs_d2 returns the first derivative of sabs","fun.html#sabs_d2","fn "],
["fun","exp_pix uses euler's formula to compute exp(+i‚ãÖx) = cos(x) + i‚ãÖsin(x)","fun.html#exp_pix","fn "],
["fun","exp_mix uses euler's formula to compute exp(-i‚ãÖx) = cos(x) - i‚ãÖsin(x)","fun.html#exp_mix","fn "],
["fun","sinc computes the sine cardinal (sinc) function","fun.html#sinc","fn "],
["fun","neg_one_pow_n computes (-1)‚Åø","fun.html#neg_one_pow_n","fn "],
["fun","imag_pow_n computes i‚Åø = (‚àö-1)‚Åø","fun.html#imag_pow_n","fn "],
["fun","imag_x_pow_n computes (x‚ãÖi)‚Åø","fun.html#imag_x_pow_n","fn "],
["fun","powp computes real raised to positive integer x‚Åø","fun.html#powp","fn "],
["fun","pow2 computes x¬≤","fun.html#pow2","fn "],
["fun","pow3 computes x¬≥","fun.html#pow3","fn "],
["fun","gamma returns the gamma function of x.","fun.html#gamma","fn "],
["fun","log_gamma returns the natural logarithm and sign (-1 or +1) of Gamma(x).","fun.html#log_gamma","fn "],
["fun","","fun.html#log_gamma_sign","fn "],
["fun","","fun.html#hypot","fn "],
["fun","","fun.html#hypot_e","fn "],
["fun","InterpCubic computes a cubic polynomial to perform interpolation either using 4 ","fun.html#InterpCubic","struct "],
["fun","f computes y = f(x) curve","fun.html#InterpCubic.f","fn (InterpCubic)"],
["fun","g computes y' = df/x|(x) curve","fun.html#InterpCubic.g","fn (InterpCubic)"],
["fun","critical returns the critical points xmin -- x @ min and y(xmin) xmax -- x @ max","fun.html#InterpCubic.critical","fn (InterpCubic)"],
["fun","fit_4points fits polynomial to 3 points (x0, y0) -- first point (x1, y1) -- seco","fun.html#InterpCubic.fit_4points","fn (InterpCubic)"],
["fun","fit_3points_d fits polynomial to 3 points and known derivative (x0, y0) -- first","fun.html#InterpCubic.fit_3points_d","fn (InterpCubic)"],
["fun","InterpCubic.new returns a new InterpCubic instance","fun.html#InterpCubic.new","fn "],
["fun","InterpQuad computes a quadratic polynomial to perform interpolation either using","fun.html#InterpQuad","struct "],
["fun","f computes y = f(x) curve","fun.html#InterpQuad.f","fn (InterpQuad)"],
["fun","g computes y' = df/x|(x) curve","fun.html#InterpQuad.g","fn (InterpQuad)"],
["fun","optimum returns the minimum or maximum point; i.e. the point with zero derivativ","fun.html#InterpQuad.optimum","fn (InterpQuad)"],
["fun","fit_3points fits polynomial to 3 points (x0, y0) -- first point (x1, y1) -- seco","fun.html#InterpQuad.fit_3points","fn (InterpQuad)"],
["fun","fit_2points_d fits polynomial to 2 points and known derivative (x0, y0) -- first","fun.html#InterpQuad.fit_2points_d","fn (InterpQuad)"],
["fun","InterpQuad.new returns a new InterpQuad instance","fun.html#InterpQuad.new","fn "],
["fun","bessel_i0 returns the modified Bessel function i0(x) for any real x.","fun.html#bessel_i0","fn "],
["fun","bessel_i1 returns the modified Bessel function i1(x) for any real x.","fun.html#bessel_i1","fn "],
["fun","bessel_in returns the modified Bessel function in(x) for any real x and n ‚â• 0","fun.html#bessel_in","fn "],
["fun","bessel_k0 returns the modified Bessel function k0(x) for positive real x. specia","fun.html#bessel_k0","fn "],
["fun","bessel_k1 returns the modified Bessel function k1(x) for positive real x. specia","fun.html#bessel_k1","fn "],
["fun","bessel_kn returns the modified Bessel function kn(x) for positive x and n ‚â• 0","fun.html#bessel_kn","fn "],
["fun","Sinusoid implements the sinusoid equation:","fun.html#Sinusoid","struct "],
["fun","yessen computes y(t) = a0 + c1‚ãÖcos(omega_0‚ãÖt + theta [essential-form]","fun.html#Sinusoid.yessen","fn (Sinusoid)"],
["fun","ybasis computes y(t) = a0 + a1‚ãÖcos(omega_0‚ãÖt) + b1‚ãÖsin(omega_0‚ãÖt) [basis","fun.html#Sinusoid.ybasis","fn (Sinusoid)"],
["fun","approx_square_fourier approximates sinusoid using Fourier series with n terms","fun.html#Sinusoid.approx_square_fourier","fn (Sinusoid)"],
["fun","test_periodicity tests that f(t) = f(t + t)","fun.html#Sinusoid.test_periodicity","fn (Sinusoid)"],
["fun","Sinusoid.essential creates a new sinusoid object with the \"essential\" paramete","fun.html#Sinusoid.essential","fn "],
["fun","Sinusoid.basis creates a new sinusoid object with the \"basis\" parameters set t","fun.html#Sinusoid.basis","fn "],
["fun","","fun.html#sin_e","fn "],
["fun","","fun.html#cos_e","fn "],
["fun","","fun.html#sin","fn "],
["fun","","fun.html#cos","fn "],
["func","","func.html#ArbitraryFn","type "],
["func","","func.html#DfFn","type "],
["func","","func.html#FdfFn","type "],
["func","","func.html#VectorValuedFn","type "],
["func","Definition of an arbitrary function with parameters","func.html#Fn","struct "],
["func","","func.html#Fn.eval","fn (Fn)"],
["func","Call the pointed-to function with argument x, put its result in y, and return an","func.html#Fn.safe_eval","fn (Fn)"],
["func","Fn.new returns an arbitrary function with parameters","func.html#Fn.new","fn "],
["func","Definition of an arbitrary function returning two values, r1, r2","func.html#FnFdf","struct "],
["func","","func.html#FnFdf.eval_f","fn (FnFdf)"],
["func","","func.html#FnFdf.eval_df","fn (FnFdf)"],
["func","","func.html#FnFdf.eval_f_df","fn (FnFdf)"],
["func","FnFdf.new returns an arbitrary function returning two values, r1, r2","func.html#FnFdf.new","fn "],
["func","Definition of an arbitrary vector-valued function with parameters","func.html#FnVec","struct "],
["func","","func.html#FnVec.eval","fn (FnVec)"],
["func","FnVec.new returns an arbitrary vector-valued function with parameters","func.html#FnVec.new","fn "],
["gm","Point holds the Cartesian coordinates of a point in 3D space","gm.html#Point","struct "],
["gm","clone creates a new copy of Point","gm.html#Point.clone","fn (Point)"],
["gm","disp creates a new copy of Point displaced by dx, dy, dz","gm.html#Point.disp","fn (Point)"],
["gm","str outputs Point","gm.html#Point.str","fn (Point)"],
["gm","Segment represents a directed segment from a to b","gm.html#Segment","struct "],
["gm","len computes the length of Segment == Euclidean norm","gm.html#Segment.len","fn (Segment)"],
["gm","New creates a new Segment scaled by m and starting from A","gm.html#Segment.scaled","fn (Segment)"],
["gm","vector returns the vector representing Segment from A to B (scaled by m)","gm.html#Segment.vector","fn (Segment)"],
["gm","str outputs Segment","gm.html#Segment.str","fn (Segment)"],
["gm","Point.new creates a new point","gm.html#Point.new","fn "],
["gm","dist_point_point computes the unsigned distance from a to b","gm.html#dist_point_point","fn "],
["gm","Segment.new creates a new segment from a to b","gm.html#Segment.new","fn "],
["gm","vector_dot returns the dot product between two vectors","gm.html#vector_dot","fn "],
["gm","vector_norm returns the length (Euclidean norm) of a vector","gm.html#vector_norm","fn "],
["gm","vector_new returns a new vector scaled by m","gm.html#vector_new","fn "],
["gm","vector_add returns a new vector by adding two other vectors w := Œ±*u + Œ≤*v","gm.html#vector_add","fn "],
["gm","dist_point_line computes the distance from p to line passing through a -> b","gm.html#dist_point_line","fn "],
["gm","points_lims returns the limits of a set of points","gm.html#points_lims","fn "],
["gm","is_point_in returns whether p is inside box with cmin and cmax","gm.html#is_point_in","fn "],
["gm","is_point_in_line returns whether p is inside line passing through a and b","gm.html#is_point_in_line","fn "],
["gm","BinEntry holds data of an entry to bin","gm.html#BinEntry","struct "],
["gm","Bin defines one bin in Bins (holds entries for search)","gm.html#Bin","struct "],
["gm","str returns the string representation of one Bin","gm.html#Bin.str","fn (Bin)"],
["gm","Bins implements a set of bins holding entries and is used to fast search entries","gm.html#Bins","struct "],
["gm","append adds a new entry {x, id, something} into the bins structure","gm.html#Bins.append","fn (Bins)"],
["gm","clear clears all biBinsns","gm.html#Bins.clear","fn (Bins)"],
["gm","find_bin_by_index finds or allocate new bin corresponding to index idx","gm.html#Bins.find_bin_by_index","fn (Bins)"],
["gm","calc_index calculates the bin index where the point x is returns -1 if out-of-ra","gm.html#Bins.calc_index","fn (Bins)"],
["gm","find_closest returns the id of the entry whose coordinates are closest to x id_c","gm.html#Bins.find_closest","fn (Bins)"],
["gm","find_closest_and_append finds closest point and, if not found, append to bins wi","gm.html#Bins.find_closest_and_append","fn (Bins)"],
["gm","find_along_segment gets the ids of entries that lie close to a segment","gm.html#Bins.find_along_segment","fn (Bins)"],
["gm","get_limits returns limigs of a specific bin","gm.html#Bins.get_limits","fn (Bins)"],
["gm","nactive returns the number of active bins; i.e. non-nil bins","gm.html#Bins.nactive","fn (Bins)"],
["gm","nentries returns the total number of entries (in active bins)","gm.html#Bins.nentries","fn (Bins)"],
["gm","summary returns the summary of this Bins' data","gm.html#Bins.summary","fn (Bins)"],
["gm","str returns the string representation of a set of Bins","gm.html#Bins.str","fn (Bins)"],
["gm","Bins.new initialise bins structure xmin -- [ndim] min/initial coordinates of the","gm.html#Bins.new","fn "],
["gm","","gm.html#PointsDiffFn","type "],
["graph","","graph.html#ShortestPaths","enum "],
["graph","Graph defines a graph structure","graph.html#Graph","struct "],
["graph","nverts returns the number of vertices","graph.html#Graph.nverts","fn (Graph)"],
["graph","get_edge performs a lookup on key2edge map and returs id of edge for given nodes","graph.html#Graph.get_edge","fn (Graph)"],
["graph","","graph.html#Graph.shortest_paths","fn (Graph)"],
["graph","path returns the path from source (s) to destination (t)","graph.html#Graph.path","fn (Graph)"],
["graph","calc_dist computes distances beetween all vertices and initialises 'next' matrix","graph.html#Graph.calc_dist","fn (Graph)"],
["graph","str_dist_matrix returns a string representation of dist matrix","graph.html#Graph.str_dist_matrix","fn (Graph)"],
["graph","get_adj returns adjacency list as a compressed storage format for METIS","graph.html#Graph.get_adj","fn (Graph)"],
["graph","Graph.new initialises graph edges    -- [nedges][2] edges (connectivity) weights","graph.html#Graph.new","fn "],
["inout.h5","","inout.h5.html#Hdf5File","struct "],
["inout.h5","write_dataset1d writes a 1-d numeric array (vector) to a named HDF5 dataset in a","inout.h5.html#Hdf5File.write_dataset1d","fn (Hdf5File)"],
["inout.h5","write_dataset2d writes a 2-d numeric array to a named HDF5 dataset in an HDF5 fi","inout.h5.html#Hdf5File.write_dataset2d","fn (Hdf5File)"],
["inout.h5","write_dataset3d writes a numeric 3-d array (layers of 2-d arrays) to a named HDF","inout.h5.html#Hdf5File.write_dataset3d","fn (Hdf5File)"],
["inout.h5","write_attribute1d adds a named 1-d numeric array (vector) attribute to a named H","inout.h5.html#Hdf5File.write_attribute1d","fn (Hdf5File)"],
["inout.h5","write_attribute adds a named scalar attribute to a named HDF5 dataset. This is a","inout.h5.html#Hdf5File.write_attribute","fn (Hdf5File)"],
["inout.h5","read_dataset1d reads a 1-d numeric array (vector) from a named HDF5 dataset in a","inout.h5.html#Hdf5File.read_dataset1d","fn (Hdf5File)"],
["inout.h5","read_dataset2d reads a 2-d numeric array from a named HDF5 dataset in an HDF5 fi","inout.h5.html#Hdf5File.read_dataset2d","fn (Hdf5File)"],
["inout.h5","read_dataset3d reads a 3-d numeric array from a named HDF5 dataset in an HDF5 fi","inout.h5.html#Hdf5File.read_dataset3d","fn (Hdf5File)"],
["inout.h5","readattribute gets a named scalar attribute from a named HDF5 dataset. This is a","inout.h5.html#Hdf5File.read_attribute","fn (Hdf5File)"],
["inout.h5","read_attribute1d reads a 1-d numeric array (vector) from a named HDF5 dataset an","inout.h5.html#Hdf5File.read_attribute1d","fn (Hdf5File)"],
["inout.h5","close releases memory resources for HDF5 files.","inout.h5.html#Hdf5File.close","fn (Hdf5File)"],
["inout.h5","Hdf5File.new creates a new HDF5 file, or truncates an existing file.","inout.h5.html#Hdf5File.new","fn "],
["inout.h5","open_file opens an existing HDF5 file.","inout.h5.html#open_file","fn "],
["iter","combinations will return an array of all length `r` combinations of `data` While","iter.html#combinations","fn "],
["iter","","iter.html#CombinationsIter","struct "],
["iter","next will return next combination if possible","iter.html#CombinationsIter.next","fn (CombinationsIter)"],
["iter","CombinationsIter.new will return an iterator that allows lazy computation for al","iter.html#CombinationsIter.new","fn "],
["iter","combinations_with_replacement will return r length subsequences of elements from","iter.html#combinations_with_replacement","fn "],
["iter","","iter.html#CombinationsWithReplacementIter","struct "],
["iter","next will return next combination if possible","iter.html#CombinationsWithReplacementIter.next","fn (CombinationsWithReplacementIter)"],
["iter","CombinationsWithReplacementIter.new will return an iterator that allows lazy com","iter.html#CombinationsWithReplacementIter.new","fn "],
["iter","","iter.html#Counter","struct "],
["iter","","iter.html#Counter.next","fn (Counter)"],
["iter","","iter.html#Counter.new","fn "],
["iter","","iter.html#Cycler","struct "],
["iter","","iter.html#Cycler.next","fn (Cycler)"],
["iter","","iter.html#Cycler.new","fn "],
["iter","","iter.html#Repeater","struct "],
["iter","","iter.html#Repeater.next","fn (Repeater)"],
["iter","","iter.html#Repeater.new","fn "],
["iter","","iter.html#PermutationsIter","struct "],
["iter","next will return next permutation if possible","iter.html#PermutationsIter.next","fn (PermutationsIter)"],
["iter","PermutationsIter.new will return an iterator that allows lazy computation for al","iter.html#PermutationsIter.new","fn "],
["iter","permutations returns successive `r` length permutations of elements in `data`","iter.html#permutations","fn "],
["iter","","iter.html#ProductIterator","struct "],
["iter","","iter.html#ProductIterator.next","fn (ProductIterator)"],
["iter","","iter.html#ProductIterator.new","fn "],
["iter","Cartesian product of the arrays in `data`","iter.html#product","fn "],
["iter","","iter.html#IntIterParams","struct "],
["iter","IntIter.new returns an iterator of evenly spaced integers numbers in the half-op","iter.html#IntIter.new","fn "],
["iter","","iter.html#IntIter","type "],
["iter","next returns the next element of the iterator if possible.","iter.html#IntIter.next","fn (IntIter)"],
["iter","","iter.html#FloatIterParams","struct "],
["iter","FloatIter.new returns an iterator of evenly spaced floats in the half-open inter","iter.html#FloatIter.new","fn "],
["iter","","iter.html#FloatIter","type "],
["iter","next returns the next element of the iterator if possible.","iter.html#FloatIter.next","fn (FloatIter)"],
["iter","","iter.html#LinearIterParams","struct "],
["iter","LinearIter.new returns an iterator of `len` evenly spaced floats in the interval","iter.html#LinearIter.new","fn "],
["iter","","iter.html#LinearIter","type "],
["iter","next returns the next element of the iterator if possible.","iter.html#LinearIter.next","fn (LinearIter)"],
["iter","","iter.html#LogIterParams","struct "],
["iter","LogIter.new returns an iterator of `len` numbers evenly spaced on a logarithmic ","iter.html#LogIter.new","fn "],
["iter","","iter.html#LogIter","type "],
["iter","next returns the next element of the iterator if possible.","iter.html#LogIter.next","fn (LogIter)"],
["la","","la.html#vector_rms_error","fn "],
["la","vector_dot returns the dot product between two vectors: s := u„Éªv","la.html#vector_dot","fn "],
["la","vector_add adds the scaled components of two vectors res := alpha‚ãÖu + beta‚ãÖv","la.html#vector_add","fn "],
["la","vector_max_diff returns the maximum absolute difference between two vectors maxd","la.html#vector_max_diff","fn "],
["la","vector_scale_abs creates a \"scale\" vector using the absolute value of another ","la.html#vector_scale_abs","fn "],
["la","matrix_vector_mul returns the matrix-vector multiplication","la.html#matrix_vector_mul","fn "],
["la","matrix_tr_vector_mul returns the transpose(matrix)-vector multiplication","la.html#matrix_tr_vector_mul","fn "],
["la","vector_vector_tr_mul returns the matrix = vector-transpose(vector) multiplicatio","la.html#vector_vector_tr_mul","fn "],
["la","matrix_vector_mul_add returns the matrix-vector multiplication with addition","la.html#matrix_vector_mul_add","fn "],
["la","matrix_matrix_mul returns the matrix multiplication (scaled)","la.html#matrix_matrix_mul","fn "],
["la","matrix_tr_matrix_mul returns the matrix multiplication (scaled) with transposed(","la.html#matrix_tr_matrix_mul","fn "],
["la","matrix_matrix_tr_mul returns the matrix multiplication (scaled) with transposed(","la.html#matrix_matrix_tr_mul","fn "],
["la","matrix_tr_matrix_tr_mul returns the matrix multiplication (scaled) with transpos","la.html#matrix_tr_matrix_tr_mul","fn "],
["la","matrix_matrix_muladd returns the matrix multiplication (scaled)","la.html#matrix_matrix_muladd","fn "],
["la","matrix_tr_matrix_muladd returns the matrix multiplication (scaled) with transpos","la.html#matrix_tr_matrix_muladd","fn "],
["la","matrix_matrix_tr_muladd returns the matrix multiplication (scaled) with transpos","la.html#matrix_matrix_tr_muladd","fn "],
["la","matrix_tr_matrix_tr_mul_add returns the matrix multiplication (scaled) with tran","la.html#matrix_tr_matrix_tr_mul_add","fn "],
["la","matrix_add adds the scaled components of two matrices res := alpha‚ãÖa + beta‚ãÖ","la.html#matrix_add","fn "],
["la","den_solve solves dense linear system using LAPACK","la.html#den_solve","fn "],
["la","jacobi performs the Jacobi transformation of a symmetric matrix to find its eige","la.html#jacobi","fn "],
["la","","la.html#Matrix","struct "],
["la","Matrix.new allocates a new (empty) Matrix with given (m,n) (row/col sizes)","la.html#Matrix.new","fn "],
["la","Matrix.deep2 allocates a new Matrix from given (Deep2) nested slice.","la.html#Matrix.deep2","fn "],
["la","Matrix.raw creates a new Matrix using given raw data Input: rawdata -- data orga","la.html#Matrix.raw","fn "],
["la","","la.html#Matrix[T]","type "],
["la","set_from_deep2 sets matrix with data from a nested slice (Deep2) structure","la.html#Matrix[T].set_from_deep2","fn (Matrix[T])"],
["la","set_diag sets diagonal matrix with diagonal components equal to val","la.html#Matrix[T].set_diag","fn (Matrix[T])"],
["la","set sets value","la.html#Matrix[T].set","fn (Matrix[T])"],
["la","get gets value","la.html#Matrix[T].get","fn (Matrix[T])"],
["la","get_deep2 returns nested slice representation","la.html#Matrix[T].get_deep2","fn (Matrix[T])"],
["la","clone returns a copy of this matrix","la.html#Matrix[T].clone","fn (Matrix[T])"],
["la","transpose returns the transpose matrix","la.html#Matrix[T].transpose","fn (Matrix[T])"],
["la","copy_into copies the scaled components of this matrix into another one (result) ","la.html#Matrix[T].copy_into","fn (Matrix[T])"],
["la","add adds value to (i,j) location","la.html#Matrix[T].add","fn (Matrix[T])"],
["la","fill fills this matrix with a single number val aij = val","la.html#Matrix[T].fill","fn (Matrix[T])"],
["la","","la.html#Matrix[T].clear_rc","fn (Matrix[T])"],
["la","","la.html#Matrix[T].clear_bry","fn (Matrix[T])"],
["la","max_diff returns the maximum difference between the components of this and anoth","la.html#Matrix[T].max_diff","fn (Matrix[T])"],
["la","largest returns the largest component |a[ij]| of this matrix, normalised by den ","la.html#Matrix[T].largest","fn (Matrix[T])"],
["la","col access column j of this matrix. No copies are made since the internal data a","la.html#Matrix[T].col","fn (Matrix[T])"],
["la","get_row returns row i of this matrix","la.html#Matrix[T].get_row","fn (Matrix[T])"],
["la","get_col returns column j of this matrix","la.html#Matrix[T].get_col","fn (Matrix[T])"],
["la","extract_cols returns columns from j=start to j=endp1-1 start -- first column end","la.html#Matrix[T].extract_cols","fn (Matrix[T])"],
["la","extract_rows returns rows from i=start to i=endp1-1 start -- first column endp1 ","la.html#Matrix[T].extract_rows","fn (Matrix[T])"],
["la","set_row sets the values of a row i with a single value","la.html#Matrix[T].set_row","fn (Matrix[T])"],
["la","set_col sets the values of a column j with a single value","la.html#Matrix[T].set_col","fn (Matrix[T])"],
["la","split_by_col splits this matrix into two matrices at column j j -- column index","la.html#Matrix[T].split_by_col","fn (Matrix[T])"],
["la","split_by_row splits this matrix into two matrices at row i i -- row index","la.html#Matrix[T].split_by_row","fn (Matrix[T])"],
["la","norm_frob returns the Frobenius norm of this matrix nrm := ‚Äña‚Äñ_F = sqrt(Œ£_i","la.html#Matrix[T].norm_frob","fn (Matrix[T])"],
["la","norm_inf returns the infinite norm of this matrix nrm := ‚Äña‚Äñ_‚àû = max_i ( Œ","la.html#Matrix[T].norm_inf","fn (Matrix[T])"],
["la","apply sets this matrix with the scaled components of another matrix this := alph","la.html#Matrix[T].apply","fn (Matrix[T])"],
["la","equals returns true if this matrix is equal to another matrix this == another   ","la.html#Matrix[T].equals","fn (Matrix[T])"],
["la","","la.html#Matrix[T].str","fn (Matrix[T])"],
["la","print prints matrix (without commas or brackets)","la.html#Matrix[T].print","fn (Matrix[T])"],
["la","print_v prints matrix in V format","la.html#Matrix[T].print_v","fn (Matrix[T])"],
["la","print_py prints matrix in Python format","la.html#Matrix[T].print_py","fn (Matrix[T])"],
["la","","la.html#safe_print","fn "],
["la","det computes the determinant of matrix using the LU factorization","la.html#matrix_det","fn "],
["la","matrix_inv_small computes the inverse of small matrices of size 1x1, 2x2, or 3x3","la.html#matrix_inv_small","fn "],
["la","matrix_svd performs the SVD decomposition Input: a     -- matrix a copy_a -- cre","la.html#matrix_svd","fn "],
["la","matrix_inv computes the inverse of a general matrix (square or not). It also com","la.html#matrix_inv","fn "],
["la","matrix_cond_num returns the condition number of a square matrix using the invers","la.html#matrix_cond_num","fn "],
["la","The SparseConfig structure holds configuration arguments for sparse solvers","la.html#SparseConfig","struct "],
["la","set_mumps_symmetry sets symmetry options for MUMPS solver","la.html#SparseConfig.set_mumps_symmetry","fn (SparseConfig)"],
["la","set_umfpack_symmetry sets symmetry options for UMFPACK solver","la.html#SparseConfig.set_umfpack_symmetry","fn (SparseConfig)"],
["la","set_mumps_ordering sets ordering for MUMPS solver ordering -- \"\" or \"amf\" [d","la.html#SparseConfig.set_mumps_ordering","fn (SparseConfig)"],
["la","set_mumps_scaling sets scaling for MUMPS solver scaling -- \"\" or \"rcit\" [def","la.html#SparseConfig.set_mumps_scaling","fn (SparseConfig)"],
["la","SparseConfig.new returns a new SparseConfig Input: comm -- may be nil","la.html#SparseConfig.new","fn "],
["la","SparseConfig.with_comm returns a new SparseConfig","la.html#SparseConfig.with_comm","fn "],
["la","Triplet is a simple representation of a sparse matrix, where the indices and val","la.html#Triplet","struct "],
["la","CCMatrix represents a sparse matrix using the so-called \"column-compressed form","la.html#CCMatrix","struct "],
["la","Triplet.new returns a new Triplet. This is a wrapper to new(Triplet) followed by","la.html#Triplet.new","fn "],
["la","","la.html#Triplet[T]","type "],
["la","init allocates all memory required to hold a sparse matrix in triplet form","la.html#Triplet[T].init","fn (Triplet[T])"],
["la","put inserts an element to a pre-allocated (with init) triplet matrix","la.html#Triplet[T].put","fn (Triplet[T])"],
["la","","la.html#Triplet[T].put_matrix_and_matrix_t","fn (Triplet[T])"],
["la","","la.html#Triplet[T].put_cc_matrix_and_matrix_t","fn (Triplet[T])"],
["la","start (re)starts index for inserting items using the put command","la.html#Triplet[T].start","fn (Triplet[T])"],
["la","Len returns the number of items just inserted in the triplet","la.html#Triplet[T].len","fn (Triplet[T])"],
["la","max returns the maximum number of items that can be inserted in the triplet","la.html#Triplet[T].max","fn (Triplet[T])"],
["la","size returns the row/column size of the matrix represented by the Triplet","la.html#Triplet[T].size","fn (Triplet[T])"],
["la","to_dense returns the dense matrix corresponding to this Triplet","la.html#Triplet[T].to_dense","fn (Triplet[T])"],
["la","vector_apply sets this []T with the scaled components of another []T this := a *","la.html#vector_apply","fn "],
["la","vector_apply_func runs a function over all components of a []T vi = f(i,vi)","la.html#vector_apply_func","fn "],
["la","vector_unit returns the unit []f64 parallel to this []f64 b := a / norm(a)","la.html#vector_unit","fn "],
["la","vector_accum sum/accumulates all components in a []T sum := Œ£_i v[i]","la.html#vector_accum","fn "],
["la","vector_norm returns the Euclidean norm of a []T: nrm := ‚Äñv‚Äñ","la.html#vector_norm","fn "],
["la","vector_rms returns the root-mean-square of this []T","la.html#vector_rms","fn "],
["la","vector_norm_diff returns the Euclidean norm of the difference: nrm := ||u - v||","la.html#vector_norm_diff","fn "],
["la","vector_largest returns the largest component |u[i]| of this []T, normalised by d","la.html#vector_largest","fn "],
["lapack","Direct specifies the direction of the multiplication for the Householder matrix.","lapack.html#Direct","enum "],
["lapack","Sort is the sorting order.","lapack.html#Sort","enum "],
["lapack","StoreV indicates the storage direction of elementary reflectors.","lapack.html#StoreV","enum "],
["lapack","MatrixNorm represents the kind of matrix norm to compute.","lapack.html#MatrixNorm","enum "],
["lapack","MatrixType represents the kind of matrix represented in the data.","lapack.html#MatrixType","enum "],
["lapack","Pivot specifies the pivot type for plane rotations.","lapack.html#Pivot","enum "],
["lapack","ApplyOrtho specifies which orthogonal matrix is applied in Dormbr.","lapack.html#ApplyOrtho","enum "],
["lapack","GenOrtho specifies which orthogonal matrix is generated in Dorgbr.","lapack.html#GenOrtho","enum "],
["lapack","SVDJob specifies the singular vector computation type for SingularValueDecomposi","lapack.html#SVDJob","enum "],
["lapack","GSVDJob specifies the singular vector computation type for Generalized SingularV","lapack.html#GSVDJob","enum "],
["lapack","EigenVectorsComp specifies how eigenvectors are computed in Dsteqr.","lapack.html#EigenVectorsComp","enum "],
["lapack","EigenVectorsJob specifies whether eigenvectors are computed in Dsyev.","lapack.html#EigenVectorsJob","enum "],
["lapack","LeftEigenVectorsJob specifies whether left eigenvectors are computed in Dgeev.","lapack.html#LeftEigenVectorsJob","enum "],
["lapack","RightEigenVectorsJob specifies whether right eigenvectors are computed in Dgeev.","lapack.html#RightEigenVectorsJob","enum "],
["lapack","BalanceJob specifies matrix balancing operation.","lapack.html#BalanceJob","enum "],
["lapack","SchurJob specifies whether the Schur form is computed in Dhseqr.","lapack.html#SchurJob","enum "],
["lapack","SchurComp specifies whether and how the Schur vectors are computed in Dhseqr.","lapack.html#SchurComp","enum "],
["lapack","UpdateSchurComp specifies whether the matrix of Schur vectors is updated in Dtre","lapack.html#UpdateSchurComp","enum "],
["lapack","EigenVectorsSide specifies what eigenvectors are computed in Dtrevc3.","lapack.html#EigenVectorsSide","enum "],
["lapack","EigenVectorsHowMany specifies which eigenvectors are computed in Dtrevc3 and how","lapack.html#EigenVectorsHowMany","enum "],
["lapack","MaximizeNormXJob specifies the heuristic method for computing a contribution to ","lapack.html#MaximizeNormXJob","enum "],
["lapack","OrthoComp specifies whether and how the orthogonal matrix is computed in Dgghrd.","lapack.html#OrthoComp","enum "],
["lapack","Convert VSL Direct to lapack64.Direct","lapack.html#to_lapack64_direct","fn "],
["lapack","Convert lapack64.Direct to VSL Direct","lapack.html#from_lapack64_direct","fn "],
["lapack","Convert VSL Sort to lapack64.Sort","lapack.html#to_lapack64_sort","fn "],
["lapack","Convert lapack64.Sort to VSL Sort","lapack.html#from_lapack64_sort","fn "],
["lapack","Convert VSL StoreV to lapack64.StoreV","lapack.html#to_lapack64_storev","fn "],
["lapack","Convert lapack64.StoreV to VSL StoreV","lapack.html#from_lapack64_storev","fn "],
["lapack","Convert VSL MatrixNorm to lapack64.MatrixNorm","lapack.html#to_lapack64_matrix_norm","fn "],
["lapack","Convert lapack64.MatrixNorm to VSL MatrixNorm","lapack.html#from_lapack64_matrix_norm","fn "],
["lapack","Convert VSL MatrixType to lapack64.MatrixType","lapack.html#to_lapack64_matrix_type","fn "],
["lapack","Convert lapack64.MatrixType to VSL MatrixType","lapack.html#from_lapack64_matrix_type","fn "],
["lapack","Convert VSL Pivot to lapack64.Pivot","lapack.html#to_lapack64_pivot","fn "],
["lapack","Convert lapack64.Pivot to VSL Pivot","lapack.html#from_lapack64_pivot","fn "],
["lapack","Convert VSL ApplyOrtho to lapack64.ApplyOrtho","lapack.html#to_lapack64_apply_ortho","fn "],
["lapack","Convert lapack64.ApplyOrtho to VSL ApplyOrtho","lapack.html#from_lapack64_apply_ortho","fn "],
["lapack","Convert VSL GenOrtho to lapack64.GenOrtho","lapack.html#to_lapack64_gen_ortho","fn "],
["lapack","Convert lapack64.GenOrtho to VSL GenOrtho","lapack.html#from_lapack64_gen_ortho","fn "],
["lapack","Convert VSL SVDJob to lapack64.SVDJob","lapack.html#to_lapack64_svd_job","fn "],
["lapack","Convert lapack64.SVDJob to VSL SVDJob","lapack.html#from_lapack64_svd_job","fn "],
["lapack","Convert VSL GSVDJob to lapack64.GSVDJob","lapack.html#to_lapack64_gsvd_job","fn "],
["lapack","Convert lapack64.GSVDJob to VSL GSVDJob","lapack.html#from_lapack64_gsvd_job","fn "],
["lapack","Convert VSL EigenVectorsComp to lapack64.EigenVectorsComp","lapack.html#to_lapack64_eigen_vectors_comp","fn "],
["lapack","Convert lapack64.EigenVectorsComp to VSL EigenVectorsComp","lapack.html#from_lapack64_eigen_vectors_comp","fn "],
["lapack","Convert VSL EigenVectorsJob to lapack64.EigenVectorsJob","lapack.html#to_lapack64_eigen_vectors_job","fn "],
["lapack","Convert lapack64.EigenVectorsJob to VSL EigenVectorsJob","lapack.html#from_lapack64_eigen_vectors_job","fn "],
["lapack","Convert VSL LeftEigenVectorsJob to lapack64.LeftEigenVectorsJob","lapack.html#to_lapack64_left_eigen_vectors_job","fn "],
["lapack","Convert lapack64.LeftEigenVectorsJob to VSL LeftEigenVectorsJob","lapack.html#from_lapack64_left_eigen_vectors_job","fn "],
["lapack","Convert VSL RightEigenVectorsJob to lapack64.RightEigenVectorsJob","lapack.html#to_lapack64_right_eigen_vectors_job","fn "],
["lapack","Convert lapack64.RightEigenVectorsJob to VSL RightEigenVectorsJob","lapack.html#from_lapack64_right_eigen_vectors_job","fn "],
["lapack","Convert VSL BalanceJob to lapack64.BalanceJob","lapack.html#to_lapack64_balance_job","fn "],
["lapack","Convert lapack64.BalanceJob to VSL BalanceJob","lapack.html#from_lapack64_balance_job","fn "],
["lapack","Convert VSL SchurJob to lapack64.SchurJob","lapack.html#to_lapack64_schur_job","fn "],
["lapack","Convert lapack64.SchurJob to VSL SchurJob","lapack.html#from_lapack64_schur_job","fn "],
["lapack","Convert VSL SchurComp to lapack64.SchurComp","lapack.html#to_lapack64_schur_comp","fn "],
["lapack","Convert lapack64.SchurComp to VSL SchurComp","lapack.html#from_lapack64_schur_comp","fn "],
["lapack","Convert VSL UpdateSchurComp to lapack64.UpdateSchurComp","lapack.html#to_lapack64_update_schur_comp","fn "],
["lapack","Convert lapack64.UpdateSchurComp to VSL UpdateSchurComp","lapack.html#from_lapack64_update_schur_comp","fn "],
["lapack","Convert VSL EigenVectorsSide to lapack64.EigenVectorsSide","lapack.html#to_lapack64_eigen_vectors_side","fn "],
["lapack","Convert lapack64.EigenVectorsSide to VSL EigenVectorsSide","lapack.html#from_lapack64_eigen_vectors_side","fn "],
["lapack","Convert VSL EigenVectorsHowMany to lapack64.EigenVectorsHowMany","lapack.html#to_lapack64_eigen_vectors_how_many","fn "],
["lapack","Convert lapack64.EigenVectorsHowMany to VSL EigenVectorsHowMany","lapack.html#from_lapack64_eigen_vectors_how_many","fn "],
["lapack","Convert VSL MaximizeNormXJob to lapack64.MaximizeNormXJob","lapack.html#to_lapack64_maximize_norm_x_job","fn "],
["lapack","Convert lapack64.MaximizeNormXJob to VSL MaximizeNormXJob","lapack.html#from_lapack64_maximize_norm_x_job","fn "],
["lapack","Convert VSL OrthoComp to lapack64.OrthoComp","lapack.html#to_lapack64_ortho_comp","fn "],
["lapack","Convert lapack64.OrthoComp to VSL OrthoComp","lapack.html#from_lapack64_ortho_comp","fn "],
["lapack","dgesv computes the solution to a real system of linear equations.","lapack.html#dgesv","fn "],
["lapack","dgesvd computes the singular value decomposition (SingularValueDecomposition) of","lapack.html#dgesvd","fn "],
["lapack","dgetrf computes an LU factorization of a general M-by-N matrix A using partial p","lapack.html#dgetrf","fn "],
["lapack","dgetri computes the inverse of a matrix using the LU factorization computed by D","lapack.html#dgetri","fn "],
["lapack","dpotrf computes the Cholesky factorization of a real symmetric positive definite","lapack.html#dpotrf","fn "],
["lapack","dgeev computes for an N-by-N real nonsymmetric matrix A, the eigenvalues and, op","lapack.html#dgeev","fn "],
["lapack","dpotrf_standardized - Standardized dpotrf wrapper","lapack.html#dpotrf_standardized","fn "],
["lapack","dsyev_standardized - Standardized dsyev wrapper","lapack.html#dsyev_standardized","fn "],
["lapack","dgeev_standardized - Standardized dgeev wrapper","lapack.html#dgeev_standardized","fn "],
["lapack","dgeqrf_standardized - Standardized dgeqrf wrapper (placeholder until implemented","lapack.html#dgeqrf_standardized","fn "],
["lapack","dorgqr_standardized - Standardized dorgqr wrapper","lapack.html#dorgqr_standardized","fn "],
["lapack","dsyev - Direct wrapper for dsyev with standardized interface","lapack.html#dsyev","fn "],
["lapack","dgeqrf - Direct wrapper for dgeqrf with standardized interface","lapack.html#dgeqrf","fn "],
["lapack","dorgqr - Direct wrapper for dorgqr with standardized interface","lapack.html#dorgqr","fn "],
["lapack","gesv solves the linear system A*X = B using LU factorization with partial pivoti","lapack.html#gesv","fn "],
["lapack","getrf computes the LU factorization of a general m√ón matrix A using partial piv","lapack.html#getrf","fn "],
["lapack","getri computes the inverse of a matrix using the LU factorization computed by ge","lapack.html#getri","fn "],
["lapack","potrf computes the Cholesky factorization of a symmetric positive definite matri","lapack.html#potrf","fn "],
["lapack","geqrf computes a QR factorization of a real m√ón matrix A.","lapack.html#geqrf","fn "],
["lapack","orgqr generates the m√ón matrix Q with orthonormal columns defined as the first ","lapack.html#orgqr","fn "],
["lapack","geev computes the eigenvalues and, optionally, the left and/or right eigenvector","lapack.html#geev","fn "],
["lapack","syev computes all eigenvalues and, optionally, eigenvectors of a real symmetric ","lapack.html#syev","fn "],
["lapack","gesvd computes the singular value decomposition (SVD) of a real m√ón matrix A.","lapack.html#gesvd","fn "],
["lapack","","lapack.html#dlange","fn "],
["lapack.lapack64","Direct specifies the direction of the multiplication for the Householder matrix.","lapack.lapack64.html#Direct","enum "],
["lapack.lapack64","Sort is the sorting order.","lapack.lapack64.html#Sort","enum "],
["lapack.lapack64","StoreV indicates the storage direction of elementary reflectors.","lapack.lapack64.html#StoreV","enum "],
["lapack.lapack64","MatrixNorm represents the kind of matrix norm to compute.","lapack.lapack64.html#MatrixNorm","enum "],
["lapack.lapack64","MatrixType represents the kind of matrix represented in the data.","lapack.lapack64.html#MatrixType","enum "],
["lapack.lapack64","Pivot specifies the pivot type for plane rotations.","lapack.lapack64.html#Pivot","enum "],
["lapack.lapack64","ApplyOrtho specifies which orthogonal matrix is applied in Dormbr.","lapack.lapack64.html#ApplyOrtho","enum "],
["lapack.lapack64","GenOrtho specifies which orthogonal matrix is generated in Dorgbr.","lapack.lapack64.html#GenOrtho","enum "],
["lapack.lapack64","SVDJob specifies the singular vector computation type for SingularValueDecomposi","lapack.lapack64.html#SVDJob","enum "],
["lapack.lapack64","GSVDJob specifies the singular vector computation type for Generalized SingularV","lapack.lapack64.html#GSVDJob","enum "],
["lapack.lapack64","EigenVectorsComp specifies how eigenvectors are computed in Dsteqr.","lapack.lapack64.html#EigenVectorsComp","enum "],
["lapack.lapack64","EigenVectorsJob specifies whether eigenvectors are computed in Dsyev.","lapack.lapack64.html#EigenVectorsJob","enum "],
["lapack.lapack64","LeftEigenVectorsJob specifies whether left eigenvectors are computed in Dgeev.","lapack.lapack64.html#LeftEigenVectorsJob","enum "],
["lapack.lapack64","RightEigenVectorsJob specifies whether right eigenvectors are computed in Dgeev.","lapack.lapack64.html#RightEigenVectorsJob","enum "],
["lapack.lapack64","BalanceJob specifies matrix balancing operation.","lapack.lapack64.html#BalanceJob","enum "],
["lapack.lapack64","SchurJob specifies whether the Schur form is computed in Dhseqr.","lapack.lapack64.html#SchurJob","enum "],
["lapack.lapack64","SchurComp specifies whether and how the Schur vectors are computed in Dhseqr.","lapack.lapack64.html#SchurComp","enum "],
["lapack.lapack64","UpdateSchurComp specifies whether the matrix of Schur vectors is updated in Dtre","lapack.lapack64.html#UpdateSchurComp","enum "],
["lapack.lapack64","EigenVectorsSide specifies what eigenvectors are computed in Dtrevc3.","lapack.lapack64.html#EigenVectorsSide","enum "],
["lapack.lapack64","EigenVectorsHowMany specifies which eigenvectors are computed in Dtrevc3 and how","lapack.lapack64.html#EigenVectorsHowMany","enum "],
["lapack.lapack64","MaximizeNormXJob specifies the heuristic method for computing a contribution to ","lapack.lapack64.html#MaximizeNormXJob","enum "],
["lapack.lapack64","OrthoComp specifies whether and how the orthogonal matrix is computed in Dgghrd.","lapack.lapack64.html#OrthoComp","enum "],
["lapack.lapack64","dgebal balances an n√ón matrix A. Balancing consists of two stages, permuting an","lapack.lapack64.html#dgebal","fn "],
["lapack.lapack64","dgeev: minimal real 2x2 eigen solver (row-major input/output for this pure-V pat","lapack.lapack64.html#dgeev","fn "],
["lapack.lapack64","dgehrd reduces a general real matrix A to upper Hessenberg form H by an orthogon","lapack.lapack64.html#dgehrd","fn "],
["lapack.lapack64","dgeqr2 computes a QR factorization of the m√ón matrix A.","lapack.lapack64.html#dgeqr2","fn "],
["lapack.lapack64","dgeqrf computes the QR factorization of the m√ón matrix A using a blocked algori","lapack.lapack64.html#dgeqrf","fn "],
["lapack.lapack64","dgesv computes the solution to a real system of linear equations","lapack.lapack64.html#dgesv","fn "],
["lapack.lapack64","dgesvd computes the singular value decomposition (SingularValueDecomposition) of","lapack.lapack64.html#dgesvd","fn "],
["lapack.lapack64","","lapack.lapack64.html#dgetf2","fn "],
["lapack.lapack64","dgetrf computes the LU decomposition of an m√ón matrix A using partial pivoting ","lapack.lapack64.html#dgetrf","fn "],
["lapack.lapack64","dgetri computes the inverse of the matrix A using the LU factorization computed ","lapack.lapack64.html#dgetri","fn "],
["lapack.lapack64","dgetrs solves a system of equations using an LU factorization. The system of equ","lapack.lapack64.html#dgetrs","fn "],
["lapack.lapack64","dlacpy copies the elements of A specified by uplo into B. Uplo can specify a tri","lapack.lapack64.html#dlacpy","fn "],
["lapack.lapack64","dlae2 computes the eigenvalues of a 2√ó2 symmetric matrix","lapack.lapack64.html#dlae2","fn "],
["lapack.lapack64","","lapack.lapack64.html#dlaev2","fn "],
["lapack.lapack64","dlange returns the value of the specified norm of a general m√ón matrix A:","lapack.lapack64.html#dlange","fn "],
["lapack.lapack64","dlanst computes the specified norm of a symmetric tridiagonal matrix A. The diag","lapack.lapack64.html#dlanst","fn "],
["lapack.lapack64","dlansy returns the value of the specified norm of an n√ón symmetric matrix. If n","lapack.lapack64.html#dlansy","fn "],
["lapack.lapack64","dlapy2 is the LAPACK version of math.hypot.","lapack.lapack64.html#dlapy2","fn "],
["lapack.lapack64","dlarf applies an elementary reflector H to an m√ón matrix C:","lapack.lapack64.html#dlarf","fn "],
["lapack.lapack64","","lapack.lapack64.html#dlarfb","fn "],
["lapack.lapack64","","lapack.lapack64.html#dlarfg","fn "],
["lapack.lapack64","dlarft forms the triangular factor T of a block reflector H, storing the answer ","lapack.lapack64.html#dlarft","fn "],
["lapack.lapack64","dlartg generates a plane rotation so that","lapack.lapack64.html#dlartg","fn "],
["lapack.lapack64","dlascl multiplies an m√ón matrix by the scalar cto/cfrom.","lapack.lapack64.html#dlascl","fn "],
["lapack.lapack64","dlaset sets the off-diagonal elements of A to alpha, and the diagonal elements t","lapack.lapack64.html#dlaset","fn "],
["lapack.lapack64","Dlasr applies a sequence of plane rotations to the m√ón matrix A. This series of","lapack.lapack64.html#dlasr","fn "],
["lapack.lapack64","dlasrt sorts the numbers in the input slice d. If s == .increasing, the elements","lapack.lapack64.html#dlasrt","fn "],
["lapack.lapack64","dlassq updates a sum of squares represented in scaled form. It returns the value","lapack.lapack64.html#dlassq","fn "],
["lapack.lapack64","","lapack.lapack64.html#dlaswp","fn "],
["lapack.lapack64","","lapack.lapack64.html#dlatrd","fn "],
["lapack.lapack64","dorg2l generates an m√ón matrix Q with orthonormal columns which is defined as t","lapack.lapack64.html#dorg2l","fn "],
["lapack.lapack64","","lapack.lapack64.html#dorg2r","fn "],
["lapack.lapack64","dorgql generates the m√ón matrix Q with orthonormal columns defined as the last ","lapack.lapack64.html#dorgql","fn "],
["lapack.lapack64","","lapack.lapack64.html#dorgqr","fn "],
["lapack.lapack64","dorgtr generates a real orthogonal matrix Q which is defined as the product of n","lapack.lapack64.html#dorgtr","fn "],
["lapack.lapack64","dpotf2 computes the Cholesky decomposition of the symmetric positive definite ma","lapack.lapack64.html#dpotf2","fn "],
["lapack.lapack64","","lapack.lapack64.html#dpotrf","fn "],
["lapack.lapack64","dsteqr computes the eigenvalues and optionally the eigenvectors of a symmetric t","lapack.lapack64.html#dsteqr","fn "],
["lapack.lapack64","dsterf computes all eigenvalues of a symmetric tridiagonal matrix using the Pal-","lapack.lapack64.html#dsterf","fn "],
["lapack.lapack64","","lapack.lapack64.html#dsyev","fn "],
["lapack.lapack64","Dsytd2 reduces a symmetric n√ón matrix A to symmetric tridiagonal form T by an o","lapack.lapack64.html#dsytd2","fn "],
["lapack.lapack64","dsytrd reduces a symmetric n√ón matrix A to symmetric tridiagonal form by an ort","lapack.lapack64.html#dsytrd","fn "],
["lapack.lapack64","dtrti2 computes the inverse of a triangular matrix, storing the result in place ","lapack.lapack64.html#dtrti2","fn "],
["lapack.lapack64","dtrtri computes the inverse of a triangular matrix, storing the result in place ","lapack.lapack64.html#dtrtri","fn "],
["lapack.lapack64","iladlc scans a matrix for its last non-zero column. Returns -1 if the matrix is ","lapack.lapack64.html#iladlc","fn "],
["lapack.lapack64","iladlr scans a matrix for its last non-zero row. Returns -1 if the matrix is all","lapack.lapack64.html#iladlr","fn "],
["ml","","ml.html#Data","struct "],
["ml","Data.new returns a new object to hold ML data Input: nb_samples  -- number of da","ml.html#Data.new","fn "],
["ml","","ml.html#Data[T]","type "],
["ml","set sets x matrix and y vector [optional] and notify observers Input: x -- x val","ml.html#Data[T].set","fn (Data[T])"],
["ml","","ml.html#Data[T].set_y","fn (Data[T])"],
["ml","","ml.html#Data[T].set_x","fn (Data[T])"],
["ml","clone returns a deep copy of this object removing the observers","ml.html#Data[T].clone","fn (Data[T])"],
["ml","clone_with_same_x returns a deep copy of this object, but with the same referenc","ml.html#Data[T].clone_with_same_x","fn (Data[T])"],
["ml","add_observer adds an object to the list of interested observers","ml.html#Data[T].add_observer","fn (Data[T])"],
["ml","notify_update notifies observers of updates","ml.html#Data[T].notify_update","fn (Data[T])"],
["ml","split returns a new object with data split into two parts Input: ratio -- ratio ","ml.html#Data[T].split","fn (Data[T])"],
["ml","Data.from_raw_x returns a new object with data set from raw x values Input: xraw","ml.html#Data.from_raw_x","fn "],
["ml","Data.from_raw_xy_sep accepts two parameters: xraw [][]T and yraw []T. It acts si","ml.html#Data.from_raw_xy_sep","fn "],
["ml","Data.from_raw_xy returns a new object with data set from raw Xy values Input: Xy","ml.html#Data.from_raw_xy","fn "],
["ml","Kmeans implements the K-means model (Observer of Data)","ml.html#Kmeans","struct "],
["ml","name returns the name of this Kmeans object (thus defining the Observer interfac","ml.html#Kmeans.name","fn (Kmeans)"],
["ml","update perform updates after data has been changed (as an Observer)","ml.html#Kmeans.update","fn (Kmeans)"],
["ml","nb_classes returns the number of classes","ml.html#Kmeans.nb_classes","fn (Kmeans)"],
["ml","set_centroids sets centroids; e.g. trial centroids xc -- [nb_class][nb_features]","ml.html#Kmeans.set_centroids","fn (Kmeans)"],
["ml","find_closest_centroids finds closest centroids to each sample","ml.html#Kmeans.find_closest_centroids","fn (Kmeans)"],
["ml","compute_centroids update centroids based on new classes information (from find_c","ml.html#Kmeans.compute_centroids","fn (Kmeans)"],
["ml","train trains model","ml.html#Kmeans.train","fn (Kmeans)"],
["ml","str is a custom str function for observers to avoid printing data","ml.html#Kmeans.str","fn (Kmeans)"],
["ml","get_plotter returns a plot.Plot struct for plotting","ml.html#Kmeans.get_plotter","fn (Kmeans)"],
["ml","Kmeans.new returns a new K-means model","ml.html#Kmeans.new","fn "],
["ml","","ml.html#TrainConfig","struct "],
["ml","KNN is the struct defining a K-Nearest Neighbors classifier.","ml.html#KNN","struct "],
["ml","name returns the name of this KNN object (thus defining the Observer interface)","ml.html#KNN.name","fn (KNN)"],
["ml","set_weights will set the weights for the KNN. They default to 1.0 for every clas","ml.html#KNN.set_weights","fn (KNN)"],
["ml","update perform updates after data has been changed (as an Observer)","ml.html#KNN.update","fn (KNN)"],
["ml","train computes the neighbors and weights during training","ml.html#KNN.train","fn (KNN)"],
["ml","predict will find the `k` points nearest to the specified `to_pred`. If the valu","ml.html#KNN.predict","fn (KNN)"],
["ml","str is a custom str function for observers to avoid printing data","ml.html#KNN.str","fn (KNN)"],
["ml","get_plotter returns a plot.Plot struct with the data needed to plot the KNN mode","ml.html#KNN.get_plotter","fn (KNN)"],
["ml","KNN.new accepts a `vml.ml.Data` parameter called `data`, that will be used to pr","ml.html#KNN.new","fn "],
["ml","data needed for KNN.predict","ml.html#PredictConfig","struct "],
["ml","LinReg implements a linear regression model","ml.html#LinReg","struct "],
["ml","name returns the name of this LinReg object (thus defining the Observer interfac","ml.html#LinReg.name","fn (LinReg)"],
["ml","predict returns the model evaluation @ {x;theta,b} Input: x -- vector of feature","ml.html#LinReg.predict","fn (LinReg)"],
["ml","cost returns the cost c(x;theta,b) Input: data -- x,y data params -- theta and b","ml.html#LinReg.cost","fn (LinReg)"],
["ml","gradients returns ‚àÇC/‚àÇtheta and ‚àÇC/‚àÇb Output: dcdtheta -- ‚àÇC/‚àÇtheta ","ml.html#LinReg.gradients","fn (LinReg)"],
["ml","train finds theta and b using closed-form solution Input: data -- x,y data Outpu","ml.html#LinReg.train","fn (LinReg)"],
["ml","calce calculates e vector (save into o.e) Output: e = b‚ãÖo + x‚ãÖtheta - y","ml.html#LinReg.calce","fn (LinReg)"],
["ml","str is a custom str function for observers to avoid printing data","ml.html#LinReg.str","fn (LinReg)"],
["ml","get_plotter returns a plot.Plot struct for plotting the data and the linear regr","ml.html#LinReg.get_plotter","fn (LinReg)"],
["ml","LinReg.new returns a new LinReg object Input: data   -- x,y data name   -- uniqu","ml.html#LinReg.new","fn "],
["ml","","ml.html#ParamsReg","struct "],
["ml","ParamsReg.new returns a new object to hold regression parameters","ml.html#ParamsReg.new","fn "],
["ml","","ml.html#ParamsReg[T]","type "],
["ml","init initializes ParamsReg with nb_features (number of features)","ml.html#ParamsReg[T].init","fn (ParamsReg[T])"],
["ml","backup creates an internal copy of parameters","ml.html#ParamsReg[T].backup","fn (ParamsReg[T])"],
["ml","restore restores an internal copy of parameters and notifies observers","ml.html#ParamsReg[T].restore","fn (ParamsReg[T])"],
["ml","set_params sets theta and b and notifies observers","ml.html#ParamsReg[T].set_params","fn (ParamsReg[T])"],
["ml","set_param sets either theta or b (use negative indices for b). Notifies observer","ml.html#ParamsReg[T].set_param","fn (ParamsReg[T])"],
["ml","get_param returns either theta or b (use negative indices for b) i -- index of t","ml.html#ParamsReg[T].get_param","fn (ParamsReg[T])"],
["ml","set_thetas sets the whole vector theta and notifies observers","ml.html#ParamsReg[T].set_thetas","fn (ParamsReg[T])"],
["ml","get_thetas gets a copy of theta","ml.html#ParamsReg[T].get_thetas","fn (ParamsReg[T])"],
["ml","access_thetas returns access (slice) to theta","ml.html#ParamsReg[T].access_thetas","fn (ParamsReg[T])"],
["ml","access_bias returns access (pointer) to b","ml.html#ParamsReg[T].access_bias","fn (ParamsReg[T])"],
["ml","set_theta sets one component of theta and notifies observers","ml.html#ParamsReg[T].set_theta","fn (ParamsReg[T])"],
["ml","get_theta returns the value of theta[i]","ml.html#ParamsReg[T].get_theta","fn (ParamsReg[T])"],
["ml","set_bias sets b and notifies observers","ml.html#ParamsReg[T].set_bias","fn (ParamsReg[T])"],
["ml","get_bias gets a copy of b","ml.html#ParamsReg[T].get_bias","fn (ParamsReg[T])"],
["ml","set_lambda sets lambda and notifies observers","ml.html#ParamsReg[T].set_lambda","fn (ParamsReg[T])"],
["ml","get_lambda gets a copy of lambda","ml.html#ParamsReg[T].get_lambda","fn (ParamsReg[T])"],
["ml","set_degree sets p and notifies observers","ml.html#ParamsReg[T].set_degree","fn (ParamsReg[T])"],
["ml","get_degree gets a copy of p","ml.html#ParamsReg[T].get_degree","fn (ParamsReg[T])"],
["ml","add_observer adds an object to the list of interested observers","ml.html#ParamsReg[T].add_observer","fn (ParamsReg[T])"],
["ml","notify_update notifies observers of updates","ml.html#ParamsReg[T].notify_update","fn (ParamsReg[T])"],
["ml","Stat holds statistics about data","ml.html#Stat","struct "],
["ml","stat returns a new Stat object","ml.html#Stat.from_data","fn "],
["ml","","ml.html#Stat[T]","type "],
["ml","name returns the name of this stat object (thus defining the Observer interface)","ml.html#Stat[T].name","fn (Stat[T])"],
["ml","update compute statistics for given data (an Observer of Data)","ml.html#Stat[T].update","fn (Stat[T])"],
["ml","sum_vars computes the sums along the columns of X and y Output: t -- scalar t = ","ml.html#Stat[T].sum_vars","fn (Stat[T])"],
["ml","copy_into copies stat into p","ml.html#Stat[T].copy_into","fn (Stat[T])"],
["ml","str is a custom str function for observers to avoid printing data","ml.html#Stat[T].str","fn (Stat[T])"],
["ml.nlp","most_frequent_ngrams returns an array with up to `n_features` elements denoting ","ml.nlp.html#most_frequent_ngrams","fn "],
["ml.nlp","count_vectorize will give you an array of occurrences of each ngram from `ngrams","ml.nlp.html#count_vectorize","fn "],
["ml.nlp","All credits go to the respective authors of NLTK's LancasterStemmer implementati","ml.nlp.html#LancasterStemmer","struct "],
["ml.nlp","set_rules redefines the rules of stemmer and parses it.","ml.nlp.html#LancasterStemmer.set_rules","fn (LancasterStemmer)"],
["ml.nlp","stem serves as a wrapper for do_stemming, which is private.","ml.nlp.html#LancasterStemmer.stem","fn (LancasterStemmer)"],
["ml.nlp","LancasterStemmer.new returns a LancasterStemmer struct with a predefined set of ","ml.nlp.html#LancasterStemmer.new","fn "],
["ml.nlp","term_frequencies will return the frequency of each term in a sentence. However, ","ml.nlp.html#term_frequencies","fn "],
["ml.nlp","inverse_document_frequencies will return the IDF of each term by calling `term_i","ml.nlp.html#inverse_document_frequencies","fn "],
["ml.nlp","term_idf will return the IDF of a single term `term`. However, since in VSL NLP ","ml.nlp.html#term_idf","fn "],
["ml.nlp","tf_idf will return the TF * IDF for any given ngram, in a sentence, in a documen","ml.nlp.html#tf_idf","fn "],
["ml.nlp","remove_punctuation will remove the following characters from the string: `,.[]()","ml.nlp.html#remove_punctuation","fn "],
["ml.nlp","tokenize will return an array of tokens from the string `x`.","ml.nlp.html#tokenize","fn "],
["ml.nlp","remove_stopwords will remove all tokens included in `stopwords`. If `ignore_case","ml.nlp.html#remove_stopwords","fn "],
["ml.nlp","remove_stopwords_en is a wrapper for `remove_stopwords`, passing a default array","ml.nlp.html#remove_stopwords_en","fn "],
["ml.nlp","ngrams will return an array of grams containing `n` elements from `tokens`. Exam","ml.nlp.html#ngrams","fn "],
["mpi","is_on tells whether MPI is on or not","mpi.html#is_on","fn "],
["mpi","initialize readies MPI for use","mpi.html#initialize","fn "],
["mpi","initialise readies MPI for use","mpi.html#initialise","fn "],
["mpi","start_thread_safe initialises MPI in a thread safe way","mpi.html#start_thread_safe","fn "],
["mpi","finalize MPI","mpi.html#finalize","fn "],
["mpi","world_rank returns the processor rank within the World Communicator","mpi.html#world_rank","fn "],
["mpi","world_size returns the number of processors in the World Communicator","mpi.html#world_size","fn "],
["mpi","Communicator holds the World Communicator or a subset Communicator","mpi.html#Communicator","struct "],
["mpi","rank returns the processor rank","mpi.html#Communicator.rank","fn (Communicator)"],
["mpi","size returns the number of processors","mpi.html#Communicator.size","fn (Communicator)"],
["mpi","abort aborts MPI","mpi.html#Communicator.abort","fn (Communicator)"],
["mpi","barrier forces synchronisation","mpi.html#Communicator.barrier","fn (Communicator)"],
["mpi","send_i32 sends values to processor to_rank","mpi.html#Communicator.send_i32","fn (Communicator)"],
["mpi","recv_i32 receives values from processor from_rank","mpi.html#Communicator.recv_i32","fn (Communicator)"],
["mpi","send_u32 sends values to processor to_rank","mpi.html#Communicator.send_u32","fn (Communicator)"],
["mpi","recv_u32 receives values from processor from_rank","mpi.html#Communicator.recv_u32","fn (Communicator)"],
["mpi","send_i64 sends values to processor to_rank","mpi.html#Communicator.send_i64","fn (Communicator)"],
["mpi","recv_i64 receives values from processor from_rank","mpi.html#Communicator.recv_i64","fn (Communicator)"],
["mpi","send_u64 sends values to processor to_rank","mpi.html#Communicator.send_u64","fn (Communicator)"],
["mpi","recv_u64 receives values from processor from_rank","mpi.html#Communicator.recv_u64","fn (Communicator)"],
["mpi","send_f32 sends values to processor to_rank","mpi.html#Communicator.send_f32","fn (Communicator)"],
["mpi","recv_f32 receives values from processor from_rank","mpi.html#Communicator.recv_f32","fn (Communicator)"],
["mpi","send_f64 sends values to processor to_rank","mpi.html#Communicator.send_f64","fn (Communicator)"],
["mpi","recv_f64 receives values from processor from_rank","mpi.html#Communicator.recv_f64","fn (Communicator)"],
["mpi","send_one_i32 sends one value to processor to_rank","mpi.html#Communicator.send_one_i32","fn (Communicator)"],
["mpi","recv_one_i32 receives one value from processor from_rank","mpi.html#Communicator.recv_one_i32","fn (Communicator)"],
["mpi","send_one_u32 sends one value to processor to_rank","mpi.html#Communicator.send_one_u32","fn (Communicator)"],
["mpi","recv_one_u32 receives one value from processor from_rank","mpi.html#Communicator.recv_one_u32","fn (Communicator)"],
["mpi","send_one_i64 sends one value to processor to_rank","mpi.html#Communicator.send_one_i64","fn (Communicator)"],
["mpi","recv_one_i64 receives one value from processor from_rank","mpi.html#Communicator.recv_one_i64","fn (Communicator)"],
["mpi","send_one_u64 sends one value to processor to_rank","mpi.html#Communicator.send_one_u64","fn (Communicator)"],
["mpi","recv_one_u64 receives one value from processor from_rank","mpi.html#Communicator.recv_one_u64","fn (Communicator)"],
["mpi","send_one_f32 sends one value to processor to_rank","mpi.html#Communicator.send_one_f32","fn (Communicator)"],
["mpi","recv_one_f32 receives one value from processor from_rank","mpi.html#Communicator.recv_one_f32","fn (Communicator)"],
["mpi","send_one_f64 sends one value to processor to_rank","mpi.html#Communicator.send_one_f64","fn (Communicator)"],
["mpi","recv_one_f64 receives one value from processor from_rank","mpi.html#Communicator.recv_one_f64","fn (Communicator)"],
["mpi","bcast_from_root_i32 broadcasts slice x from root (Rank == 0) to all other proces","mpi.html#Communicator.bcast_from_root_i32","fn (Communicator)"],
["mpi","bcast_from_root_u32 broadcasts slice x from root (Rank == 0) to all other proces","mpi.html#Communicator.bcast_from_root_u32","fn (Communicator)"],
["mpi","bcast_from_root_i64 broadcasts slice x from root (Rank == 0) to all other proces","mpi.html#Communicator.bcast_from_root_i64","fn (Communicator)"],
["mpi","bcast_from_root_u64 broadcasts slice x from root (Rank == 0) to all other proces","mpi.html#Communicator.bcast_from_root_u64","fn (Communicator)"],
["mpi","bcast_from_root_f32 broadcasts slice x from root (Rank == 0) to all other proces","mpi.html#Communicator.bcast_from_root_f32","fn (Communicator)"],
["mpi","bcast_from_root_f64 broadcasts slice x from root (Rank == 0) to all other proces","mpi.html#Communicator.bcast_from_root_f64","fn (Communicator)"],
["mpi","reduce_sum_i32 sums all values in 'orig' to 'dest' in root (Rank == 0) processor","mpi.html#Communicator.reduce_sum_i32","fn (Communicator)"],
["mpi","all_reduce_sum_i32 combines all values from orig into dest summing values note (","mpi.html#Communicator.all_reduce_sum_i32","fn (Communicator)"],
["mpi","reduce_min_i32 minimizes all values in 'orig' to 'dest' in root (Rank == 0) proc","mpi.html#Communicator.reduce_min_i32","fn (Communicator)"],
["mpi","all_reduce_min_i32 minimizes all values from orig into all dest values note (imp","mpi.html#Communicator.all_reduce_min_i32","fn (Communicator)"],
["mpi","reduce_max_i32 maximizes all values in 'orig' to 'dest' in root (Rank == 0) proc","mpi.html#Communicator.reduce_max_i32","fn (Communicator)"],
["mpi","all_reduce_max_i32 maximizes all values from orig into all dest values note (imp","mpi.html#Communicator.all_reduce_max_i32","fn (Communicator)"],
["mpi","reduce_sum_u32 sums all values in 'orig' to 'dest' in root (Rank == 0) processor","mpi.html#Communicator.reduce_sum_u32","fn (Communicator)"],
["mpi","all_reduce_sum_u32 combines all values from orig into dest summing values note (","mpi.html#Communicator.all_reduce_sum_u32","fn (Communicator)"],
["mpi","reduce_min_u32 minimizes all values in 'orig' to 'dest' in root (Rank == 0) proc","mpi.html#Communicator.reduce_min_u32","fn (Communicator)"],
["mpi","all_reduce_min_u32 minimizes all values from orig into all dest values note (imp","mpi.html#Communicator.all_reduce_min_u32","fn (Communicator)"],
["mpi","reduce_max_u32 maximizes all values in 'orig' to 'dest' in root (Rank == 0) proc","mpi.html#Communicator.reduce_max_u32","fn (Communicator)"],
["mpi","all_reduce_max_u32 maximizes all values from orig into all dest values note (imp","mpi.html#Communicator.all_reduce_max_u32","fn (Communicator)"],
["mpi","reduce_sum_i64 sums all values in 'orig' to 'dest' in root (Rank == 0) processor","mpi.html#Communicator.reduce_sum_i64","fn (Communicator)"],
["mpi","all_reduce_sum_i64 combines all values from orig into dest summing values note (","mpi.html#Communicator.all_reduce_sum_i64","fn (Communicator)"],
["mpi","reduce_min_i64 minimizes all values in 'orig' to 'dest' in root (Rank == 0) proc","mpi.html#Communicator.reduce_min_i64","fn (Communicator)"],
["mpi","all_reduce_min_i64 minimizes all values from orig into all dest values note (imp","mpi.html#Communicator.all_reduce_min_i64","fn (Communicator)"],
["mpi","reduce_max_i64 maximizes all values in 'orig' to 'dest' in root (Rank == 0) proc","mpi.html#Communicator.reduce_max_i64","fn (Communicator)"],
["mpi","all_reduce_max_i64 maximizes all values from orig into all dest values note (imp","mpi.html#Communicator.all_reduce_max_i64","fn (Communicator)"],
["mpi","reduce_sum_u64 sums all values in 'orig' to 'dest' in root (Rank == 0) processor","mpi.html#Communicator.reduce_sum_u64","fn (Communicator)"],
["mpi","all_reduce_sum_u64 combines all values from orig into dest summing values note (","mpi.html#Communicator.all_reduce_sum_u64","fn (Communicator)"],
["mpi","reduce_min_u64 minimizes all values in 'orig' to 'dest' in root (Rank == 0) proc","mpi.html#Communicator.reduce_min_u64","fn (Communicator)"],
["mpi","all_reduce_min_u64 minimizes all values from orig into all dest values note (imp","mpi.html#Communicator.all_reduce_min_u64","fn (Communicator)"],
["mpi","reduce_max_u64 maximizes all values in 'orig' to 'dest' in root (Rank == 0) proc","mpi.html#Communicator.reduce_max_u64","fn (Communicator)"],
["mpi","all_reduce_max_u64 maximizes all values from orig into all dest values note (imp","mpi.html#Communicator.all_reduce_max_u64","fn (Communicator)"],
["mpi","reduce_sum_f32 sums all values in 'orig' to 'dest' in root (Rank == 0) processor","mpi.html#Communicator.reduce_sum_f32","fn (Communicator)"],
["mpi","all_reduce_sum_f32 combines all values from orig into dest summing values note (","mpi.html#Communicator.all_reduce_sum_f32","fn (Communicator)"],
["mpi","reduce_min_f32 minimizes all values in 'orig' to 'dest' in root (Rank == 0) proc","mpi.html#Communicator.reduce_min_f32","fn (Communicator)"],
["mpi","all_reduce_min_f32 minimizes all values from orig into all dest values note (imp","mpi.html#Communicator.all_reduce_min_f32","fn (Communicator)"],
["mpi","reduce_max_f32 maximizes all values in 'orig' to 'dest' in root (Rank == 0) proc","mpi.html#Communicator.reduce_max_f32","fn (Communicator)"],
["mpi","all_reduce_max_f32 maximizes all values from orig into all dest values note (imp","mpi.html#Communicator.all_reduce_max_f32","fn (Communicator)"],
["mpi","reduce_sum_f64 sums all values in 'orig' to 'dest' in root (Rank == 0) processor","mpi.html#Communicator.reduce_sum_f64","fn (Communicator)"],
["mpi","all_reduce_sum_f64 combines all values from orig into dest summing values note (","mpi.html#Communicator.all_reduce_sum_f64","fn (Communicator)"],
["mpi","reduce_min_f64 minimizes all values in 'orig' to 'dest' in root (Rank == 0) proc","mpi.html#Communicator.reduce_min_f64","fn (Communicator)"],
["mpi","all_reduce_min_f64 minimizes all values from orig into all dest values note (imp","mpi.html#Communicator.all_reduce_min_f64","fn (Communicator)"],
["mpi","reduce_max_f64 maximizes all values in 'orig' to 'dest' in root (Rank == 0) proc","mpi.html#Communicator.reduce_max_f64","fn (Communicator)"],
["mpi","all_reduce_max_f64 maximizes all values from orig into all dest values note (imp","mpi.html#Communicator.all_reduce_max_f64","fn (Communicator)"],
["mpi","Communicator.new creates a new communicator or returns the World Communicator ra","mpi.html#Communicator.new","fn "],
["noise","Generator is a struct holding the permutation table used in perlin and simplex n","noise.html#Generator","struct "],
["noise","perlin2d is a function that return a single value of perlin noise for a given 2d","noise.html#Generator.perlin2d","fn (Generator)"],
["noise","perlin3d is a function that return a single value of perlin noise for a given 3d","noise.html#Generator.perlin3d","fn (Generator)"],
["noise","randomize is a function that shuffle the permutation set inside the Generator st","noise.html#Generator.randomize","fn (Generator)"],
["noise","simplex_1d returns a simplex noise value for a given x position","noise.html#Generator.simplex_1d","fn (Generator)"],
["noise","simplex_2d returns a simplex noise value for a given x, y position","noise.html#Generator.simplex_2d","fn (Generator)"],
["noise","simplex_3d returns a simplex noise value for a given x, y, z position","noise.html#Generator.simplex_3d","fn (Generator)"],
["noise","simplex_4d returns a simplex noise value for a given x, y, z, w position","noise.html#Generator.simplex_4d","fn (Generator)"],
["noise","new is a function that return a new Generator struct","noise.html#Generator.new","fn "],
["plot","Annotation handles all the information needed to annotate plots","plot.html#Annotation","struct "],
["plot","Axis handles axis data","plot.html#Axis","struct "],
["plot","AxisTitle handles needed data to render an axis title","plot.html#AxisTitle","struct "],
["plot","RangeSlider handles range slider configuration for axes","plot.html#RangeSlider","struct "],
["plot","Font handles data to customize fonts","plot.html#Font","struct "],
["plot","Layout","plot.html#Layout","struct "],
["plot","Polar layout for radar/polar charts","plot.html#Polar","struct "],
["plot","RadialAxis for polar plots","plot.html#RadialAxis","struct "],
["plot","AngularAxis for polar plots","plot.html#AngularAxis","struct "],
["plot","Geo layout for geographic plots","plot.html#Geo","struct "],
["plot","GeoProjection for geographic projections","plot.html#GeoProjection","struct "],
["plot","GeoRotation for geographic rotation","plot.html#GeoRotation","struct "],
["plot","GeoCenter for geographic center","plot.html#GeoCenter","struct "],
["plot","Mapbox layout for mapbox plots","plot.html#Mapbox","struct "],
["plot","MapboxCenter for mapbox center","plot.html#MapboxCenter","struct "],
["plot","Light for mapbox plots","plot.html#Light","struct "],
["plot","Plot is the main structure that contains layout and traces to generate plots","plot.html#Plot","struct "],
["plot","box adds a box trace to the plot","plot.html#Plot.annotation","fn (Plot)"],
["plot","bar adds a bar trace to the plot","plot.html#Plot.bar","fn (Plot)"],
["plot","box adds a box trace to the plot","plot.html#Plot.box","fn (Plot)"],
["plot","candlestick adds a candlestick trace to the plot","plot.html#Plot.candlestick","fn (Plot)"],
["plot","chord adds a chord diagram trace to the plot","plot.html#Plot.chord","fn (Plot)"],
["plot","choropleth adds a choropleth map trace to the plot","plot.html#Plot.choropleth","fn (Plot)"],
["plot","contour adds a contour trace to the plot","plot.html#Plot.contour","fn (Plot)"],
["plot","debug_json prints the JSON that would be sent to Plotly.js for debugging","plot.html#Plot.debug_json","fn (Plot)"],
["plot","density adds a density plot trace to the plot","plot.html#Plot.density","fn (Plot)"],
["plot","densitymapbox adds a density on mapbox trace to the plot","plot.html#Plot.densitymapbox","fn (Plot)"],
["plot","funnel adds a funnel trace to the plot","plot.html#Plot.funnel","fn (Plot)"],
["plot","get_plotly_script returns the plot script as an html tag.","plot.html#Plot.get_plotly_script","fn (Plot)"],
["plot","heatmap adds a heatmap trace to the plot","plot.html#Plot.heatmap","fn (Plot)"],
["plot","histogram adds a histogram trace to the plot","plot.html#Plot.histogram","fn (Plot)"],
["plot","histogram2d adds a 2D histogram trace to the plot","plot.html#Plot.histogram2d","fn (Plot)"],
["plot","layout sets the layout of the plot","plot.html#Plot.layout","fn (Plot)"],
["plot","layout_json returns the layout configuration as a JSON string The returned JSON ","plot.html#Plot.layout_json","fn (Plot)"],
["plot","line adds a line trace to the plot","plot.html#Plot.line","fn (Plot)"],
["plot","network adds a network/graph trace to the plot","plot.html#Plot.network","fn (Plot)"],
["plot","parcoords adds a parallel coordinates trace to the plot","plot.html#Plot.parcoords","fn (Plot)"],
["plot","pie adds a pie trace to the plot","plot.html#Plot.pie","fn (Plot)"],
["plot","ridgeline adds a ridgeline plot trace to the plot","plot.html#Plot.ridgeline","fn (Plot)"],
["plot","sankey adds a Sankey diagram trace to the plot","plot.html#Plot.sankey","fn (Plot)"],
["plot","scatter adds a scatter trace to the plot","plot.html#Plot.scatter","fn (Plot)"],
["plot","scatter3d adds a scatter3d trace to the plot. If the z value is a 2D array, it i","plot.html#Plot.scatter3d","fn (Plot)"],
["plot","scattermapbox adds a scatter on mapbox trace to the plot","plot.html#Plot.scattermapbox","fn (Plot)"],
["plot","scatterpolar adds a polar/radar trace to the plot","plot.html#Plot.scatterpolar","fn (Plot)"],
["plot","show starts a web server and opens a browser window to display the plot.","plot.html#Plot.show","fn (Plot)"],
["plot","sunburst adds a sunburst trace to the plot","plot.html#Plot.sunburst","fn (Plot)"],
["plot","surface adds a surface trace to the plot","plot.html#Plot.surface","fn (Plot)"],
["plot","to_json returns the plot's traces and layout as separate JSON strings This metho","plot.html#Plot.to_json","fn (Plot)"],
["plot","traces_json returns the traces data as a JSON string The returned JSON is compat","plot.html#Plot.traces_json","fn (Plot)"],
["plot","treemap adds a treemap trace to the plot","plot.html#Plot.treemap","fn (Plot)"],
["plot","violin adds a violin trace to the plot","plot.html#Plot.violin","fn (Plot)"],
["plot","waterfall adds a waterfall trace to the plot","plot.html#Plot.waterfall","fn (Plot)"],
["plot","","plot.html#Plot.new","fn "],
["plot","PlotConfig is a configuration for the Plotly plot. It includes the configuration","plot.html#PlotConfig","struct "],
["plot","PlotlyScriptConfig is a configuration for the Plotly plot script.","plot.html#PlotlyScriptConfig","struct "],
["plot","Enum for trace types","plot.html#TraceType","enum "],
["plot","XType is a type for x-axis data","plot.html#XType","type "],
["plot","YType is a type for y-axis data","plot.html#YType","type "],
["plot","ZType is a type for z-axis data","plot.html#ZType","type "],
["plot","CommonTrace is a struct for common trace properties","plot.html#CommonTrace","struct "],
["plot","ScatterTrace is a struct for Scatter trace type","plot.html#ScatterTrace","struct "],
["plot","PieTrace is a struct for Pie trace type","plot.html#PieTrace","struct "],
["plot","HeatmapTrace is a struct for Heatmap trace type","plot.html#HeatmapTrace","struct "],
["plot","SurfaceTrace is a struct for Surface trace type","plot.html#SurfaceTrace","struct "],
["plot","Scatter3DTrace is a struct for Scatter3D trace type","plot.html#Scatter3DTrace","struct "],
["plot","BarTrace is a struct for Bar trace type","plot.html#BarTrace","struct "],
["plot","HistogramTrace is a struct for Histogram trace type","plot.html#HistogramTrace","struct "],
["plot","LineTrace is a struct for Line trace type","plot.html#LineTrace","struct "],
["plot","BoxTrace is a struct for Box trace type","plot.html#BoxTrace","struct "],
["plot","ViolinTrace is a struct for Violin trace type","plot.html#ViolinTrace","struct "],
["plot","ContourTrace is a struct for Contour trace type","plot.html#ContourTrace","struct "],
["plot","WaterfallTrace is a struct for Waterfall trace type","plot.html#WaterfallTrace","struct "],
["plot","SunburstTrace is a struct for Sunburst trace type","plot.html#SunburstTrace","struct "],
["plot","TreemapTrace is a struct for Treemap trace type","plot.html#TreemapTrace","struct "],
["plot","CandlestickTrace is a struct for Candlestick trace type","plot.html#CandlestickTrace","struct "],
["plot","FunnelTrace is a struct for Funnel trace type","plot.html#FunnelTrace","struct "],
["plot","ScatterPolarTrace is a struct for Radar/Polar trace type","plot.html#ScatterPolarTrace","struct "],
["plot","Marker is a struct for marker properties in a trace","plot.html#Marker","struct "],
["plot","Line is a struct for line properties in a trace","plot.html#Line","struct "],
["plot","Bins is a struct for bin limits in a histogram trace","plot.html#Bins","struct "],
["plot","Box is a struct for box configuration in violin plots","plot.html#Box","struct "],
["plot","Contours is a struct for contour configuration","plot.html#Contours","struct "],
["plot","Connector is a struct for waterfall and funnel connectors","plot.html#Connector","struct "],
["plot","Decreasing is a struct for decreasing values styling","plot.html#Decreasing","struct "],
["plot","Increasing is a struct for increasing values styling","plot.html#Increasing","struct "],
["plot","Totals is a struct for totals styling in waterfall charts","plot.html#Totals","struct "],
["plot","PathBar is a struct for treemap pathbar configuration","plot.html#PathBar","struct "],
["plot","Trace is a sum type for representing different trace types","plot.html#Trace","type "],
["plot","","plot.html#Trace.trace_type","fn (Trace)"],
["plot","Dimension is a struct for parallel coordinates dimensions","plot.html#Dimension","struct "],
["plot","ParallelLine is a struct for parallel coordinates line styling","plot.html#ParallelLine","struct "],
["plot","SankeyNode is a struct for Sankey diagram nodes","plot.html#SankeyNode","struct "],
["plot","SankeyLink is a struct for Sankey diagram links","plot.html#SankeyLink","struct "],
["plot","NetworkNodes is a struct for network graph nodes","plot.html#NetworkNodes","struct "],
["plot","NetworkEdges is a struct for network graph edges","plot.html#NetworkEdges","struct "],
["plot","Cluster is a struct for mapbox clustering","plot.html#Cluster","struct "],
["plot","Histogram2DTrace is a struct for 2D Histogram trace type","plot.html#Histogram2DTrace","struct "],
["plot","DensityTrace is a struct for Density plot trace type","plot.html#DensityTrace","struct "],
["plot","RidgelineTrace is a struct for Ridgeline plot trace type","plot.html#RidgelineTrace","struct "],
["plot","ParallelCoordinatesTrace is a struct for Parallel Coordinates trace type","plot.html#ParallelCoordinatesTrace","struct "],
["plot","SankeyTrace is a struct for Sankey diagram trace type","plot.html#SankeyTrace","struct "],
["plot","ChordTrace is a struct for Chord diagram trace type","plot.html#ChordTrace","struct "],
["plot","NetworkTrace is a struct for Network/Graph trace type","plot.html#NetworkTrace","struct "],
["plot","ChoroplethTrace is a struct for Choropleth map trace type","plot.html#ChoroplethTrace","struct "],
["plot","ScatterMapboxTrace is a struct for Scatter on mapbox trace type","plot.html#ScatterMapboxTrace","struct "],
["plot","DensityMapboxTrace is a struct for Density on mapbox trace type","plot.html#DensityMapboxTrace","struct "],
["poly","eval is a function that evaluates a polynomial P(x) = a_n * x^n + a_{n-1} * x^{n","poly.html#eval","fn "],
["poly","eval_derivs evaluates a polynomial P(x) and its derivatives P'(x), P''(x), ..., ","poly.html#eval_derivs","fn "],
["poly","solve_quadratic solves the quadratic equation ax^2 + bx + c = 0 using the quadra","poly.html#solve_quadratic","fn "],
["poly","solve_cubic solves the cubic equation x^3 + ax^2 + bx + c = 0 using Cardano's fo","poly.html#solve_cubic","fn "],
["poly","companion_matrix creates a companion matrix for the polynomial P(x) = a_n * x^n ","poly.html#companion_matrix","fn "],
["poly","balance_companion_matrix balances a companion matrix C to improve numerical stab","poly.html#balance_companion_matrix","fn "],
["poly","add adds two polynomials: (a_n * x^n + ... + a_0) + (b_m * x^m + ... + b_0) Inpu","poly.html#add","fn "],
["poly","subtract subtracts two polynomials: (a_n * x^n + ... + a_0) - (b_m * x^m + ... +","poly.html#subtract","fn "],
["poly","multiply multiplies two polynomials: (a_n * x^n + ... + a_0) * (b_m * x^m + ... ","poly.html#multiply","fn "],
["poly","divide divides two polynomials: (a_n * x^n + ... + a_0) / (b_m * x^m + ... + b_0","poly.html#divide","fn "],
["prime","","prime.html#is_prime","fn "],
["prime","prime sieve returns a list of primes up the number specified","prime.html#prime_sieve","fn "],
["quaternion","","quaternion.html#Quaternion","struct "],
["quaternion","","quaternion.html#Quaternion.*","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.+","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.-","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion./","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.abs","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.add","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.angle","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.conjugate","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.copy","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.divide","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.equal","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.exp","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.inverse","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.is_finite","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.is_greater","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.is_greaterequal","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.is_inf","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.is_less","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.is_lessequal","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.is_nan","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.is_zero","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.lerp","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.log","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.multiply","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.nlerp","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.norm","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.normalized","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.opposite","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.parity_antisymmetric_part","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.parity_conjugate","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.parity_symmetric_part","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.pow","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.rotation_chordal_distance","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.rotation_intrinsic_distance","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.rotor_chordal_distance","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.rotor_intrinsic_distance","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.scalar_add","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.scalar_divide","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.scalar_multiply","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.scalar_pow","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.scalar_subtract","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.slerp","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.sqrt","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.squad","fn (Quaternion)"],
["quaternion","To String method w + xi + yj + zk","quaternion.html#Quaternion.str","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.subtract","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.x_parity_antisymmetric_part","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.x_parity_conjugate","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.x_parity_symmetric_part","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.y_parity_antisymmetric_part","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.y_parity_conjugate","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.y_parity_symmetric_part","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.z_parity_antisymmetric_part","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.z_parity_conjugate","fn (Quaternion)"],
["quaternion","","quaternion.html#Quaternion.z_parity_symmetric_part","fn (Quaternion)"],
["quaternion","","quaternion.html#quaternion","fn "],
["quaternion","","quaternion.html#id","fn "],
["quaternion","","quaternion.html#from_axis_anglef3","fn "],
["quaternion","","quaternion.html#from_spherical_coords","fn "],
["quaternion","","quaternion.html#from_euler_angles","fn "],
["roots","Bisection implements a bisection method for finding the root of a function","roots.html#Bisection","struct "],
["roots","next returns the next iteration of the bisection method.","roots.html#Bisection.next","fn (Bisection)"],
["roots","solve solves for the root of the function using the bisection method.","roots.html#Bisection.solve","fn (Bisection)"],
["roots","BisectionParams contains the parameters for the bisection method","roots.html#BisectionParams","struct "],
["roots","Bisection.new creates a new Bisection object with the given parameters","roots.html#Bisection.new","fn "],
["roots","","roots.html#BisectionIteration","struct "],
["roots","Brent implements Brent's method for finding roots of a function in a given inter","roots.html#Brent","struct "],
["roots","Brent.new creates a new Brent object","roots.html#Brent.new","fn "],
["roots","BrentIteration is a single iteration of Brent's method","roots.html#BrentIteration","struct "],
["roots","Find the root of a function using Newton's algorithm with the Armijo line search","roots.html#newton","fn "],
["roots","Find the root of a function by combining Newton's method with the bisection meth","roots.html#newton_bisection","fn "],
["util","int_ints_map_append appends a new item to a map of slice.","util.html#int_ints_map_append","fn "],
["util","str_ints_map_append appends a new item to a map of slice.","util.html#str_ints_map_append","fn "],
["util","str_flts_map_append appends a new item to a map of slice.","util.html#str_flts_map_append","fn "],
["util","Observer is an interface to objects that need to observe something the data obse","util.html#Observer","interface "],
["util","Observable indicates that an object is observable; i.e. it has a list of interes","util.html#Observable","struct "],
["util","add_observer adds an object to the list of interested observers","util.html#Observable.add_observer","fn (Observable)"],
["util","notify_update notifies observers of updates","util.html#Observable.notify_update","fn (Observable)"],
["util","range returns a list with int values in the interval [0, n)","util.html#arange","fn "],
["util","","util.html#RangeStep","struct "],
["util","range returns a list with int values in the interval [start, stop)","util.html#range","fn "],
["util","get_many returns an array containing the values in the given idxs","util.html#get_many","fn "],
["util","lin_space returns evenly spaced numbers over a specified closed interval.","util.html#lin_space","fn "],
["util","move_ith_to_end removes element at i from the array, and puts it at the end is O","util.html#move_ith_to_end","fn "],
["vcl","ImageChannelOrder represents available image types","vcl.html#ImageChannelOrder","enum "],
["vcl","ImageChannelDataType describes the size of the channel data type","vcl.html#ImageChannelDataType","enum "],
["vcl","Bytes is a memory buffer on the device that holds []byte","vcl.html#Bytes","struct "],
["vcl","size the size of the bytes buffer","vcl.html#Bytes.size","fn (Bytes)"],
["vcl","release releases the buffer on the device","vcl.html#Bytes.release","fn (Bytes)"],
["vcl","load copies the data from host data to device buffer it's a non-blocking call, c","vcl.html#Bytes.load","fn (Bytes)"],
["vcl","data gets data from device, it's a blocking call","vcl.html#Bytes.data","fn (Bytes)"],
["vcl","map applies an map kernel on all elements of the buffer","vcl.html#Bytes.map","fn (Bytes)"],
["vcl","buffer returns the underlying buffer","vcl.html#Bytes.buffer","fn (Bytes)"],
["vcl","Device the only needed entrence for the VCL represents the device on which memor","vcl.html#Device","struct "],
["vcl","add_program compiles program source from OpenCL C code This method takes OpenCL ","vcl.html#Device.add_program","fn (Device)"],
["vcl","bytes allocates new memory buffer with specified size on device","vcl.html#Device.bytes","fn (Device)"],
["vcl","driver_version device info - driver version","vcl.html#Device.driver_version","fn (Device)"],
["vcl","extensions device info - extensions","vcl.html#Device.extensions","fn (Device)"],
["vcl","from_image creates new Image and copies data from Image","vcl.html#Device.from_image","fn (Device)"],
["vcl","image allocates an image buffer","vcl.html#Device.image","fn (Device)"],
["vcl","kernel returns a kernel if retrieving the kernel didn't complete the function wi","vcl.html#Device.kernel","fn (Device)"],
["vcl","name device info - name","vcl.html#Device.name","fn (Device)"],
["vcl","open_clc_version device info - OpenCL C version","vcl.html#Device.open_clc_version","fn (Device)"],
["vcl","profile device info - profile","vcl.html#Device.profile","fn (Device)"],
["vcl","release releases the device","vcl.html#Device.release","fn (Device)"],
["vcl","","vcl.html#Device.str","fn (Device)"],
["vcl","vector allocates new vector buffer with specified length","vcl.html#Device.vector","fn (Device)"],
["vcl","vendor device info - vendor","vcl.html#Device.vendor","fn (Device)"],
["vcl","version device info - version","vcl.html#Device.version","fn (Device)"],
["vcl","","vcl.html#DeviceType","enum "],
["vcl","ErrVCL converts that OpenCL error code to an V error","vcl.html#ErrVCL","type "],
["vcl","","vcl.html#ErrVCL.err","fn (ErrVCL)"],
["vcl","","vcl.html#error_from_code","fn "],
["vcl","","vcl.html#error_or_default","fn "],
["vcl","","vcl.html#typed_error","fn "],
["vcl","","vcl.html#vcl_error","fn "],
["vcl","","vcl.html#panic_on_error","fn "],
["vcl","Rect is a struct that represents a rectangle shape","vcl.html#Rect","struct "],
["vcl","IImage holds the fileds and data needed to represent a bitmap/pixel based image ","vcl.html#IImage","interface "],
["vcl","Image memory buffer on the device with image data","vcl.html#Image","struct "],
["vcl","release releases the buffer on the device","vcl.html#Image.release","fn (Image)"],
["vcl","","vcl.html#Image.data","fn (Image)"],
["vcl","","vcl.html#ArgumentType","interface "],
["vcl","","vcl.html#UnsupportedArgumentTypeError","struct "],
["vcl","","vcl.html#UnsupportedArgumentTypeError.msg","fn (UnsupportedArgumentTypeError)"],
["vcl","Kernel represent a single kernel","vcl.html#Kernel","struct "],
["vcl","global returns an kernel with global size set","vcl.html#Kernel.global","fn (Kernel)"],
["vcl","KernelWithGlobal is a kernel with the global size set to run the kernel it must ","vcl.html#KernelWithGlobal","struct "],
["vcl","local ets the local work sizes and returns an KernelCall which takes kernel argu","vcl.html#KernelWithGlobal.local","fn (KernelWithGlobal)"],
["vcl","KernelCall is a kernel with global and local work sizes set and it's ready to be","vcl.html#KernelCall","struct "],
["vcl","run calls the kernel on its device with specified global and local work sizes an","vcl.html#KernelCall.run","fn (KernelCall)"],
["vcl","get_devices returns all devices of all platforms with specified type","vcl.html#get_devices","fn "],
["vcl","get_default_device ...","vcl.html#get_default_device","fn "],
["vcl","Vector is a memory buffer on device that holds []T","vcl.html#Vector","struct "],
["vcl","","vcl.html#Vector[T]","type "],
["vcl","Length the length of the vector","vcl.html#Vector[T].length","fn (Vector[T])"],
["vcl","Release releases the buffer on the device","vcl.html#Vector[T].release","fn (Vector[T])"],
["vcl","load copies the T data from host data to device buffer it's a non-blocking call,","vcl.html#Vector[T].load","fn (Vector[T])"],
["vcl","data gets T data from device, it's a blocking call","vcl.html#Vector[T].data","fn (Vector[T])"],
["vcl","map applies an map kernel on all elements of the vector","vcl.html#Vector[T].map","fn (Vector[T])"],
["vcl","buffer returns the underlying buffer","vcl.html#Vector[T].buffer","fn (Vector[T])"],
["vcl.internal.dl","","vcl.internal.dl.html#get_sym","fn "],
];

